/**
* @vue/shared v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const Se={},ze=()=>{},Ce=Object.assign,Oe=Array.isArray,j=e=>typeof e=="function",Me=e=>typeof e=="string",Ne=e=>typeof e=="symbol";let X;const L=()=>X||(X=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});/**
* @vue/reactivity v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Ne));function P(e){const t=e&&e.__v_raw;return t?P(t):e}function Te(e){return e?e.__v_isRef===!0:!1}/**
* @vue/runtime-core v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const v=[];function kt(e){v.push(e)}function Et(){v.pop()}let W=!1;function It(e,...t){if(W)return;W=!0;const n=v.length?v[v.length-1].component:null,o=n&&n.appContext.config.warnHandler,s=Fe();if(o)A(o,n,11,[e+t.map(r=>{var i,c;return(c=(i=r.toString)==null?void 0:i.call(r))!=null?c:JSON.stringify(r)}).join(""),n&&n.proxy,s.map(({vnode:r})=>`at <${re(n,r.type)}>`).join(`
`),s]);else{const r=[`[Vue warn]: ${e}`,...t];s.length&&r.push(`
`,...$e(s)),console.warn(...r)}W=!1}function Fe(){let e=v[v.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const o=e.component&&e.component.parent;e=o&&o.vnode}return t}function $e(e){const t=[];return e.forEach((n,o)=>{t.push(...o===0?[]:[`
`],...Ve(n))}),t}function Ve({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"",o=e.component?e.component.parent==null:!1,s=` at <${re(e.component,e.type,o)}`,r=">"+n;return e.props?[s,...Re(e.props),r]:[s+r]}function Re(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(o=>{t.push(...Z(o,e[o]))}),n.length>3&&t.push(" ..."),t}function Z(e,t,n){return Me(t)?(t=JSON.stringify(t),n?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[`${e}=${t}`]:Te(t)?(t=Z(e,P(t.value),!0),n?t:[`${e}=Ref<`,t,">"]):j(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=P(t),n?t:[`${e}=`,t])}const vt={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function A(e,t,n,o){try{return o?e(...o):e()}catch(s){ee(s,t,n)}}function ee(e,t,n,o=!0){const s=t?t.vnode:null,{errorHandler:r,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||Se;if(t){let c=t.parent;const l=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;c;){const a=c.ec;if(a){for(let h=0;h<a.length;h++)if(a[h](e,l,u)===!1)return}c=c.parent}if(r){A(r,null,10,[e,l,u]);return}}De(e,n,s,o,i)}function De(e,t,n,o=!0,s=!1){if(s)throw e;console.error(e)}const b=[];let x=-1;const S=[];let k=null,z=0;const je=Promise.resolve();let q=null;const Le=100;function Pe(e){let t=x+1,n=b.length;for(;t<n;){const o=t+n>>>1,s=b[o],r=M(s);r<e||r===e&&s.flags&2?t=o+1:n=o}return t}function We(e){if(!(e.flags&1)){const t=M(e),n=b[b.length-1];!n||!(e.flags&2)&&t>=M(n)?b.push(e):b.splice(Pe(t),0,e),e.flags|=1,te()}}function te(){q||(q=je.then(ne))}function Ae(e){Oe(e)?S.push(...e):k&&e.id===-1?k.splice(z+1,0,e):e.flags&1||(S.push(e),e.flags|=1),te()}function qe(e){if(S.length){const t=[...new Set(S)].sort((n,o)=>M(n)-M(o));if(S.length=0,k){k.push(...t);return}for(k=t,z=0;z<k.length;z++){const n=k[z];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}k=null,z=0}}const M=e=>e.id==null?e.flags&2?-1:1/0:e.id;function ne(e){const t=ze;try{for(x=0;x<b.length;x++){const n=b[x];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),A(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;x<b.length;x++){const n=b[x];n&&(n.flags&=-2)}x=-1,b.length=0,qe(e),q=null,(b.length||S.length)&&ne(e)}}function St(e,t){const n=e.get(t)||0;if(n>Le){const o=t.i,s=o&&se(o.type);return ee(`Maximum recursive updates exceeded${s?` in component <${s}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return e.set(t,n+1),!1}const H=new Map,F=new Map;function zt(e,t){return F.has(e)?!1:(F.set(e,{initialDef:$(t),instances:new Set}),!0)}function $(e){return Je(e)?e.__vccOpts:e}function Ct(e,t){const n=F.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(o=>{t&&(o.render=t,$(o.type).render=t),o.renderCache=[],o.update()}))}function Ot(e,t){const n=F.get(e);if(!n)return;t=$(t),oe(n.initialDef,t);const o=[...n.instances];for(let s=0;s<o.length;s++){const r=o[s],i=$(r.type);let c=H.get(i);c||(i!==n.initialDef&&oe(i,t),H.set(i,c=new Set)),c.add(r),r.appContext.propsCache.delete(r.type),r.appContext.emitsCache.delete(r.type),r.appContext.optionsCache.delete(r.type),r.ceReload?(c.add(r),r.ceReload(t.styles),c.delete(r)):r.parent?We(()=>{r.parent.update(),c.delete(r)}):r.appContext.reload?r.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),r.root.ce&&r!==r.root&&r.root.ce._removeChildStyle(i)}Ae(()=>{H.clear()})}function oe(e,t){Ce(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Mt(e){return(t,n)=>{try{return e(t,n)}catch(o){console.error(o),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}L().requestIdleCallback,L().cancelIdleCallback;const Nt={};{const e=L(),t=(n,o)=>{let s;return(s=e[n])||(s=e[n]=[]),s.push(o),r=>{s.length>1?s.forEach(i=>i(r)):s[0](r)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}const He=/(?:^|[-_])(\w)/g,Ue=e=>e.replace(He,t=>t.toUpperCase()).replace(/[-_]/g,"");function se(e,t=!0){return j(e)?e.displayName||e.name:e.name||t&&e.__name}function re(e,t,n=!1){let o=se(t);if(!o&&t.__file){const s=t.__file.match(/([^/\\]+)\.\w+$/);s&&(o=s[1])}if(!o&&e&&e.parent){const s=r=>{for(const i in r)if(r[i]===t)return i};o=s(e.components||e.parent.type.components)||s(e.appContext.components)}return o?Ue(o):n?"App":"Anonymous"}function Je(e){return j(e)&&"__vccOpts"in e}[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:Ge}=Object,{fromEntries:Be}=Object,Ye="ENTRIES",ie="KEYS",ce="VALUES",y="";class U{set;_type;_path;constructor(t,n){const o=t._tree,s=Array.from(o.keys());this.set=t,this._type=n,this._path=s.length>0?[{node:o,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:n}=C(this._path);if(C(n)===y)return{done:!1,value:this.result()};const o=t.get(C(n));return this._path.push({node:o,keys:Array.from(o.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=C(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>C(t)).filter(t=>t!==y).join("")}value(){return C(this._path).node.get(y)}result(){switch(this._type){case ce:return this.value();case ie:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const C=e=>e[e.length-1],Ke=(e,t,n)=>{const o=new Map;if(typeof t!="string")return o;const s=t.length+1,r=s+n,i=new Uint8Array(r*s).fill(n+1);for(let c=0;c<s;++c)i[c]=c;for(let c=1;c<r;++c)i[c*s]=c;return le(e,t,n,o,i,1,s,""),o},le=(e,t,n,o,s,r,i,c)=>{const l=r*i;e:for(const u of e.keys())if(u===y){const a=s[l-1];a<=n&&o.set(c,[e.get(u),a])}else{let a=r;for(let h=0;h<u.length;++h,++a){const g=u[h],m=i*a,w=m-i;let d=s[m];const f=Math.max(0,a-n-1),p=Math.min(i-1,a+n);for(let _=f;_<p;++_){const E=g!==t[_],D=s[w+_]+ +E,T=s[w+_+1]+1,I=s[m+_]+1,O=s[m+_+1]=Math.min(D,T,I);O<d&&(d=O)}if(d>n)continue e}le(e.get(u),t,n,o,s,a,i,c+u)}};let ue=class N{_tree;_prefix;_size=void 0;constructor(t=new Map,n=""){this._tree=t,this._prefix=n}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[n,o]=V(this._tree,t.slice(this._prefix.length));if(n===void 0){const[s,r]=B(o);for(const i of s.keys())if(i!==y&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),s.get(i)),new N(c,t)}}return new N(n,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Qe(this._tree,t)}entries(){return new U(this,Ye)}forEach(t){for(const[n,o]of this)t(n,o,this)}fuzzyGet(t,n){return Ke(this._tree,t,n)}get(t){const n=J(this._tree,t);return n!==void 0?n.get(y):void 0}has(t){return J(this._tree,t)?.has(y)??!1}keys(){return new U(this,ie)}set(t,n){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,G(this._tree,t).set(y,n),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);return o.set(y,n(o.get(y))),this}fetch(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);let s=o.get(y);return s===void 0&&o.set(y,s=n()),s}values(){return new U(this,ce)}[Symbol.iterator](){return this.entries()}static from(t){const n=new N;for(const[o,s]of t)n.set(o,s);return n}static fromObject(t){return N.from(Object.entries(t))}};const V=(e,t,n=[])=>{if(t.length===0||e==null)return[e,n];for(const o of e.keys())if(o!==y&&t.startsWith(o))return n.push([e,o]),V(e.get(o),t.slice(o.length),n);return n.push([e,t]),V(void 0,"",n)},J=(e,t)=>{if(t.length===0||!e)return e;for(const n of e.keys())if(n!==y&&t.startsWith(n))return J(e.get(n),t.slice(n.length))},G=(e,t)=>{const n=t.length;e:for(let o=0;e&&o<n;){for(const r of e.keys())if(r!==y&&t[o]===r[0]){const i=Math.min(n-o,r.length);let c=1;for(;c<i&&t[o+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(o,o+c),u),e.delete(r),e=u}o+=c;continue e}const s=new Map;return e.set(t.slice(o),s),s}return e},Qe=(e,t)=>{const[n,o]=V(e,t);if(n!==void 0){if(n.delete(y),n.size===0)ae(o);else if(n.size===1){const[s,r]=n.entries().next().value;fe(o,s,r)}}},ae=e=>{if(e.length===0)return;const[t,n]=B(e);if(t.delete(n),t.size===0)ae(e.slice(0,-1));else if(t.size===1){const[o,s]=t.entries().next().value;o!==y&&fe(e.slice(0,-1),o,s)}},fe=(e,t,n)=>{if(e.length===0)return;const[o,s]=B(e);o.set(s+t,n),o.delete(s)},B=e=>e[e.length-1],Xe=(e,t)=>{const n=e._idToShortId.get(t);if(n!=null)return e._storedFields.get(n)},Ze=/[\n\r\p{Z}\p{P}]+/u,Y="or",de="and",et="and_not",tt=(e,t)=>{e.includes(t)||e.push(t)},he=(e,t)=>{for(const n of t)e.includes(n)||e.push(n)},pe=({score:e},{score:t})=>t-e,nt=()=>new Map,R=e=>{const t=new Map;for(const n of Object.keys(e))t.set(parseInt(n,10),e[n]);return t},ge=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,me={[Y]:(e,t)=>{for(const n of t.keys()){const o=e.get(n);if(o==null)e.set(n,t.get(n));else{const{score:s,terms:r,match:i}=t.get(n);o.score=o.score+s,o.match=Object.assign(o.match,i),he(o.terms,r)}}return e},[de]:(e,t)=>{const n=new Map;for(const o of t.keys()){const s=e.get(o);if(s==null)continue;const{score:r,terms:i,match:c}=t.get(o);he(s.terms,i),n.set(o,{score:s.score+r,terms:s.terms,match:Object.assign(s.match,c)})}return n},[et]:(e,t)=>{for(const n of t.keys())e.delete(n);return e}},ot=(e,t,n,o,s,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(n-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*o/s)))},st=e=>(t,n,o)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,n,o):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,n,o):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,n,o):1}),_e=(e,t,n,o)=>{for(const s of Object.keys(e._fieldIds))if(e._fieldIds[s]===n){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${o}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},rt=(e,t,n,o)=>{if(!e._index.has(o)){_e(e,n,t,o);return}const s=e._index.fetch(o,nt),r=s.get(t),i=r?.get(n);!r||typeof i>"u"?_e(e,n,t,o):i<=1?r.size<=1?s.delete(t):r.delete(n):r.set(n,i-1),e._index.get(o).size===0&&e._index.delete(o)},it={k:1.2,b:.7,d:.5},ct={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(Ze),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},ye={combineWith:Y,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:it},lt={combineWith:de,prefix:(e,t,n)=>t===n.length-1},ut={batchSize:1e3,batchWait:10},we={minDirtFactor:.1,minDirtCount:20},at={...ut,...we},be=Symbol("*"),ft=(e,t)=>{const n=new Map,o={...e._options.searchOptions,...t};for(const[s,r]of e._documentIds){const i=o.boostDocument?o.boostDocument(r,"",e._storedFields.get(s)):1;n.set(s,{score:i,terms:[],match:{}})}return n},xe=(e,t=Y)=>{if(e.length===0)return new Map;const n=t.toLowerCase();if(!(n in me))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(me[n])},K=(e,t,n,o,s,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const a of Object.keys(i)){const h=i[a],g=e._fieldIds[a],m=r.get(g);if(m==null)continue;let w=m.size;const d=e._avgFieldLength[g];for(const f of m.keys()){if(!e._documentIds.has(f)){rt(e,g,f,n),w-=1;continue}const p=c?c(e._documentIds.get(f),n,e._storedFields.get(f)):1;if(!p)continue;const _=m.get(f),E=e._fieldLength.get(f)[g],D=ot(_,w,e._documentCount,E,d,l),T=o*s*h*p*D,I=u.get(f);if(I){I.score+=T,tt(I.terms,t);const O=ge(I.match,n);O?O.push(a):I.match[n]=[a]}else u.set(f,{score:T,terms:[t],match:{[n]:[a]}})}}return u},dt=(e,t,n)=>{const o={...e._options.searchOptions,...n},s=(o.fields??e._options.fields).reduce((d,f)=>({...d,[f]:ge(o.boost,f)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=o,{fuzzy:u,prefix:a}={...ye.weights,...i},h=e._index.get(t.term),g=K(e,t.term,t.term,1,t.termBoost,h,s,r,l);let m,w;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,f=d<1?Math.min(c,Math.round(t.term.length*d)):d;f&&(w=e._index.fuzzyGet(t.term,f))}if(m)for(const[d,f]of m){const p=d.length-t.term.length;if(!p)continue;w?.delete(d);const _=a*d.length/(d.length+.3*p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}if(w)for(const d of w.keys()){const[f,p]=w.get(d);if(!p)continue;const _=u*d.length/(d.length+p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}return g},ke=(e,t,n={})=>{if(t===be)return ft(e,n);if(typeof t!="string"){const a={...n,...t,queries:void 0},h=t.queries.map(g=>ke(e,g,a));return xe(h,a.combineWith)}const{tokenize:o,processTerm:s,searchOptions:r}=e._options,i={tokenize:o,processTerm:s,...r,...n},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(a=>l(a)).filter(a=>!!a).map(st(i)).map(a=>dt(e,a,i));return xe(u,i.combineWith)},Ee=(e,t,n={})=>{const{searchOptions:o}=e._options,s={...o,...n},r=ke(e,t,n),i=[];for(const[c,{score:l,terms:u,match:a}]of r){const h=u.length||1,g={id:e._documentIds.get(c),score:l*h,terms:Object.keys(a),queryTerms:u,match:a};Object.assign(g,e._storedFields.get(c)),(s.filter==null||s.filter(g))&&i.push(g)}return t===be&&s.boostDocument==null||i.sort(pe),i},ht=(e,t,n={})=>{n={...e._options.autoSuggestOptions,...n};const o=new Map;for(const{score:r,terms:i}of Ee(e,t,n)){const c=i.join(" "),l=o.get(c);l!=null?(l.score+=r,l.count+=1):o.set(c,{score:r,terms:i,count:1})}const s=[];for(const[r,{score:i,terms:c,count:l}]of o)s.push({suggestion:r,terms:c,score:i/l});return s.sort(pe),s};class pt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const n=t.autoVacuum==null||t.autoVacuum===!0?at:t.autoVacuum;this._options={...ct,...t,autoVacuum:n,searchOptions:{...ye,...t.searchOptions},autoSuggestOptions:{...lt,...t.autoSuggestOptions}},this._index=new ue,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=we,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[n,o]of this._index){const s={};for(const[r,i]of o)s[r]=Object.fromEntries(i);t.push([n,s])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let n=0;n<t.length;n++)this._fieldIds[t[n]]=n}}const gt=e=>new pt(e),mt=({documentCount:e,nextId:t,fieldIds:n,averageFieldLength:o,dirtCount:s,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=gt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=n,c._avgFieldLength=o,c._dirtCount=s??0,c._index=new ue,c},_t=(e,t)=>{const{index:n,documentIds:o,fieldLength:s,storedFields:r}=e,i=mt(e,t);i._documentIds=R(o),i._fieldLength=R(s),i._storedFields=R(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of n){const u=new Map;for(const a of Object.keys(l))u.set(parseInt(a,10),R(l[a]));i._index.set(c,u)}return i},Q=(e,t)=>{const n=e.toLowerCase(),o=t.toLowerCase(),s=[];let r=0,i=0;const c=(u,a=!1)=>{let h;i===0?h=u.length>20?`… ${u.slice(-20)}`:u:a?h=u.length+i>100?`${u.slice(0,100-i)}… `:u:h=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,h&&s.push(h),i+=h.length,a||(s.push(["mark",t]),i+=t.length,i>=100&&s.push(" …"))};let l=n.indexOf(o,r);if(l===-1)return null;for(;l>=0;){const u=l+o.length;if(c(e.slice(r,l)),r=u,i>100)break;l=n.indexOf(o,r)}return i<100&&c(e.slice(r),!0),s},{entries:yt}=Object,wt=(e,t)=>t.contents.reduce((n,[,o])=>n+o,0)-e.contents.reduce((n,[,o])=>n+o,0),bt=(e,t)=>Math.max(...t.contents.map(([,n])=>n))-Math.max(...e.contents.map(([,n])=>n)),Ie=(e,t,n={},o="max")=>{const s={};return Ee(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...n}).forEach(r=>{const{id:i,terms:c,score:l}=r,u=i.includes("@"),a=i.includes("#"),[h,g]=i.split(/[#@]/),m=Number(h),w=c.sort((f,p)=>f.length-p.length).filter((f,p)=>c.slice(p+1).every(_=>!_.includes(f))),{contents:d}=s[m]??={title:"",contents:[]};if(u)d.push([{type:"customField",id:m,index:g,display:w.map(f=>r.c.map(p=>Q(p,f))).flat().filter(f=>f!==null)},l]);else{const f=w.map(p=>Q(r.h,p)).filter(p=>p!==null);if(f.length&&d.push([{type:a?"heading":"title",id:m,...a&&{anchor:g},display:f},l]),"t"in r&&r.t)for(const p of r.t){const _=w.map(E=>Q(p,E)).filter(E=>E!==null);_.length&&d.push([{type:"text",id:m,...a&&{anchor:g},display:_},l])}}}),yt(s).sort(([,r],[,i])=>(o?wt:bt)(r,i)).map(([r,{title:i,contents:c}])=>{if(!i){const l=Xe(t,r);l&&(i=l.h)}return{title:i,contents:c.map(([l])=>l)}})},ve=(e,t,n={})=>{const o=ht(t,e,{fuzzy:.2,maxFuzzy:3,...n}).map(({suggestion:s})=>s);return e.includes(" ")?o:o.filter(s=>!s.includes(" "))},xt=Be(Ge(JSON.parse("{\"/\":{\"documentCount\":264,\"nextId\":264,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"2#一、什么是-port\",\"4\":\"2#二、port-分类总览\",\"5\":\"2#_1-按通信角色\",\"6\":\"2#_2-按接口类型\",\"7\":\"2#三、连接方式解析\",\"8\":\"2#✅-assembly-connector\",\"9\":\"2#✅-delegation-connector\",\"10\":\"2#四、常见误区与连接限制\",\"11\":\"2#❌-错误连接-senderport-同时参与-delegation-和-assembly\",\"12\":\"2#✅-正确做法\",\"13\":\"2#❌-错误连接-receiverport-被多个-senderport-连接-fan-in\",\"14\":\"2#✅-替代方案\",\"15\":\"2#五、senderport-fan-out-支持-1-n\",\"16\":\"2#六、结构化接口的字段级连接-高级实践\",\"17\":\"2#✅-场景描述\",\"18\":\"2#✅-合法连接方式\",\"19\":\"2#⚙️-工具配置建议\",\"20\":\"2#📌-注意事项\",\"21\":\"2#七、port-设计推荐实践\",\"22\":\"2#八、总结\",\"23\":\"2#十、结语\",\"24\":\"2#autosar-port-不只是通信通道-它是组件建模、架构清晰与系统稳定的基础。在项目建模初期-保持-port-连接职责单一、遵循连接规则-能极大提高系统的可维护性和工具链兼容性。\",\"25\":\"3\",\"26\":\"3#can通信基本原理\",\"27\":\"3#can通信概述\",\"28\":\"3#can标准及原理图\",\"29\":\"3#can特性\",\"30\":\"3#can功能特性\",\"31\":\"3#can系统构成\",\"32\":\"3#autosar-can协议栈概述\",\"33\":\"3#can-driver\",\"34\":\"3#mcal相关配置\",\"35\":\"3#cantrcv\",\"36\":\"3#cantrcv-模式切换\",\"37\":\"3#mcal配置\",\"38\":\"3#autosar-can协议栈集成\",\"39\":\"3#autosar-can调试策略\",\"40\":\"3#参考链接\",\"41\":\"3@0\",\"42\":\"3@1\",\"43\":\"4\",\"44\":\"4#autosar技术标准框架\",\"45\":\"4#adaptive-platform-ap\",\"46\":\"4#classic-platform-cp\",\"47\":\"4#foundation-fo\",\"48\":\"4#fo部分所定义的通用特性\",\"49\":\"4#ap、cp、fo间的关系\",\"50\":\"4#cp-与-ap-的区别\",\"51\":\"4#基于区域集中式ee架构的整车部署\",\"52\":\"4#autosar标准制定方式\",\"53\":\"4#autosar年度关键节点\",\"54\":\"4#参考链接\",\"55\":\"4@0\",\"56\":\"4@1\",\"57\":\"5\",\"58\":\"5#项目构建\",\"59\":\"5#部署到gitpages\",\"60\":\"5@0\",\"61\":\"5@1\",\"62\":\"6\",\"63\":\"6#余法运算公式\",\"64\":\"6@0\",\"65\":\"6@1\",\"66\":\"7\",\"67\":\"7#一、前提\",\"68\":\"7#_1-本书背景及重要性\",\"69\":\"7#_1-背景\",\"70\":\"7#_2-重要性\",\"71\":\"7#_2-基础概念\",\"72\":\"7#_1-和-符号表示\",\"73\":\"7#_2-interface概念\",\"74\":\"7#_3-蓝图-blueprint\",\"75\":\"7#二、设计模式的定义和分类\",\"76\":\"7#_1-设计模式的概念\",\"77\":\"7#_2-模式构成\",\"78\":\"7#_3-模式和算法的区别\",\"79\":\"7#_4-设计模式的分类\",\"80\":\"7#三、设计原则\",\"81\":\"7#优秀设计的特征\",\"82\":\"7#四、创建型模式\",\"83\":\"7#工厂方法模式\",\"84\":\"7#抽象工厂模式\",\"85\":\"7#生成器模式\",\"86\":\"7#原型模式\",\"87\":\"7#单例模式\",\"88\":\"7#五、结构型模式\",\"89\":\"7#适配器模式\",\"90\":\"7#桥接模式\",\"91\":\"7#组合模式\",\"92\":\"7#装饰模式\",\"93\":\"7#外观模式\",\"94\":\"7#享元模式\",\"95\":\"7#代理模式\",\"96\":\"7#六、行为型模式\",\"97\":\"7#责任链模式-chain-of-responsibility-pattern\",\"98\":\"7#命令模式-command-pattern\",\"99\":\"7#迭代器模式-iterator-pattern\",\"100\":\"7#中介者模式-mediator-pattern\",\"101\":\"7#备忘录模式-memento-pattern\",\"102\":\"7#观察者模式-observer-pattern\",\"103\":\"7#状态模式-state-pattern\",\"104\":\"7#策略模式-strategy-pattern\",\"105\":\"7#模板方法模式-template-method-pattern\",\"106\":\"7#访问者模式-visitor-pattern\",\"107\":\"7#七、参考文献\",\"108\":\"7@0\",\"109\":\"7@1\",\"110\":\"8\",\"111\":\"8#引言\",\"112\":\"8#环境\",\"113\":\"8#大环境\",\"114\":\"8#小环境\",\"115\":\"8#影响股票的三个因素\",\"116\":\"8#股票的走势及走势线\",\"117\":\"8#综合看图\",\"118\":\"8#成功的要素\",\"119\":\"8#何时买股票何时卖股票\",\"120\":\"8#买入的要点归纳\",\"121\":\"8#选择股票的步骤\",\"122\":\"8#何时卖股票\",\"123\":\"8#小结一下何时及怎样卖股票\",\"124\":\"8#华尔街家训\",\"125\":\"8#怎样在心理上建设自己\",\"126\":\"8#抓住大机会\",\"127\":\"8#炒手访谈\",\"128\":\"8#金钱的反思\",\"129\":\"8#建立并严守自己的规则\",\"130\":\"8@0\",\"131\":\"8@1\",\"132\":\"9\",\"133\":\"9#一、什么是-some-ip-sd\",\"134\":\"9#📦-sd-解决了什么\",\"135\":\"9#🔗-应用场景\",\"136\":\"9#🧠-核心特性\",\"137\":\"9#🗺-工作流程简图\",\"138\":\"9#💬-一句话总结\",\"139\":\"9#二、协议格式-组成\",\"140\":\"9#三、正常通信流程\",\"141\":\"9#⏱-provider-与-client-的交互时序图-文字示意\",\"142\":\"9#四、provider-与-consumer-状态机模型\",\"143\":\"9#✅-provider-状态机结构图\",\"144\":\"9#✅-consumer-client-状态机结构图\",\"145\":\"9#✅-provider-状态机\",\"146\":\"9#✅-consumer-client-状态机\",\"147\":\"9#五、实际-subscribeeventgroup-抽象\",\"148\":\"9#六、协议细节-行为解析\",\"149\":\"9#📑-sd-报文类型概览-autosar-官方定义\",\"150\":\"9#🧹-服务释放机制-unsubscribe-stop-offer\",\"151\":\"9#✅-1-provider-停止提供服务\",\"152\":\"9#✅-2-client-主动取消订阅\",\"153\":\"9#🔁-offerservice-报文的发送时机\",\"154\":\"9#🔍-client-的-findservice-触发时机\",\"155\":\"9#七、实战故障排查\",\"156\":\"9#八、与-autosar-rte-组成\",\"157\":\"9#九、结论\",\"158\":\"10\",\"159\":\"10#指令介绍\",\"160\":\"10#设置代理\",\"161\":\"10#取消代理\",\"162\":\"10#生效优先级\",\"163\":\"10#案例\",\"164\":\"10@0\",\"165\":\"10@1\",\"166\":\"11\",\"167\":\"11#在c-类中vector声明-报错-expected-parameter-declarator\",\"168\":\"11@0\",\"169\":\"11@1\",\"170\":\"12\",\"171\":\"12#原理\",\"172\":\"12#案例\",\"173\":\"12@0\",\"174\":\"12@1\",\"175\":\"13\",\"176\":\"13#前提\",\"177\":\"13#extern作用\",\"178\":\"13#案例-使用extern模拟面向对象编程\",\"179\":\"13@0\",\"180\":\"13@1\",\"181\":\"14\",\"182\":\"14#一、gcc-优化等级概览\",\"183\":\"14#二、gcc-优化原理深入解析\",\"184\":\"14#_1-前端优化-源代码层面\",\"185\":\"14#_2-中间代码优化-gimple-ssa\",\"186\":\"14#_3-后端优化-rtl\",\"187\":\"14#三、示例实战分析-数组求和优化对比\",\"188\":\"14#🔬-汇编分析亮点\",\"189\":\"14#四、最佳实践总结\",\"190\":\"14#五、进一步探索方向\",\"191\":\"14#结语\",\"192\":\"15\",\"193\":\"15#原理\",\"194\":\"15#实现方式\",\"195\":\"15#代码分析\",\"196\":\"15@0\",\"197\":\"15@1\",\"198\":\"16\",\"199\":\"16#一、什么是-栈向下增长\",\"200\":\"16#二、进程内存布局-栈在什么位置\",\"201\":\"16#三、为什么程序栈向下增长\",\"202\":\"16#✅-1-与堆对称增长-避免冲突\",\"203\":\"16#✅-2-地址计算自然-负偏移更高效\",\"204\":\"16#✅-3-页式管理高效-防溢出安全\",\"205\":\"16#✅-4-向后兼容旧架构\",\"206\":\"16#四、参数在栈中哪里\",\"207\":\"16#五、-上一个-rbp-是什么-是否占空间\",\"208\":\"16#六、如果栈向上增长-会怎样\",\"209\":\"16#❌-问题一-变量管理复杂\",\"210\":\"16#❌-问题二-编译器和调试器成本增加\",\"211\":\"16#七、总结对比\",\"212\":\"16#结语-原理即美学\",\"213\":\"17\",\"214\":\"17#ppireqs-安装\",\"215\":\"17#使用\",\"216\":\"17#使用案例\",\"217\":\"17#参考链接\",\"218\":\"17@0\",\"219\":\"17@1\",\"220\":\"18\",\"221\":\"18#工作原理\",\"222\":\"18#配置方法\",\"223\":\"18#参考链接\",\"224\":\"18@0\",\"225\":\"18@1\",\"226\":\"19\",\"227\":\"19#连接原则\",\"228\":\"19#auto-connect\",\"229\":\"19#simple-pattern\",\"230\":\"19#enhanced-patterns\",\"231\":\"19#reference\",\"232\":\"19@0\",\"233\":\"19@1\",\"234\":\"20\",\"235\":\"20#_1-介绍\",\"236\":\"20#_2-工作空间-workspace\",\"237\":\"20#_3-swc-设计\",\"238\":\"20#_1-创建-application-components\",\"239\":\"20#_2-理解类型、原型和接口-types-prototypes-and-interfaces\",\"240\":\"20#_3-端口、端口初始值和-数据元素-元数据的一个原子数据单元\",\"241\":\"20#_4-在应用程序组件中配置服务端口\",\"242\":\"20#_5-定义runnables\",\"243\":\"20#_6-为runnable配置触发器、-port-access\",\"244\":\"20#_7-生成模板\",\"245\":\"20@0\",\"246\":\"20@1\",\"247\":\"21\",\"248\":\"22\",\"249\":\"23\",\"250\":\"24\",\"251\":\"25\",\"252\":\"26\",\"253\":\"27\",\"254\":\"28\",\"255\":\"29\",\"256\":\"30\",\"257\":\"31\",\"258\":\"32\",\"259\":\"33\",\"260\":\"34\",\"261\":\"35\",\"262\":\"36\",\"263\":\"37\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,1],\"2\":[4,16],\"3\":[4,15],\"4\":[3],\"5\":[2,10],\"6\":[2,14],\"7\":[2],\"8\":[3,12],\"9\":[3,17],\"10\":[2],\"11\":[7,12],\"12\":[2,9],\"13\":[9,16],\"14\":[2,6],\"15\":[8,22],\"16\":[4],\"17\":[3,17],\"18\":[3,23],\"19\":[3,17],\"20\":[3,12],\"21\":[3,30],\"22\":[2,28],\"23\":[2],\"24\":[11],\"25\":[2,4],\"26\":[1],\"27\":[1,28],\"28\":[1,31],\"29\":[1,26],\"30\":[1,14],\"31\":[1,3],\"32\":[2,9],\"33\":[2,5],\"34\":[1,6],\"35\":[1,9],\"36\":[2,7],\"37\":[1,8],\"38\":[2],\"39\":[2],\"40\":[1,4],\"41\":[null,null,1],\"42\":[null,null,2],\"43\":[1,1],\"44\":[1,2],\"45\":[4,14],\"46\":[4,25],\"47\":[3,3],\"48\":[1,9],\"49\":[3,2],\"50\":[4,56],\"51\":[1,4],\"52\":[1],\"53\":[1,8],\"54\":[1,4],\"55\":[null,null,1],\"56\":[null,null,2],\"57\":[1,6],\"58\":[1,2],\"59\":[1,27],\"60\":[null,null,1],\"61\":[null,null,2],\"62\":[1],\"63\":[1,8],\"64\":[null,null,1],\"65\":[null,null,2],\"66\":[3,2],\"67\":[1],\"68\":[2,11],\"69\":[1,17],\"70\":[1,22],\"71\":[2],\"72\":[4,2],\"73\":[2,11],\"74\":[4,7],\"75\":[1],\"76\":[2,26],\"77\":[2,8],\"78\":[2,5],\"79\":[2,39],\"80\":[1],\"81\":[1,317],\"82\":[1],\"83\":[1,145],\"84\":[1,137],\"85\":[1,162],\"86\":[1,139],\"87\":[1,158],\"88\":[1],\"89\":[1,151],\"90\":[1,137],\"91\":[1,171],\"92\":[1,133],\"93\":[1,144],\"94\":[1,160],\"95\":[1,151],\"96\":[1],\"97\":[6,143],\"98\":[4,152],\"99\":[4,155],\"100\":[4,136],\"101\":[4,130],\"102\":[4,176],\"103\":[4,146],\"104\":[4,126],\"105\":[5,125],\"106\":[4,140],\"107\":[1,17],\"108\":[null,null,1],\"109\":[null,null,2],\"110\":[3,3],\"111\":[1,65],\"112\":[1],\"113\":[1,16],\"114\":[1,14],\"115\":[1,6],\"116\":[1,48],\"117\":[1,62],\"118\":[1,118],\"119\":[1,23],\"120\":[1,57],\"121\":[1,30],\"122\":[1,6],\"123\":[1,26],\"124\":[1,169],\"125\":[1,48],\"126\":[1,67],\"127\":[1,15],\"128\":[1,23],\"129\":[1,24],\"130\":[null,null,1],\"131\":[null,null,2],\"132\":[5],\"133\":[6,17],\"134\":[4,14],\"135\":[2,12],\"136\":[2,20],\"137\":[2,15],\"138\":[2,9],\"139\":[3,28],\"140\":[2,16],\"141\":[7,16],\"142\":[5],\"143\":[3,19],\"144\":[4,24],\"145\":[3,13],\"146\":[4,28],\"147\":[4,23],\"148\":[3],\"149\":[6,81],\"150\":[6,5],\"151\":[4,20],\"152\":[4,17],\"153\":[3,29],\"154\":[5,35],\"155\":[2,28],\"156\":[5,18],\"157\":[2,24],\"158\":[1,4],\"159\":[1],\"160\":[1,12],\"161\":[1,13],\"162\":[1,13],\"163\":[1,15],\"164\":[null,null,1],\"165\":[null,null,2],\"166\":[2,2],\"167\":[6,9],\"168\":[null,null,1],\"169\":[null,null,3],\"170\":[1,8],\"171\":[1,35],\"172\":[1,2],\"173\":[null,null,1],\"174\":[null,null,2],\"175\":[1,1],\"176\":[1,7],\"177\":[1,37],\"178\":[2,67],\"179\":[null,null,1],\"180\":[null,null,2],\"181\":[4,12],\"182\":[3,30],\"183\":[3,6],\"184\":[4,4],\"185\":[5,17],\"186\":[4,11],\"187\":[3,46],\"188\":[2,15],\"189\":[2,36],\"190\":[2,15],\"191\":[1,13],\"192\":[1,1],\"193\":[1,16],\"194\":[1,37],\"195\":[1,50],\"196\":[null,null,1],\"197\":[null,null,2],\"198\":[2,8],\"199\":[4,23],\"200\":[4,25],\"201\":[3],\"202\":[4,11],\"203\":[4,34],\"204\":[4,10],\"205\":[3,9],\"206\":[3,45],\"207\":[6,26],\"208\":[4],\"209\":[3,18],\"210\":[3,8],\"211\":[2,28],\"212\":[2,14],\"213\":[1,1],\"214\":[2,3],\"215\":[1,133],\"216\":[1,14],\"217\":[1,1],\"218\":[null,null,1],\"219\":[null,null,2],\"220\":[1,3],\"221\":[1,26],\"222\":[1,47],\"223\":[1,8],\"224\":[null,null,1],\"225\":[null,null,2],\"226\":[6,5],\"227\":[1],\"228\":[2],\"229\":[2],\"230\":[2],\"231\":[1,1],\"232\":[null,null,1],\"233\":[null,null,2],\"234\":[4,4],\"235\":[2,11],\"236\":[4,2],\"237\":[3,25],\"238\":[4,13],\"239\":[8,26],\"240\":[6,36],\"241\":[2],\"242\":[2],\"243\":[4],\"244\":[2,8],\"245\":[null,null,1],\"246\":[null,null,2],\"247\":[1,3],\"248\":[1],\"249\":[1],\"250\":[1],\"251\":[1],\"252\":[1],\"253\":[1],\"254\":[1],\"255\":[1],\"256\":[1],\"257\":[1],\"258\":[1],\"259\":[1],\"260\":[1],\"261\":[4],\"262\":[4],\"263\":[2]},\"averageFieldLength\":[2.355732601579361,34.34611790335734,0.3626865528780813],\"storedFields\":{\"0\":{\"h\":\"主页\"},\"1\":{\"h\":\"介绍页\",\"t\":[\"新能源汽车行业从业者\"]},\"2\":{\"h\":\"AUTOSAR Port 的设计、连接原理与实践总结\",\"t\":[\"在 AUTOSAR 架构中，Port 是组件之间通信的桥梁。理解 Port 的类型、连接方式、使用限制，是建立稳定、可维护嵌入式软件架构的前提。本文从基本分类讲起，深入解析 Port 的连接机制、常见误区以及最佳实践建议。\"]},\"3\":{\"h\":\"一、什么是 Port？\",\"t\":[\"Port 是软件组件（SWC）对外暴露的通信接口点，定义了该组件与外界的交互边界。\",\"不包含功能实现\",\"仅定义：通信方向（提供/请求）、接口类型（S/R、C/S）\"]},\"4\":{\"h\":\"二、Port 分类总览\"},\"5\":{\"h\":\"1. 按通信角色\",\"t\":[\"类型\",\"含义\",\"P-Port\",\"提供数据或服务（Provider）\",\"R-Port\",\"请求数据或服务（Required）\"]},\"6\":{\"h\":\"2. 按接口类型\",\"t\":[\"接口模型\",\"场景\",\"特性\",\"Sender-Receiver\",\"周期数据、信号类\",\"单向\",\"Client-Server\",\"服务调用、命令执行\",\"双向，有响应\"]},\"7\":{\"h\":\"三、连接方式解析\"},\"8\":{\"h\":\"✅ Assembly Connector\",\"t\":[\"SWC ⇌ SWC 连接方式\",\"用于真实的数据交换\",\"[SWC_A: R-Port] ——— Assembly ———> [SWC_B: P-Port]\"]},\"9\":{\"h\":\"✅ Delegation Connector\",\"t\":[\"Composition 内部连接\",\"Composition 自身不实现逻辑，仅“转发”到内部 SWC\",\"[Composition: R-Port] ——— Delegation ———> [SWC_A: R-Port]\",\"📌 注意：一个 Port 只能参与一种连接类型！\"]},\"10\":{\"h\":\"四、常见误区与连接限制\"},\"11\":{\"h\":\"❌ 错误连接：SenderPort 同时参与 Delegation 和 Assembly\",\"t\":[\"[SWC_A: SenderPort] ├── Assembly —> [SWC_B: Receiver] └── Delegation —> [Composition]\"]},\"12\":{\"h\":\"✅ 正确做法\",\"t\":[\"将 SenderPort 拆分为两个独立端口；\",\"或在 Composition 使用 PR-Port。\"]},\"13\":{\"h\":\"❌ 错误连接：ReceiverPort 被多个 SenderPort 连接（Fan-in）\",\"t\":[\"[SWC_A: Sender] ─┐ ├──→ [SWC_C: ReceiverPort] [SWC_B: Sender] ─┘\",\"❌ 不被 AUTOSAR 允许，数据源不唯一，代码生成失败。\"]},\"14\":{\"h\":\"✅ 替代方案\",\"t\":[\"引入中间 SWC_Router；\",\"合并逻辑后输出给 Receiver。\"]},\"15\":{\"h\":\"五、SenderPort Fan-out 支持（1:N）\",\"t\":[\"[SWC_Sensor: SenderPort] ├──→ [SWC_Display: ReceiverPort] └──→ [SWC_Logger: ReceiverPort]\",\"📌 合法条件：\",\"使用 S/R 接口\",\"Unqueued、非响应式\",\"所有连接为 AssemblyConnector\",\"工具链支持（如 Vector）\"]},\"16\":{\"h\":\"六、结构化接口的字段级连接（高级实践）\"},\"17\":{\"h\":\"✅ 场景描述：\",\"t\":[\"一个 ReceiverPort 使用结构接口（即包含多个 DataElement），每个字段可分别绑定不同的 SenderPort。\",\"interface VehicleStatus_IF { uint16 speed; uint8 gear; float32 temp; }\"]},\"18\":{\"h\":\"✅ 合法连接方式：\",\"t\":[\"SWC_SpeedSensor → speed SWC_GearControl → gear SWC_TempSensor → temp ↓ [SWC_Display: R-Port (VehicleStatus_IF)]\",\"所有 SenderPort 均使用相同结构接口，但仅发送自身负责的 DataElement。\",\"ReceiverPort 从多个 SenderPort 获取各字段值。\"]},\"19\":{\"h\":\"⚙️ 工具配置建议：\",\"t\":[\"在 Vector DaVinci / EB Tresos 中，需通过 DataElementToPortMapping 明确指定每个 Sender 负责的字段。\",\"确保每个 DataElement 只被一个 SenderPort 提供。\"]},\"20\":{\"h\":\"📌 注意事项：\",\"t\":[\"所有连接必须为 AssemblyConnector。\",\"各 Sender 所使用的 Interface 类型必须一致。\",\"不得存在 DataElement 重复来源或混用 Delegation。\"]},\"21\":{\"h\":\"七、Port 设计推荐实践\",\"t\":[\"目标\",\"建议\",\"外部连接\",\"使用 Assembly Connector\",\"内部代理\",\"使用 Delegation Connector\",\"双向通信\",\"使用 PR-Port（仅限 Composition）\",\"结构接口字段分拆\",\"使用 DataElement 映射\",\"多组件共享数据\",\"使用 Sender Fan-out\",\"避免数据冲突\",\"禁用 Receiver Fan-in，使用 Router SWC\",\"强调职责清晰\",\"每个 Port 单一职责，避免混合连接\"]},\"22\":{\"h\":\"八、总结\",\"t\":[\"核心概念\",\"内容\",\"Port 类型\",\"P-Port / R-Port\",\"接口模型\",\"Sender-Receiver / Client-Server\",\"连接类型\",\"Assembly / Delegation（不能混用）\",\"合法 Fan-out\",\"一个 Sender → 多 Receiver\",\"❌ 不允许 Fan-in\",\"多 Sender → 一个 Receiver\",\"✅ 支持结构字段连接\",\"一个 Receiver Port 的每个字段来自不同 SenderPort\"]},\"23\":{\"h\":\"十、结语\"},\"24\":{\"h\":\"AUTOSAR Port 不只是通信通道，它是组件建模、架构清晰与系统稳定的基础。在项目建模初期，保持 Port 连接职责单一、遵循连接规则，能极大提高系统的可维护性和工具链兼容性。\"},\"25\":{\"h\":\"Autosar can协议栈\",\"t\":[\"本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略\"]},\"26\":{\"h\":\"CAN通信基本原理\"},\"27\":{\"h\":\"CAN通信概述\",\"t\":[\"CAN（Controller Area Network）即控制器局域网络。由于其高性能、高可靠性、及独 特的设计，CAN越来越受到人们的重视。国外已有许多大公司的产品采用了这一技术。\",\"CAN最初是由德国的BOSCH公司为汽车监测、控制系统而设计的。现代汽车越来越多地采用电子装置控制，如发动机的定时、注油控制，加速、刹车控制（ASC）及复杂的抗锁定刹车系统（ABS）等。由于这些控制需检测及交换大量数据，采用硬接信号线的方式不但烦琐、昂贵，而且难以解决问题，采用CAN总线上述问题便得到很好地解决。\"]},\"28\":{\"h\":\"CAN标准及原理图\",\"t\":[\"CAN总线是一种用于在不同的ECU（电子控制单元）之间传输数据的线，CAN总线协议是一种ISO 国际标准化的串行通信协议，有 ISO-11898 和 ISO-11519两个系列。其定义有： ISO-11898 定义了通信速率为 125 kbps ~1Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米，如下图。\",\"ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米，如下图。\"]},\"29\":{\"h\":\"CAN特性\",\"t\":[\"传输速率最高可达1Mbps，距离最远可达10km\",\"通信介质选择灵活（双绞线、同轴电缆、光纤）\",\"采用双线差分信号\",\"协议本身对节点的数量没有限制\",\"总线上节点的数量可以动态改变，组网灵活\",\"短帧结构，传输时间短，受干扰概率低\",\"多主站结构，各节点平等，任一节点可在任一时刻主动发送\",\"非破坏性的基于优先级的总线仲裁\",\"优先级通过报文的标识符（ID）区分，报文标识符在网络中是唯一的 \",\"标识符描述了数据的含义\",\"某些特定的应用对标识符的分配进行了标准化\",\"广播发送报文，报文可以被所有节点同时接收\",\"根据需要可进行相关性报文过滤\"]},\"30\":{\"h\":\"CAN功能特性\",\"t\":[\"CAN总线上，信号表现为电压形式，通过CAN_H和CAN_L线上的电位差来表示CAN信号，分为显性电平(dominant)和隐性电平(recessive)两种类型。其中显性电平规定为逻辑0，隐性电平则为逻辑1。其具体定义可通过下图来理解。\"]},\"31\":{\"h\":\"CAN系统构成\",\"t\":[\"有两种，如下图；第三种是CAN收发器也集成到微控制器中\"]},\"32\":{\"h\":\"AUTOSAR CAN协议栈概述\",\"t\":[\"Driver：主要包括CAN的Driver，以及根据外部的CAN的收\",\"HaedwareAbs：包括用于区分CAN通信的接口，接收／发送不同功能的PDU以及控制CAN收发器进行工作的Transceiver\",\"Services：包换CAN的状态管理以及PDU和信号的处理相关的模块\"]},\"33\":{\"h\":\"CAN Driver\",\"t\":[\"MCU的CAN外设控制模块\",\"主要数处理CAN的控制器中的功能，实现 数据在MCU CAN模块的收发\"]},\"34\":{\"h\":\"MCAL相关配置\",\"t\":[\"CanGeneral：配置一些API的使能函数周期等\",\"CanController：配置MCU的CAN外设操作功能以及CAN的Filter\",\"CanHaradwareObject：配置CAN的接收发送邮箱以及使用的Filter\"]},\"35\":{\"h\":\"CANTrcv\",\"t\":[\"CAN Trcv模块主要控制CAN外部收发器的模式，MCU的CAN信号与CAN总线建立起数据交互;目标是为适用于大多数当前和未来CAN收发器设备定义接口和行为。CAN Trcv抽象了CAN收发器硬件。它为更高层提供了一个独立于硬件的接口。 它通过使用MCAL层的API来访问CAN收发器硬件，以便实现ECU布局中的抽象化。\"]},\"36\":{\"h\":\"CANTrcv 模式切换\",\"t\":[\"CANTrcv的模式转换主要通过控制Dio或者SPI来控制硬件Trcv\",\"上电调用Init可以直接切换到任意一个模式\",\"SetMode函数用于被MainFunction或者CANIf接口调用控制\",\"在支持唤醒的Trcv一定要确保下电进入Sleep，才能有唤醒功能，这个时候Trcv处于常电模式，且唤醒中断引脚连接SBC的唤醒引脚\"]},\"37\":{\"h\":\"MCAL配置\",\"t\":[\"·General：主要配置相关API的使能以及是否支持唤醒等功能 ·ConfigSet：根据外部电路配置Trcv的通道，主要分为DIO控制的和SPI控制的，DIO控制的根据使用的PIN关联到DIO通道，SPI控制的要分配SPI的Sequence\"]},\"38\":{\"h\":\"AUTOSAR CAN协议栈集成\"},\"39\":{\"h\":\"AUTOSAR CAN调试策略\"},\"40\":{\"h\":\"参考链接\",\"t\":[\"AUTOSAR_TR_FoundationReleaseOverview AUTOSAR中国官方培训课程\"]},\"41\":{\"c\":[\"Autosar\"]},\"42\":{\"c\":[\"CAN\",\"协议\"]},\"43\":{\"h\":\"Autosar解决方案概述\",\"t\":[\"本文主要讲解Autosar解决方案相关内容\"]},\"44\":{\"h\":\"Autosar技术标准框架\",\"t\":[\"AUTOSAR技术标准针对不同的需求提供了不同的解决方案，以涵盖汽车软件开发领域的各种应用场景\"]},\"45\":{\"h\":\"Adaptive Platform(AP)\",\"t\":[\"Adaptive Platform是AUTOSAR为开发安全相关的高算力ECU，如自动驾驶，而提供的解决方案\",\"AP分层软件架构特点:\",\"支持采用C++作为应用软件的编程语言\",\"采用面向服务的架构（SOA）\",\"支持多任务并行处理\",\"尽可能重用已有标准\",\"支持功能安全和信息安全\",\"有计划的动态性，而非完全动态\",\"支持基于敏捷的开发过程\"]},\"46\":{\"h\":\"Classic Platform(CP)\",\"t\":[\"Classic Platform是AUTOSAR为开发硬实时、高安全性嵌入式系统，如电驱控制，而提供的解决方案\",\"CP分层软件架构支持：\",\"对硬件进行抽象，实现软硬解耦\",\"对Runnable和Task进行调度（操作系统）\",\"抽象部署在同一ECU或者不同ECU上的应用之间的通信，实现整车层面的虚拟功能总线\",\"故障诊断及诊断服务\",\"功能安全服务\",\"今信息安全服务\",\"CP所定义的系统服务、存储、通信、硬件1/0和复杂驱动等各个基础软件技术栈，其作用类似于人体的神经系统。相对应地，控制器硬件可以理解为身体，而应用软件可以理解为大脑或灵魂。\"]},\"47\":{\"h\":\"Foundation(FO)\",\"t\":[\"Foundation包含了AP和CP之间通用的内容以保证二者之间以及二者与非AUTOSAR系统之间的兼容性\",\"原文如下：\"]},\"48\":{\"h\":\"FO部分所定义的通用特性\",\"t\":[\"FO部分所定义的内容为“基础设施”，同时适用于CP和AP两种系统，以保证二者之间的兼容性。如通信协议、元模型、主干需求与术语、文件模板等。\"]},\"49\":{\"h\":\"AP、CP、FO间的关系\",\"t\":[\"Alt text\"]},\"50\":{\"h\":\"CP 与 AP 的区别\",\"t\":[\"CP\",\"AP\",\"Based on OSEK\",\"Based on POSIX\",\"Execution of code directly from ROM\",\"App is loaded from persistent memory into RAM\",\"Same address space for all applications (MPU support for safety)\",\"Each application has its own (virtual) address space (MMU support)\",\"Optimized for signal-based communication (CAN, FlexRay)\",\"Service-oriented communication\",\"Fixed task configuration\",\"Support of multiple (dynamic) scheduling strategies\",\"Specification\",\"Specification and code\",\"从CP到AP,实时性与安全性需求减少，算力需求增加\"]},\"51\":{\"h\":\"基于区域集中式EE架构的整车部署\",\"t\":[\" CP应用范围更广，AP与CP相辅相成，AP不会替代AP\"]},\"52\":{\"h\":\"Autosar标准制定方式\"},\"53\":{\"h\":\"AUTOSAR年度关键节点\",\"t\":[\"每年11月份集中发布FO、CP和AP标准\",\"AP演示代码在次年春季发布\",\"每年上半年举办开放大会AOC\",\"每年12月份组织标准发布会\",\"年中组织全体工作组会议\",\"Alt text\"]},\"54\":{\"h\":\"参考链接\",\"t\":[\"AUTOSAR_TR_FoundationReleaseOverview AUTOSAR中国官方培训课程\"]},\"55\":{\"c\":[\"Autosar\"]},\"56\":{\"c\":[\"概述\",\"解决方案\"]},\"57\":{\"h\":\"使用vuePress搭建博客\",\"t\":[\"这里使用的是theme-hope主题，项目环境、构建、本地运行指令可参考下面这个链接。\"]},\"58\":{\"h\":\"项目构建\",\"t\":[\"参考链接 小白教程\"]},\"59\":{\"h\":\"部署到gitpages\",\"t\":[\"若参考上面项目构建链接，此时本地git仓库已初始化\",\"1.创建本地分支\",\"查看本地分支\",\"git branch\",\"创建本地分支\",\"git checkout -b master\",\"2.连接远程分支\",\"添加远程仓库的引用\",\"git remote add origin https://github.com/yourusername/myrepo.git\",\"3.提交本地分支到远程分支\",\"git push origin <local_branch>:<remote_branch>\"]},\"60\":{\"c\":[\"使用指南\"]},\"61\":{\"c\":[\"VuePress\",\"使用指南\"]},\"62\":{\"h\":\"一些算法公式技巧摘录\"},\"63\":{\"h\":\"余法运算公式\",\"t\":[\"a mod b表示a除以b的余数。有下面的公式：\",\"(a + b) % p = (a%p + b%p) %p\",\"(a - b) % p = ((a%p - b%p) + p) %p\",\"(a * b) % p = (a%p)*(b%p) %p\"]},\"64\":{\"c\":[\"算法\"]},\"65\":{\"c\":[\"余数计算\",\"协议\"]},\"66\":{\"h\":\"《深入设计模式》阅读笔记\",\"t\":[\"本文主要总结设计模式这本书，并用c语言简单举例\"]},\"67\":{\"h\":\"\"},\"68\":{\"h\":\"1.本书背景及重要性\",\"t\":[\"这本书由亚历山大·什韦茨（Alexander Shvets）撰写，深入探讨了23种经典的设计模式。它不仅介绍了设计模式的定义、分类和应用场景，还通过具体的代码示例和UML图，帮助读者更好地理解和应用这些模式。\"]},\"69\":{\"h\":\"\",\"t\":[\"设计模式是软件设计中常见问题的典型解决方案，它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。自1994年“四人组（GoF）”的《设计模式：可复用面向对象软件的基础》一书出版以来，设计模式逐渐成为软件开发领域的重要组成部分。随着软件开发技术的不断发展，新的设计模式不断涌现，原有的设计模式也在不断演进和完善。因此，深入研究设计模式对于提高软件设计的质量和效率具有重要意义。\"]},\"70\":{\"h\":\"\",\"t\":[\"提高软件的可复用性：设计模式是软件开发中的经验总结，它们提供了一种通用的解决方案，可以在不同的项目中重复使用。通过使用设计模式，可以减少代码的重复编写，提高代码的复用率，从而降低软件开发的成本和风险。\",\"提高软件的可维护性：设计模式通常具有良好的结构和组织，它们将复杂的系统分解为简单的模块，使得软件的维护更加容易。通过使用设计模式，可以提高软件的可读性、可扩展性和可维护性，从而降低软件维护的成本和风险。\",\"提高软件的开发效率：设计模式提供了一种通用的解决方案，可以在不同的项目中重复使用。通过使用设计模式，可以减少代码的重复编写，提高代码的复用率，从而提高软件开发的效率。\",\"促进团队协作：设计模式是软件开发中的经验总结，它们提供了一种通用的解决方案，可以在不同的项目中重复使用。通过使用设计模式，可以提高团队成员之间的沟通和协作效率，从而提高团队的整体素质和竞争力。\"]},\"71\":{\"h\":\"2.基础概念\"},\"72\":{\"h\":\"1. + 和 - 符号表示\",\"t\":[\"+表示公有\",\"-表示私有\"]},\"73\":{\"h\":\"2. Interface概念\",\"t\":[\"interface代表对象的共有部分\",\"基于接口的实现，规定一类对象的行为\",\"Untitled\",\"如果父类实现了某个接口，子类必须实现该接口；子类继承父类的目的是对父类的拓展，无法裁剪;\",\"开闭原则的基础，实现拒绝修改，支持拓展\"]},\"74\":{\"h\":\"3. 蓝图**（Blueprint）**\",\"t\":[\"蓝图通常指的是系统或应用的高层设计。它描述了系统的架构、组件、模块以及它们之间的关系和交互。蓝图更多关注的是整体结构和规划，而不是具体的实现细节。\"]},\"75\":{\"h\":\"\"},\"76\":{\"h\":\"1.设计模式的概念\",\"t\":[\"设计模式是软件设计中常见问题的典型解决方案，它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。\",\"设计模式并不是一段特定的代码，而是解决特定问题的一般性概念。它提供了一种通用的解决方案，可以在不同的项目中重复使用。设计模式的目的是提高软件的可复用性、可维护性和可读性，使软件设计更加灵活、高效和可靠。\",\"设计模式通常具有以下特点：\",\"通用性：设计模式是针对软件设计中常见问题的解决方案，具有广泛的适用性。\",\"可复用性：设计模式提供了一种通用的解决方案，可以在不同的项目中重复使用，减少代码的重复编写。\",\"灵活性：设计模式可以根据具体的需求进行调整和扩展，具有较高的灵活性。\",\"可读性：设计模式提供了一种清晰、简洁的设计思路，使代码易于理解和维护。\"]},\"77\":{\"h\":\"2.模式构成\",\"t\":[\"意图\",\"描述问题和解决方案\",\"动机\",\"解释问题并说明模式会如何提供解决方案\",\"结构\",\"展示模式的各个部分和它们之间的关系\",\"实现\",\"在不同语言中的实现\"]},\"78\":{\"h\":\"3.模式和算法的区别\",\"t\":[\"算法像菜谱，提供达成目标的明确步骤。模式像蓝图[ ]:可以看到最终的结果和模式的功能，但需要自己确定实现步骤\"]},\"79\":{\"h\":\"4.设计模式的分类\",\"t\":[\"设计模式可以分为创建型模式、结构型模式和行为型模式三大类。创建型模式主要用于创建对象，结构型模式主要用于组织对象，行为型模式主要用于协调对象之间的交互。\",\"创建型模式\",\"提供创建对象的机制，增加已有代码的灵活性和可复用性\",\"结构型模式\",\"提供如何将对象和类组成较大的结构，同时保持结构的灵活性和高效\",\"行为模式\",\"负责对象间的高效沟通和职责委派\",\"创建型模式\",\"创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。创建型模式包括工厂方法模式、抽象工厂模式、生成器模式、原型模式和单例模式。\",\"结构型模式\",\"结构型模式介绍了如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。结构型模式包括适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式和代理模式。\",\"行为型模式\",\"行为型模式负责对象间的高效沟通和职责委派。行为型模式包括责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。\"]},\"80\":{\"h\":\"\"},\"81\":{\"h\":\"优秀设计的特征\",\"t\":[\"在软件开发中，优秀的设计应该具备以下特征（设计原则）：\",\"代码复用：通过复用已有的代码，可以减少代码的重复编写，提高开发效率，降低维护成本。\",\"扩展性：设计应该能够适应未来的变化和扩展，以便在需要时能够轻松地添加新的功能或修改现有的功能。\",\"单一职责原则：一个类应该只有一个引起它变化的原因，也就是说，一个类应该只负责一项职责。\",\"开闭原则：软件实体应该对扩展开放，对修改关闭。也就是说，在不修改现有代码的情况下，可以通过添加新的代码来扩展软件的功能。\",\"里氏替换原则：当一个子类的对象可以替换其父类的对象时，软件的行为不会发生变化。也就是说，子类应该能够完全替代父类，而不会影响软件的正确性。\",\"接口隔离原则：客户端不应该被迫依赖于它们不使用的方法。也就是说，应该将接口拆分成更小的接口，以便客户端只需要依赖它们实际使用的接口。\",\"依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。也就是说，应该将高层模块和低层模块之间的依赖关系倒置过来，使得高层模块依赖于抽象，而不是具体的实现。\",\"(实际上就是面向接口开发)\",\"在C语言中，我们可以将汽车和引擎的关系作为依赖倒置原则的例子。在这个例子中，汽车是一个高层模块，引擎是一个低层模块。根据依赖倒置原则，汽车不应该直接依赖于具体的引擎实现，而是应该依赖于引擎的抽象接口。\",\"下面是一个简单的C语言代码示例：\",\"#include <stdio.h> // Engine interface typedef void(*EngineStart)(); typedef void(*EngineStop)(); typedef struct Engine { EngineStart start; EngineStop stop; } Engine; // Concrete engine implementation void startConcreteEngine() { printf(\\\"Concrete engine started.\\\\\\\\n\\\"); } void stopConcreteEngine() { printf(\\\"Concrete engine stopped.\\\\\\\\n\\\"); } Engine createConcreteEngine() { Engine engine = { .start = startConcreteEngine, .stop = stopConcreteEngine }; return engine; } // Car class typedef struct Car { Engine* engine; } Car; Car createCar(Engine* engine) { Car car = { .engine = engine }; return car; } void startCar(Car* car) { car->engine->start(); } void stopCar(Car* car) { car->engine->stop(); } int main() { Engine concreteEngine = createConcreteEngine(); Car car = createCar(&concreteEngine); startCar(&car); stopCar(&car); return 0; }\",\"在这个例子中，Engine是一个抽象接口，ConcreteEngine是一个具体的实现。Car类依赖于Engine接口，而不是具体的ConcreteEngine实现。这样，如果我们要更换汽车的引擎，我们只需要创建一个新的引擎实现，并将其传递给Car构造函数，而无需修改Car类的代码。这就是依赖倒置原则的应用。\",\"封装变化的内容\",\"“封装变化的内容” (pdf)\",\"面向接口进行开发，而不是面向实现\",\"“面向接口进行开发， 而不是面向实现” (pdf)\",\"组合优于继承 “组合优于继承” (pdf)\",\"“在重写方法时， 你需要确保新行为与其基类中的版本兼容。 这一点很重要， 因为子类的所有对象都可能被传递给以超类 对象为参数的任何代码， 相信你不会希望这些代码崩溃的。” (pdf) 当你重写一个方法时，确保新行为与基类中的版本兼容意味着你需要保持方法的签名（参数列表和返回类型）相同，以及保持方法的预期行为相似。这是因为在面向对象编程中，子类对象可以被当作其超类对象使用，而超类中的方法可能会被其他代码调用，这些代码可能无法区分子类和超类的对象。\",\"举个例子，假设有一个动物园程序，里面有一个 feed_animal 函数，它接受一个动物对象并喂养它。如果我们在子类中重写了动物的 eat 方法，我们需要确保新的 eat 方法与超类中的 eat 方法具有相同的签名和类似的行为，以便 feed_animal 函数在处理子类对象时不会出现问题。\",\"class Animal: def eat(self): print(\\\"Animal is eating\\\") class Dog(Animal): def eat(self): print(\\\"Dog is eating\\\") \\\\## feed_animal 函数接受一个 Animal 对象并喂养它def feed_animal(animal): animal.eat() \\\\## 创建一个 Dog 对象dog = Dog() \\\\## 调用 feed_animal 函数并传递 Dog 对象feed_animal(dog)\",\"在这个例子中，Dog 类重写了 eat 方法，但它的签名和预期行为与超类 Animal 中的 eat 方法相同，因此 feed_animal 函数在处理 Dog 对象时不会出现问题。\",\"如果 Dog 类中的 eat 方法签名或行为与 Animal 类中的不同，那么 feed_animal 函数在处理 Dog 对象时可能会出现意料之外的行为或错误。因此，确保在重写方法时与超类中的版本兼容是很重要的。\",\"“通过继承复用代码可能导致平行继承体系的产生。” (pdf) 你提到的这种情况通常被称为”多重继承”或”平行继承体系”，它可能会导致类层次结构的复杂性增加，从而使代码难以维护和理解。这种情况通常出现在具有多个功能维度的系统中，因为每个功能维度可能都需要一组不同的特性或行为。\",\"让我们通过一个简单的代码示例来说明这个概念。假设我们正在设计一个图形界面库，其中有两个主要功能维度：控件类型和主题样式。我们希望能够创建不同类型的控件（如按钮、文本框）并为它们应用不同的主题样式（如浅色主题、深色主题）。\",\"在这种情况下，如果我们使用了多重继承，可能会导致类层次结构的爆炸性增长。让我们看一个简化的示例：\",\"class Widget: def draw(self): pass class Button(Widget): def click(self): pass class TextBox(Widget): def edit(self): pass class LightTheme: def apply(self, widget): pass class DarkTheme: def apply(self, widget): pass class LightButton(Button, LightTheme): pass class DarkButton(Button, DarkTheme): pass class LightTextBox(TextBox, LightTheme): pass class DarkTextBox(TextBox, DarkTheme): pass\",\"在上面的示例中，我们创建了四个类来表示不同类型的控件和主题样式组合。如果我们有更多的控件类型和主题样式，类层次结构将会急剧膨胀。\",\"为了避免这种情况，通常会使用其他设计模式，如组合或策略模式，来减轻类层次结构的压力。这些模式允许我们将行为和特性组合起来，而不是通过继承来扩展类。这样可以更灵活地管理代码，并且不会导致类层次结构的爆炸性增长。\",\"“组合是代替继承的一种方法。 继承代表类之间的“是” 关系 （汽车是交通工具）， 而组合则代表“有” 关系（汽车有一个 引擎）” (pdf) 继承is是，组合is有\",\"SOLID 原则\",\"好莱坞原则” (pdf)\",\"“好莱坞原则” (pdf) 好莱坞原则是一种设计原则，它指导着框架与应用程序代码之间的交互方式。在这种原则下，框架控制着应用程序的执行流程，而应用程序代码则通过特定的方式与框架进行交互。具体来说，当需要执行某些操作时，框架会调用应用程序代码，而应用程序代码不能主动调用框架。\",\"让我们以JUnit为例来解释这个原则。JUnit是一个用于编写和运行Java单元测试的框架。在JUnit中，你可以编写测试用例，然后JUnit框架负责执行这些测试用例，并向你报告测试结果。在这个过程中，你的测试用例类会继承JUnit提供的测试类，并且你会覆盖一些方法或者使用注解来标记测试方法。\",\"下面是一个简单的JUnit测试用例的示例：\",\"import static org.junit.Assert.assertEquals; import org.junit.Test; public class MyTestClass { @Test public void testAddition() { int result = 2 + 2; assertEquals(4, result); } }\",\"在这个例子中，MyTestClass是一个简单的测试类，它包含了一个测试方法testAddition()。当你运行这个测试类时，JUnit框架会负责调用testAddition()方法，并检查其结果是否符合预期。\",\"这符合好莱坞原则的精神，因为测试方法的调用是由JUnit框架触发的，而不是由测试类自身触发的。换句话说，测试类告诉JUnit框架它有哪些测试方法，并且JUnit框架在需要执行这些方法时会主动调用它们。\",\"“设计 模式比框架更小且更抽象。 它们实际上是对一组类的关系及 其互动方式的描述。” (pdf) 模式的本质\",\"“中间层次的优点在于模式提供的复用方式要比框架的风险小。” (pdf) 中间层次的设计模式提供了一种介于框架和单个类之间的解决方案。它通常涉及将一些常见的模式、结构或者逻辑抽象出来，形成中间层次的组件，以便在不同的应用场景中进行复用。\",\"相比之下，框架提供了一个更为全面和高级的解决方案，它通常包含了整个应用程序的基础架构，定义了应用程序的整体结构和行为。因此，在使用框架时，你必须遵循框架所定义的规则和约定，这可能会限制你的灵活性，并且需要花费更多的时间来学习和理解整个框架的工作原理。\",\"中间层次的优点在于：\",\"更小的风险： 使用中间层次的设计模式，你可以更加灵活地选择性地应用一些特定的模式或者组件，而不需要依赖整个框架。这样可以降低引入新技术或者更改现有逻辑所带来的风险。因为中间层次的组件通常比整个框架更为简单和可控，你可以更容易地理解和管理这些组件。\",\"更高的可维护性： 中间层次的组件通常更加模块化和可组合，这使得它们更易于维护和扩展。你可以根据具体的需求选择性地替换或者更新中间层次的组件，而不会对整个应用程序产生太大的影响。\",\"举个例子，假设你正在开发一个Web应用程序，你可以选择使用一个完整的Web框架，比如Django或者Spring，来构建整个应用程序的基础架构。然而，如果你只需要处理一些简单的HTTP请求和响应，你也可以选择使用中间层次的组件，比如WSGI（Python Web Server Gateway Interface）或者Servlets（Java Servlets），来处理这些请求和响应，而不需要引入整个框架的复杂性和约束。这样可以减少开发和维护的成本，并且降低引入新技术所带来的风险。\"]},\"82\":{\"h\":\"\"},\"83\":{\"h\":\"工厂方法模式\",\"t\":[\"一、定义\",\"工厂方法模式是一种创建型设计模式，它定义了一个创建对象的接口，但让子类决定实例化哪个类。工厂方法模式将对象的创建与使用分离，使得系统更加灵活和可扩展。\",\"二、结构\",\"抽象工厂类：定义了一个创建产品的接口，其中包含一个抽象的工厂方法。\",\"具体工厂类：实现了抽象工厂类中的工厂方法，负责创建具体的产品对象。\",\"抽象产品类：定义了产品的共性，包含一个抽象的产品方法。\",\"具体产品类：实现了抽象产品类中的产品方法，是具体的产品对象。\",\"三、示例代码\",\"以下是一个使用工厂方法模式创建汽车的 C 语言示例：\",\"#include <stdio.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct { char* model; int year; } Car; // 抽象工厂函数 Car* createCar(CarType type) { switch (type) { case SEDAN: return createSedan(); case SUV: return createSUV(); case HATCHBACK: return createHatchback(); default: return NULL; } } // 创建轿车 Car* createSedan() { Car* sedan = (Car*)malloc(sizeof(Car)); sedan->model = \\\"Sedan Model\\\"; sedan->year = 2023; return sedan; } // 创建 SUV Car* createSUV() { Car* suv = (Car*)malloc(sizeof(Car)); suv->model = \\\"SUV Model\\\"; suv->year = 2023; return suv; } // 创建掀背车 Car* createHatchback() { Car* hatchback = (Car*)malloc(sizeof(Car)); hatchback->model = \\\"Hatchback Model\\\"; hatchback->year = 2023; return hatchback; } int main() { // 创建轿车 Car* sedan = createCar(SEDAN); printf(\\\"Created Sedan: %s, %d\\\\\\\\n\\\", sedan->model, sedan->year); // 创建 SUV Car* suv = createCar(SUV); printf(\\\"Created SUV: %s, %d\\\\\\\\n\\\", suv->model, suv->year); // 创建掀背车 Car* hatchback = createCar(HATCHBACK); printf(\\\"Created Hatchback: %s, %d\\\\\\\\n\\\", hatchback->model, hatchback->year); // 释放内存 free(sedan); free(suv); free(hatchback); return 0; }\",\"在上述示例中，我们定义了一个汽车类型枚举CarType，表示不同类型的汽车。然后，我们定义了一个汽车结构体Car，包含汽车的模型和年份信息。\",\"接下来，我们定义了一个抽象工厂函数createCar，它根据传入的汽车类型参数创建相应类型的汽车。在函数内部，我们使用switch语句根据汽车类型创建具体的汽车对象，并返回创建的汽车指针。\",\"然后，我们分别实现了创建轿车、SUV 和掀背车的具体函数createSedan、createSUV和createHatchback，它们分别创建相应类型的汽车对象，并设置汽车的模型和年份信息。\",\"在main函数中，我们使用createCar函数创建了三种不同类型的汽车，并打印出汽车的信息。最后，我们使用free函数释放了创建的汽车对象所占用的内存。\",\"通过使用工厂方法模式，我们将汽车的创建过程封装在抽象工厂函数中，使得客户端代码无需关心具体汽车类型的创建细节，只需要调用抽象工厂函数即可创建所需类型的汽车对象。这样可以提高代码的灵活性和可扩展性，方便后续添加新的汽车类型或修改汽车的创建方式。\",\"四、优点\",\"灵活性：工厂方法模式将对象的创建与使用分离，使得系统更加灵活。客户端可以根据需要选择不同的工厂类来创建不同的产品对象，而无需关心产品对象的具体实现细节。\",\"可扩展性：工厂方法模式允许添加新的工厂类和产品类，而无需修改现有代码。只需要在新的工厂类中实现createShape方法，就可以创建新的产品对象。\",\"封装性：工厂方法模式将产品对象的创建过程封装在工厂类中，使得客户端无法直接创建产品对象，从而提高了系统的封装性和安全性。\",\"五、缺点\",\"增加了系统的复杂度：工厂方法模式需要定义抽象工厂类、具体工厂类、抽象产品类和具体产品类，增加了系统的复杂度。\",\"可能会导致类的数量过多：如果系统中需要创建的产品种类较多，那么可能会导致工厂类和产品类的数量过多，从而增加了系统的维护成本。\",\"六、适用场景\",\"当需要创建的对象种类较多，且它们的创建过程比较复杂时，可以使用工厂方法模式。\",\"当需要在不同的条件下创建不同的对象时，可以使用工厂方法模式。\",\"当需要将对象的创建过程与使用过程分离时，可以使用工厂方法模式。\",\"七、总结\",\"工厂方法模式是一种创建型设计模式，它定义了一个创建对象的接口，但让子类决定实例化哪个类。工厂方法模式将对象的创建与使用分离，使得系统更加灵活和可扩展。工厂方法模式的优点是灵活性、可扩展性和封装性，缺点是增加了系统的复杂度和可能会导致类的数量过多。工厂方法模式适用于需要创建的对象种类较多、在不同的条件下创建不同的对象以及将对象的创建过程与使用过程分离的场景。\"]},\"84\":{\"h\":\"抽象工厂模式\",\"t\":[\"一、定义\",\"抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。\",\"二、结构\",\"抽象产品：定义了产品的共性，是具体产品的父类。\",\"具体产品：实现了抽象产品的接口，是抽象产品的具体实现。\",\"抽象工厂：声明了一组创建抽象产品的方法，是具体工厂的父类。\",\"具体工厂：实现了抽象工厂的构建方法，负责创建具体的产品对象。\",\"三、示例代码\",\"#include <stdio.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct { char* model; int year; } Car; // 抽象工厂函数 Car* createCar(CarType type) { switch (type) { case SEDAN: return createSedan(); case SUV: return createSUV(); case HATCHBACK: return createHatchback(); default: return NULL; } } // 创建轿车 Car* createSedan() { Car* sedan = (Car*)malloc(sizeof(Car)); sedan->model = \\\"Sedan Model\\\"; sedan->year = 2023; return sedan; } // 创建 SUV Car* createSUV() { Car* suv = (Car*)malloc(sizeof(Car)); suv->model = \\\"SUV Model\\\"; suv->year = 2023; return suv; } // 创建掀背车 Car* createHatchback() { Car* hatchback = (Car*)malloc(sizeof(Car)); hatchback->model = \\\"Hatchback Model\\\"; hatchback->year = 2023; return hatchback; } int main() { // 创建轿车 Car* sedan = createCar(SEDAN); printf(\\\"Created Sedan: %s, %d\\\\\\\\n\\\", sedan->model, sedan->year); // 创建 SUV Car* suv = createCar(SUV); printf(\\\"Created SUV: %s, %d\\\\\\\\n\\\", suv->model, suv->year); // 创建掀背车 Car* hatchback = createCar(HATCHBACK); printf(\\\"Created Hatchback: %s, %d\\\\\\\\n\\\", hatchback->model, hatchback->year); // 释放内存 free(sedan); free(suv); free(hatchback); return 0; }\",\"在上述示例中，我们定义了一个抽象工厂函数createCar，它根据传入的汽车类型参数创建相应类型的汽车。在函数内部，我们使用switch语句根据汽车类型创建具体的汽车对象，并返回创建的汽车指针。\",\"然后，我们分别实现了创建轿车、SUV 和掀背车的具体函数createSedan、createSUV和createHatchback，它们分别创建相应类型的汽车对象，并设置汽车的模型和年份信息。\",\"在main函数中，我们使用createCar函数创建了三种不同类型的汽车，并打印出汽车的信息。最后，我们使用free函数释放了创建的汽车对象所占用的内存。\",\"四、优点\",\"封装性：抽象工厂模式将产品的创建过程封装在抽象工厂类中，使得客户端代码无需关心产品的具体创建过程，只需要通过抽象工厂类提供的方法来获取产品即可。\",\"可扩展性：抽象工厂模式支持产品族的扩展，当需要添加新的产品族时，只需要创建新的具体工厂类即可，无需修改现有代码。\",\"灵活性：抽象工厂模式可以根据不同的需求创建不同的产品族，从而提高了系统的灵活性。\",\"五、缺点\",\"抽象工厂类的设计难度较大：抽象工厂类需要定义多个抽象方法来创建不同的产品，这些方法的参数和返回值类型需要根据具体的产品族进行设计，因此抽象工厂类的设计难度较大。\",\"产品族的扩展较为困难：当需要添加新的产品族时，需要创建新的具体工厂类，并且需要在抽象工厂类中添加相应的抽象方法，这可能会导致抽象工厂类的代码变得复杂。\",\"客户端代码的修改较为困难：当需要修改产品族的实现时，需要修改具体工厂类的代码，这可能会导致客户端代码的修改较为困难。\",\"六、适用场景\",\"当需要创建的对象具有复杂的结构，且需要分步骤创建时，可以使用生成器模式。\",\"当需要创建的对象具有不同的实现方式，且这些实现方式之间存在差异时，可以使用生成器模式。\",\"当需要创建的对象具有不同的配置选项，且这些配置选项之间存在差异时，可以使用生成器模式。\",\"七、总结\",\"工厂模式与抽象工厂模式的区别在于:\",\"工厂方法模式：针对的是 一个产品等级结构。 抽象工厂模式：针对 多个产品等级结构\",\"抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。抽象工厂模式将产品的创建过程封装在抽象工厂类中，使得客户端代码无需关心产品的具体创建过程，只需要通过抽象工厂类提供的方法来获取产品即可。抽象工厂模式支持产品族的扩展，当需要添加新的产品族时，只需要创建新的具体工厂类即可，无需修改现有代码。抽象工厂模式可以根据不同的需求创建不同的产品族，从而提高了系统的灵活性。\"]},\"85\":{\"h\":\"生成器模式\",\"t\":[\"一、定义\",\"生成器模式是一种创建型设计模式，它使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。\",\"二、结构\",\"生成器（Builder）：声明了创建产品对象的抽象接口，通常包含一系列创建方法。\",\"具体生成器（Concrete Builder）：实现了生成器接口，负责创建具体的产品对象，并提供了设置产品参数的方法。\",\"产品（Product）：表示被创建的复杂对象，包含多个部件。\",\"主管（Director）：负责使用生成器对象创建产品，它知道如何按照一定的顺序调用生成器的方法来创建产品。\",\"三、示例代码（用 C 语言举汽车例子）\",\"#include <stdio.h> #include <stdlib.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct { char* model; int year; CarType type; } Car; // 声明生成器 struct Builder; // 生成器接口 typedef struct Builder { void (*setModel)(struct Builder*, char*); void (*setYear)(struct Builder*, int); void (*setType)(struct Builder*, CarType); Car* (*build)(struct Builder*); } Builder; // 具体生成器 typedef struct { // base 用于模拟继承，ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)builder; Builder base; Car* car; } ConcreteBuilder; // 设置汽车模型 void setModel(Builder* builder, char* model) { ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)builder; concreteBuilder->car->model = model; } // 设置汽车年份 void setYear(Builder* builder, int year) { ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)builder; concreteBuilder->car->year = year; } // 设置汽车类型 void setType(Builder* builder, CarType type) { ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)builder; concreteBuilder->car->type = type; } // 构建汽车 Car* build(Builder* builder) { ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)builder; return concreteBuilder->car; } // 主管 typedef struct { Builder* builder; } Director; // 创建主管 Director* createDirector(Builder* builder) { Director* director = (Director*)malloc(sizeof(Director)); director->builder = builder; return director; } // 制造汽车 Car* manufactureCar(Director* director) { director->builder->setModel(director->builder, \\\"Toyota Camry\\\"); director->builder->setYear(director->builder, 2023); director->builder->setType(director->builder, SEDAN); return director->builder->build(director->builder); } int main() { // 创建具体生成器 ConcreteBuilder* concreteBuilder = (ConcreteBuilder*)malloc(sizeof(ConcreteBuilder)); concreteBuilder->car = (Car*)malloc(sizeof(Car)); // 初始化生成器接口 concreteBuilder->base.setModel = setModel; concreteBuilder->base.setYear = setYear; concreteBuilder->base.setType = setType; concreteBuilder->base.build = build; // 创建主管 Director* director = createDirector((Builder*)concreteBuilder); // 制造汽车 Car* car = manufactureCar(director); // 输出汽车信息 printf(\\\"Model: %s\\\\n\\\", car->model); printf(\\\"Year: %d\\\\n\\\", car->year); printf(\\\"Type: %d\\\\n\\\", car->type); // 释放内存 free(car); free(concreteBuilder); free(director); return 0; }\",\"在上述示例中，我们定义了一个汽车结构体Car，它包含汽车的模型、年份和类型等信息。然后，我们定义了一个生成器接口Builder，它包含了设置汽车模型、年份和类型的方法，以及构建汽车的方法。接着，我们定义了一个具体生成器ConcreteBuilder，它实现了生成器接口，并在构建汽车时创建了一个汽车结构体的实例。\",\"为了使用生成器模式创建汽车，我们还定义了一个主管Director，它包含了一个生成器实例。主管的manufactureCar方法按照一定的顺序调用生成器的方法来创建汽车。\",\"在main函数中，我们首先创建了一个具体生成器和一个生成器实例，然后创建了一个主管。接着，我们使用主管的manufactureCar方法创建了一辆汽车，并输出了汽车的信息。最后，我们释放了所有的内存。\",\"四、优点\",\"封装性：生成器模式将产品的创建过程封装在生成器类中，使得客户端代码无需关心产品的具体创建过程，只需要通过生成器类提供的方法来获取产品即可。\",\"灵活性：生成器模式可以根据不同的需求创建不同的生成器类，从而实现不同的产品创建过程。\",\"可扩展性：生成器模式可以很容易地添加新的产品类型和创建过程，只需要创建新的生成器类即可。\",\"五、缺点\",\"复杂性：生成器模式需要定义多个类来实现产品的创建过程，因此代码结构比较复杂。\",\"性能问题：生成器模式在创建产品时需要进行多次方法调用，因此可能会影响代码的性能。\",\"六、适用场景\",\"当需要创建的对象具有复杂的结构，且需要分步骤创建时，可以使用生成器模式。\",\"当需要创建的对象具有不同的实现方式，且这些实现方式之间存在差异时，可以使用生成器模式。\",\"当需要创建的对象具有不同的配置选项，且这些配置选项之间存在差异时，可以使用生成器模式。\",\"七、总结\",\"生成器模式是一种创建型设计模式，它使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。生成器模式的优点是封装性、灵活性和可扩展性，缺点是复杂性和性能问题。生成器模式适用于需要创建的对象具有复杂的结构、不同的实现方式或不同的配置选项的场景。\"]},\"86\":{\"h\":\"原型模式\",\"t\":[\"一、定义\",\"原型模式是一种创建型设计模式，它使你能够复制已有对象，而又无需使代码依赖它们所属的类。\",\"二、结构\",\"原型（Prototype）：声明了克隆方法的接口。在绝大多数情况下，其中只会有一个名为clone的方法。\",\"具体原型（Concrete Prototype）：实现了克隆方法的类。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等等。\",\"客户端（Client）：可以复制实现了原型接口的任何对象。\",\"三、示例代码\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct Car { char* model; int year; CarType type; struct Car* (*clone)(struct Car*); } Car; // 克隆函数 Car* cloneCar(Car* original) { Car* newCar = (Car*)malloc(sizeof(Car)); newCar->model = strdup(original->model); newCar->year = original->year; newCar->type = original->type; newCar->clone = original->clone; return newCar; } // 创建新的汽车实例 Car* createCar(char* model, int year, CarType type) { Car* car = (Car*)malloc(sizeof(Car)); car->model = strdup(model); car->year = year; car->type = type; car->clone = cloneCar; return car; } // 打印汽车信息 void printCar(Car* car) { printf(\\\"Model: %s\\\\n\\\", car->model); printf(\\\"Year: %d\\\\n\\\", car->year); printf(\\\"Type: %d\\\\n\\\", car->type); } int main() { // 创建原型汽车 Car* prototypeCar = createCar(\\\"Toyota Camry\\\", 2023, SEDAN); // 克隆新汽车 Car* clonedCar = prototypeCar->clone(prototypeCar); // 修改克隆汽车的信息 clonedCar->model = strdup(\\\"Honda Accord\\\"); clonedCar->year = 2024; // 打印汽车信息 printf(\\\"Original Car:\\\\n\\\"); printCar(prototypeCar); printf(\\\"\\\\nCloned Car:\\\\n\\\"); printCar(clonedCar); // 释放内存 free(prototypeCar->model); free(prototypeCar); free(clonedCar->model); free(clonedCar); return 0; }\",\"四、优点\",\"提高性能：原型模式可以避免重复创建对象的开销，特别是在创建复杂对象时。\",\"方便创建复杂对象：原型模式可以通过复制已有对象来创建新对象，而无需关心对象的具体实现细节。\",\"便于扩展：原型模式可以通过添加新的原型类来扩展系统的功能，而无需修改已有代码。\",\"五、缺点\",\"内存消耗：原型模式需要为每个原型对象分配内存，如果原型对象数量较多，可能会导致内存消耗过大。\",\"深拷贝问题：如果原型对象包含指向其他对象的引用，那么在克隆原型对象时，需要进行深拷贝，否则可能会导致引用的对象被多个克隆对象共享，从而引发问题。\",\"安全问题：原型模式可能会导致安全问题，例如，如果原型对象包含敏感信息，那么在克隆原型对象时，需要进行特殊处理，以避免敏感信息泄露。\",\"六、适用场景\",\"创建复杂对象：如果创建一个复杂对象的过程比较复杂，或者需要大量的计算资源，那么可以使用原型模式来提高创建对象的效率。\",\"需要频繁创建对象：如果需要频繁创建对象，那么可以使用原型模式来避免重复创建对象的开销。\",\"对象状态变化较小：如果对象的状态变化较小，那么可以使用原型模式来减少对象的创建和销毁次数。\",\"七、总结\",\"原型模式是一种创建型设计模式，它通过复制已有对象来创建新对象，从而避免了重复创建对象的开销。原型模式的优点是提高性能、方便创建复杂对象和便于扩展，缺点是内存消耗、深拷贝问题和安全问题。原型模式适用于创建复杂对象、需要频繁创建对象和对象状态变化较小的场景。\"]},\"87\":{\"h\":\"单例模式\",\"t\":[\"一、定义\",\"单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来访问该实例。\",\"二、结构\",\"单例类：包含一个私有构造函数，以防止外部创建实例。它还包含一个静态成员变量来存储唯一的实例，并提供一个公共静态方法来获取该实例。\",\"客户端：通过调用单例类的公共静态方法来获取唯一的实例。\",\"三、示例代码（用 C 语言举汽车例子）\",\"#include <stdio.h> #include <stdlib.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct { char* model; int year; CarType type; } Car; // 单例类 typedef struct { Car* car; } Singleton; // 获取单例实例的方法 Singleton* getSingleton() { static Singleton instance = {NULL}; if (instance.car == NULL) { instance.car = (Car*)malloc(sizeof(Car)); instance.car->model = \\\"Toyota Camry\\\"; instance.car->year = 2023; instance.car->type = SEDAN; } return &instance; } int main() { // 获取单例实例 Singleton* singleton = getSingleton(); // 打印汽车信息 printf(\\\"Model: %s\\\\\\\\n\\\", singleton->car->model); printf(\\\"Year: %d\\\\\\\\n\\\", singleton->car->year); printf(\\\"Type: %d\\\\\\\\n\\\", singleton->car->type); // 释放内存 free(singleton->car); return 0; }\",\"在上述示例中，我们定义了一个Car结构体来表示汽车的属性，包括车型、生产年份和车辆类型。然后，我们定义了一个Singleton结构体来表示单例类，其中包含一个Car类型的指针car，用于存储唯一的汽车实例。\",\"在getSingleton方法中，我们使用静态变量instance来存储单例实例。如果instance为空，则创建一个新的汽车实例并将其赋值给instance。如果instance已经存在，则直接返回该实例。\",\"在main函数中，我们调用getSingleton方法获取单例实例，并打印汽车的信息。最后，我们释放单例实例所占用的内存。\",\"四、优点\",\"保证唯一性：单例模式保证一个类只有一个实例，避免了多个实例之间的竞争和冲突。\",\"全局访问点：单例模式提供了一个全局访问点来访问唯一的实例，方便了代码的使用和管理。\",\"节省资源：单例模式只创建一个实例，避免了多次创建和销毁实例所带来的资源浪费。\",\"提高性能：单例模式避免了多个实例之间的竞争和冲突，提高了程序的性能。\",\"五、缺点\",\"违反单一职责原则：单例模式将创建实例和管理实例的职责集中在一个类中，违反了单一职责原则。\",\"难以测试：单例模式的实例是在程序启动时创建的，难以在测试中进行模拟和控制。\",\"可能导致内存泄漏：如果单例模式的实例没有被正确释放，可能会导致内存泄漏。\",\"不支持多线程：在多线程环境下，单例模式可能会出现线程安全问题，需要进行特殊处理。\",\"六、适用场景\",\"需要全局访问的对象：如果一个对象需要在整个程序中被全局访问，例如日志记录器、数据库连接池等，可以使用单例模式来保证只有一个实例存在。\",\"资源共享的对象：如果一个对象需要被多个线程或进程共享，例如文件系统、网络连接等，可以使用单例模式来保证只有一个实例存在，避免资源竞争和冲突。\",\"需要频繁创建和销毁的对象：如果一个对象的创建和销毁非常频繁，例如线程池、对象池等，可以使用单例模式来避免频繁的创建和销毁操作，提高程序的性能。\",\"需要保证唯一性的对象：如果一个对象需要保证唯一性，例如序列号生成器、唯一标识符生成器等，可以使用单例模式来保证只有一个实例存在，避免重复生成。\",\"七、总结\",\"单例模式是一种简单而实用的设计模式，它保证了一个类只有一个实例，并提供了一个全局访问点来访问该实例。单例模式的优点是保证唯一性、全局访问点、节省资源和提高性能，缺点是违反单一职责原则、难以测试、可能导致内存泄漏和不支持多线程。单例模式适用于需要全局访问的对象、资源共享的对象、需要频繁创建和销毁的对象和需要保证唯一性的对象。在使用单例模式时，需要注意处理好线程安全问题，避免出现内存泄漏等问题。\"]},\"88\":{\"h\":\"\"},\"89\":{\"h\":\"适配器模式\",\"t\":[\"一、定义\",\"适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。\",\"二、结构\",\"客户端（Client）：使用适配器的对象。\",\"目标接口（Target）：客户端期望的接口。\",\"适配器（Adapter）：将源接口转换为目标接口的对象。\",\"源接口（Adaptee）：需要被适配的接口。\",\"三、示例代码（用 C 语言举汽车例子）\",\"#include <stdio.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 汽车结构体 typedef struct { char* model; int year; CarType type; } Car; // 电动汽车结构体 typedef struct { Car car; int batteryCapacity; } ElectricCar; // 定义电动汽车接口 typedef struct { void (*charge)(struct ElectricCar*); } ElectricCarInterface; // 实现电动汽车接口的充电方法 void charge(ElectricCar* electricCar) { printf(\\\"Charging the electric car: %s\\\\\\\\n\\\", electricCar->car.model); } // 定义传统燃油汽车接口 typedef struct { void (*refuel)(struct GasolineCar*); } GasolineCarInterface; // 传统燃油汽车结构体 typedef struct { Car car; int fuelCapacity; } GasolineCar; // 实现传统燃油汽车接口的加油方法 void refuel(GasolineCar* gasolineCar) { printf(\\\"Refueling the gasoline car: %s\\\\n\\\", gasolineCar->car.model); } // 定义适配器结构体 typedef struct { ElectricCarInterface electricCarInterface; GasolineCar* gasolineCar; } Adapter; // 实现适配器的充电方法 void adapterCharge(Adapter* adapter) { refuel(adapter->gasolineCar); } int main() { // 创建传统燃油汽车对象 GasolineCar gasolineCar = { .car = { .model = \\\"Toyota Camry\\\", .year = 2023, .type = SEDAN }, .fuelCapacity = 50 }; // 创建适配器对象，并将传统燃油汽车对象作为参数传递给适配器的构造函数 Adapter adapter = { .electricCarInterface = { .charge = adapterCharge }, .gasolineCar = &gasolineCar }; // 通过适配器对象调用充电方法 adapter.electricCarInterface.charge(&adapter); return 0; }\",\"在上述示例中，我们定义了一个汽车类型枚举CarType，表示汽车的类型。然后，我们定义了一个汽车结构体Car，表示汽车的基本信息。\",\"接下来，我们定义了一个电动汽车接口ElectricCarInterface，其中包含一个充电方法charge。我们还定义了一个电动汽车结构体ElectricCar，它包含一个汽车结构体Car和一个电池容量batteryCapacity。\",\"然后，我们定义了一个传统燃油汽车接口GasolineCarInterface，其中包含一个加油方法refuel。我们还定义了一个传统燃油汽车结构体GasolineCar，它包含一个汽车结构体Car和一个燃油容量fuelCapacity。\",\"为了使传统燃油汽车能够使用电动汽车的充电接口，我们定义了一个适配器结构体Adapter，它包含一个电动汽车接口ElectricCarInterface和一个传统燃油汽车结构体GasolineCar的指针。\",\"在适配器的构造函数中，我们将传统燃油汽车结构体的指针赋值给适配器结构体中的gasolineCar指针。\",\"在适配器的充电方法adapterCharge中，我们调用了传统燃油汽车结构体的加油方法refuel，实现了将传统燃油汽车的加油接口转换为电动汽车的充电接口的功能。\",\"在main函数中，我们创建了一个传统燃油汽车对象gasolineCar，并创建了一个适配器对象adapter，将传统燃油汽车对象作为参数传递给适配器的构造函数。\",\"最后，我们通过适配器对象调用充电方法charge，实现了对传统燃油汽车的充电操作。\",\"四、优点\",\"提高了代码的复用性：适配器模式可以将现有的接口转换为客户端期望的接口，从而提高了代码的复用性。\",\"提高了代码的灵活性：适配器模式可以在不修改现有代码的情况下，将现有的接口转换为客户端期望的接口，从而提高了代码的灵活性。\",\"提高了代码的可扩展性：适配器模式可以在不修改现有代码的情况下，将现有的接口转换为客户端期望的接口，从而提高了代码的可扩展性。\",\"五、缺点\",\"增加了代码的复杂度：适配器模式需要定义一个适配器类，将现有的接口转换为客户端期望的接口，从而增加了代码的复杂度。\",\"降低了代码的性能：适配器模式需要将现有的接口转换为客户端期望的接口，从而降低了代码的性能。\",\"六、适用场景\",\"需要将现有的接口转换为客户端期望的接口：当现有的接口与客户端期望的接口不兼容时，可以使用适配器模式将现有的接口转换为客户端期望的接口。\",\"需要提高代码的复用性和灵活性：当需要提高代码的复用性和灵活性时，可以使用适配器模式将现有的接口转换为客户端期望的接口。\",\"需要提高代码的可扩展性：当需要提高代码的可扩展性时，可以使用适配器模式将现有的接口转换为客户端期望的接口。\",\"七、总结\",\"适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。适配器模式的优点是提高了代码的复用性、灵活性和可扩展性，缺点是增加了代码的复杂度和降低了代码的性能。适配器模式适用于需要将现有的接口转换为客户端期望的接口的场景。\"]},\"90\":{\"h\":\"桥接模式\",\"t\":[\"一、定义\",\"桥接模式是一种结构型设计模式，它通过将抽象部分与实现部分分离，使它们可以独立变化。它是通过组合而不是继承来达到目的，即将抽象和实现用组合的方式桥接在一起。\",\"二、结构\",\"桥接模式主要包括以下几个部分：\",\"抽象部分（Abstraction）：定义高层接口，并维护对实现部分的引用。\",\"实现部分（Implementor）：定义实现接口，但不提供具体实现。\",\"具体实现部分（ConcreteImplementor）：实现实现接口的具体类。\",\"扩展抽象部分（RefinedAbstraction）：扩展抽象部分的接口，通常是高层业务逻辑。\",\"三、示例代码\",\"假设我们要设计一个汽车应用程序，不同类型的汽车（如轿车、SUV）可以有不同的操作系统（如Android Auto、Apple CarPlay）。我们使用桥接模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> // 实现部分接口 typedef struct CarSystem { void (*playMusic)(struct CarSystem*); void (*navigate)(struct CarSystem*); } CarSystem; // 具体实现部分：Android Auto typedef struct AndroidAuto { CarSystem carSystem; } AndroidAuto; void androidPlayMusic(CarSystem* carSystem) { printf(\\\"Playing music with Android Auto.\\\\\\\\n\\\"); } void androidNavigate(CarSystem* carSystem) { printf(\\\"Navigating with Android Auto.\\\\\\\\n\\\"); } AndroidAuto* createAndroidAuto() { AndroidAuto* androidAuto = (AndroidAuto*)malloc(sizeof(AndroidAuto)); androidAuto->carSystem.playMusic = androidPlayMusic; androidAuto->carSystem.navigate = androidNavigate; return androidAuto; } // 具体实现部分：Apple CarPlay typedef struct AppleCarPlay { CarSystem carSystem; } AppleCarPlay; void applePlayMusic(CarSystem* carSystem) { printf(\\\"Playing music with Apple CarPlay.\\\\\\\\n\\\"); } void appleNavigate(CarSystem* carSystem) { printf(\\\"Navigating with Apple CarPlay.\\\\\\\\n\\\"); } AppleCarPlay* createAppleCarPlay() { AppleCarPlay* appleCarPlay = (AppleCarPlay*)malloc(sizeof(AppleCarPlay)); appleCarPlay->carSystem.playMusic = applePlayMusic; appleCarPlay->carSystem.navigate = appleNavigate; return appleCarPlay; } // 抽象部分：汽车 typedef struct Car { CarSystem* carSystem; void (*playMusic)(struct Car*); void (*navigate)(struct Car*); } Car; void carPlayMusic(Car* car) { car->carSystem->playMusic(car->carSystem); } void carNavigate(Car* car) { car->carSystem->navigate(car->carSystem); } Car* createCar(CarSystem* carSystem) { Car* car = (Car*)malloc(sizeof(Car)); car->carSystem = carSystem; car->playMusic = carPlayMusic; car->navigate = carNavigate; return car; } // 扩展抽象部分：轿车 typedef struct Sedan { Car car; } Sedan; Sedan* createSedan(CarSystem* carSystem) { Sedan* sedan = (Sedan*)malloc(sizeof(Sedan)); sedan->car.carSystem = carSystem; sedan->car.playMusic = carPlayMusic; sedan->car.navigate = carNavigate; return sedan; } // 扩展抽象部分：SUV typedef struct SUV { Car car; } SUV; SUV* createSUV(CarSystem* carSystem) { SUV* suv = (SUV*)malloc(sizeof(SUV)); suv->car.carSystem = carSystem; suv->car.playMusic = carPlayMusic; suv->car.navigate = carNavigate; return suv; } int main() { // 创建具体实现部分对象 AndroidAuto* androidAuto = createAndroidAuto(); AppleCarPlay* appleCarPlay = createAppleCarPlay(); // 创建扩展抽象部分对象，使用不同的实现部分 Sedan* sedanWithAndroid = createSedan((CarSystem*)androidAuto); SUV* suvWithApple = createSUV((CarSystem*)appleCarPlay); // 使用扩展抽象部分对象 sedanWithAndroid->car.playMusic((Car*)sedanWithAndroid); sedanWithAndroid->car.navigate((Car*)sedanWithAndroid); suvWithApple->car.playMusic((Car*)suvWithApple); suvWithApple->car.navigate((Car*)suvWithApple); // 清理内存 free(androidAuto); free(appleCarPlay); free(sedanWithAndroid); free(suvWithApple); return 0; }\",\"主要结构说明\",\"实现部分（Implementor）：定义了CarSystem接口，包括playMusic和navigate方法。\",\"具体实现部分（ConcreteImplementor）：定义了AndroidAuto和AppleCarPlay，分别实现了CarSystem接口的方法。\",\"抽象部分（Abstraction）：定义了Car，包含一个指向CarSystem的指针，并提供playMusic和navigate方法，这些方法将调用CarSystem的相应方法。\",\"扩展抽象部分（RefinedAbstraction）：定义了Sedan和SUV，它们扩展了Car。\",\"四、优点\",\"分离抽象和实现：可以独立地扩展抽象部分和实现部分。\",\"提高系统可扩展性：桥接模式提高了系统的可扩展性。\",\"降低类的数量：通过组合来减少继承层次，可以有效地减少类的数量。\",\"五、缺点\",\"增加复杂性：引入了更多的类和接口，增加了系统的复杂性。\",\"六、适用场景\",\"需要在抽象和具体实现之间增加更多的灵活性。\",\"不希望使用继承或层次过深的继承结构。\",\"一个类存在两个独立变化的维度，并且这两个维度都需要独立扩展。\",\"七、总结\",\"桥接模式通过分离抽象部分和实现部分，使得它们可以独立变化，提高了系统的可扩展性和灵活性。在汽车应用中，不同类型的汽车可以使用不同的操作系统，这展示了桥接模式如何在实际项目中使用。\"]},\"91\":{\"h\":\"组合模式\",\"t\":[\"一、定义\",\"组合模式是一种结构型设计模式，它允许你将对象组合成树状结构来表示“部分-整体”的层次结构。组合模式使得客户端可以统一对待单个对象和组合对象。\",\"二、结构\",\"组合模式主要包括以下几个部分：\",\"组件（Component）：定义对象的接口，并提供接口的默认实现。\",\"叶子（Leaf）：表示叶节点对象，没有子节点。\",\"容器（Composite）：包含子节点，既可以是叶子也可以是其他容器。\",\"三、示例代码\",\"假设我们要设计一个汽车应用程序，不同的汽车零部件（如车轮、发动机）可以组合成一个整体汽车。我们使用组合模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 定义组件接口 typedef struct Component { void (*operation)(struct Component*); void (*add)(struct Component*, struct Component*); void (*remove)(struct Component*, struct Component*); struct Component* (*getChild)(struct Component*, int); char* name; } Component; // 定义叶子节点：汽车零部件 typedef struct Leaf { Component component; } Leaf; void leafOperation(Component* component) { printf(\\\"Leaf: %s\\\\\\\\n\\\", component->name); } void leafAdd(Component* component, Component* child) { // 叶子节点不能添加子节点 } void leafRemove(Component* component, Component* child) { // 叶子节点不能移除子节点 } Component* leafGetChild(Component* component, int index) { return NULL; // 叶子节点没有子节点 } Leaf* createLeaf(const char* name) { Leaf* leaf = (Leaf*)malloc(sizeof(Leaf)); leaf->component.name = strdup(name); leaf->component.operation = leafOperation; leaf->component.add = leafAdd; leaf->component.remove = leafRemove; leaf->component.getChild = leafGetChild; return leaf; } // 定义组合节点：汽车 typedef struct Composite { Component component; Component** children; int childCount; int capacity; } Composite; void compositeOperation(Component* component) { Composite* composite = (Composite*)component; printf(\\\"Composite: %s\\\\\\\\n\\\", component->name); for (int i = 0; i < composite->childCount; ++i) { composite->children[i]->operation(composite->children[i]); } } void compositeAdd(Component* component, Component* child) { Composite* composite = (Composite*)component; if (composite->childCount >= composite->capacity) { composite->capacity *= 2; composite->children = (Component**)realloc(composite->children, composite->capacity * sizeof(Component*)); } composite->children[composite->childCount++] = child; } void compositeRemove(Component* component, Component* child) { Composite* composite = (Composite*)component; for (int i = 0; i < composite->childCount; ++i) { if (composite->children[i] == child) { for (int j = i; j < composite->childCount - 1; ++j) { composite->children[j] = composite->children[j + 1]; } composite->childCount--; break; } } } Component* compositeGetChild(Component* component, int index) { Composite* composite = (Composite*)component; if (index < 0 || index >= composite->childCount) { return NULL; } return composite->children[index]; } Composite* createComposite(const char* name) { Composite* composite = (Composite*)malloc(sizeof(Composite)); composite->component.name = strdup(name); composite->component.operation = compositeOperation; composite->component.add = compositeAdd; composite->component.remove = compositeRemove; composite->component.getChild = compositeGetChild; composite->children = (Component**)malloc(4 * sizeof(Component*)); composite->capacity = 4; composite->childCount = 0; return composite; } // 测试组合模式 int main() { // 创建叶子节点：汽车零部件 Leaf* wheel = createLeaf(\\\"Wheel\\\"); Leaf* engine = createLeaf(\\\"Engine\\\"); Leaf* door = createLeaf(\\\"Door\\\"); // 创建组合节点：汽车 Composite* car = createComposite(\\\"Car\\\"); // 将零部件添加到汽车 car->component.add((Component*)car, (Component*)wheel); car->component.add((Component*)car, (Component*)engine); car->component.add((Component*)car, (Component*)door); // 调用汽车的操作，应该递归调用子节点的操作 car->component.operation((Component*)car); // 清理内存 free(wheel->component.name); free(wheel); free(engine->component.name); free(engine); free(door->component.name); free(door); free(car->children); free(car->component.name); free(car); return 0; }\",\"主要结构说明\",\"组件（Component）：定义了统一的接口，包含操作方法 operation 以及管理子节点的方法 add、remove 和 getChild。还包含一个名称属性 name。\",\"叶子（Leaf）：具体实现了组件接口，没有子节点的功能。实现了 operation 方法。\",\"容器（Composite）：实现了组件接口，并包含一个子节点数组，用于管理其子节点。实现了 operation、add、remove 和 getChild 方法。\",\"测试组合模式：创建了多个叶子节点（汽车零部件）和一个组合节点（汽车），并将叶子节点添加到组合节点中，最终调用组合节点的操作方法来展示组合模式的工作方式。\",\"四、优点\",\"清晰的层次结构：组合模式能清晰地表示对象的层次结构。\",\"客户端一致性：客户端可以一致地对待单个对象和组合对象。\",\"便于扩展：可以很容易地增加新的叶子节点或组合节点。\",\"五、缺点\",\"类型安全性较低：由于使用了通用的组件接口，类型检查只能在运行时进行。\",\"管理复杂性：如果层次结构较深，可能会导致管理复杂性增加。\",\"六、适用场景\",\"需要表示对象的部分-整体层次结构。\",\"希望客户端可以统一处理单个对象和组合对象。\",\"七、 总结\",\"组合模式通过定义统一的接口，使得单个对象和组合对象可以一致地进行处理。它适用于需要表示部分-整体层次结构的场景。在汽车应用中，汽车可以由不同的零部件组合而成，展示了组合模式如何在实际项目中使用。\"]},\"92\":{\"h\":\"装饰模式\",\"t\":[\"一、定义\",\"装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它是一种结构型设计模式，通过创建一个装饰类来包装原有的类，并在不修改原类的情况下添加额外的行为。\",\"二、结构\",\"装饰模式的主要角色包括：\",\"组件（Component）：定义了一个对象接口，可以给这些对象动态地添加职责。\",\"具体组件（Concrete Component）：定义了一个具体的对象，也可以给这个对象添加一些职责。\",\"装饰（Decorator）：装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。\",\"具体装饰（Concrete Decorator）：具体的装饰对象，起到给Component添加职责的功能。\",\"三、示例代码\",\"下面是一个使用装饰模式的示例代码，演示了如何使用装饰模式来为一个汽车添加不同的功能：\",\"#include <stdio.h> // 定义汽车结构体 typedef struct { char *name; int speed; } Car; // 定义汽车装饰结构体 typedef struct { Car *car; void (*decorate)(struct Decorator *decorator); } Decorator; // 定义汽车装饰函数 void decorateWithGPS(Decorator *decorator) { printf(\\\"%s 汽车已安装 GPS\\\\\\\\n\\\", decorator->car->name); } void decorateWithSunroof(Decorator *decorator) { printf(\\\"%s 汽车已安装天窗\\\\\\\\n\\\", decorator->car->name); } // 创建汽车对象 Car *createCar(char *name, int speed) { Car *car = (Car *)malloc(sizeof(Car)); car->name = name; car->speed = speed; return car; } // 创建汽车装饰对象 Decorator *createDecorator(Car *car, void (*decorate)(Decorator *decorator)) { Decorator *decorator = (Decorator *)malloc(sizeof(Decorator)); decorator->car = car; decorator->decorate = decorate; return decorator; } // 测试函数 int main() { // 创建汽车对象 Car *car = createCar(\\\"宝马\\\", 200); // 创建汽车装饰对象 Decorator *decoratorWithGPS = createDecorator(car, decorateWithGPS); Decorator *decoratorWithSunroof = createDecorator(car, decorateWithSunroof); // 调用汽车装饰函数 decoratorWithGPS->decorate(decoratorWithGPS); decoratorWithSunroof->decorate(decoratorWithSunroof); // 释放内存 free(car); free(decoratorWithGPS); free(decoratorWithSunroof); return 0; }\",\"在上述代码中，我们首先定义了一个Car结构体，其中包含汽车的名称和速度。然后，我们定义了一个Decorator结构体，其中包含一个指向Car结构体的指针和一个装饰函数指针。接着，我们定义了两个装饰函数decorateWithGPS和decorateWithSunroof，分别用于为汽车添加GPS和天窗功能。然后，我们使用createCar函数创建了一个汽车对象，并使用createDecorator函数为汽车对象创建了两个装饰对象，分别用于添加GPS和天窗功能。最后，我们使用decorate函数调用了装饰对象的装饰函数，为汽车添加了GPS和天窗功能。\",\"四、优点\",\"动态扩展：装饰模式可以在不改变原有对象结构的情况下，动态地给对象添加新的功能，具有很强的灵活性。\",\"遵循开闭原则：装饰模式可以在不修改原有代码的情况下，扩展对象的功能，符合开闭原则。\",\"简化代码：装饰模式可以将复杂的功能分解为多个简单的装饰类，每个装饰类只负责一个特定的功能，从而简化了代码的结构。\",\"提高代码的可维护性：装饰模式将功能分解为多个独立的装饰类，每个装饰类只负责一个特定的功能，从而提高了代码的可维护性。\",\"五、缺点\",\"增加了系统的复杂性：装饰模式需要创建多个装饰类，增加了系统的复杂性。\",\"降低了系统的性能：装饰模式需要创建多个装饰类，并且在运行时需要动态地选择装饰类，从而降低了系统的性能。\",\"六、适用场景\",\"需要动态地给对象添加新的功能：装饰模式可以在不改变原有对象结构的情况下，动态地给对象添加新的功能，具有很强的灵活性。\",\"需要在不修改原有代码的情况下，扩展对象的功能：装饰模式可以在不修改原有代码的情况下，扩展对象的功能，符合开闭原则。\",\"需要将复杂的功能分解为多个简单的装饰类：装饰模式可以将复杂的功能分解为多个简单的装饰类，每个装饰类只负责一个特定的功能，从而简化了代码的结构，提高了代码的可维护性。\",\"七、总结\",\"装饰模式是一种非常有用的设计模式，它可以在不改变原有对象结构的情况下，动态地给对象添加新的功能，具有很强的灵活性。装饰模式遵循开闭原则，可以在不修改原有代码的情况下，扩展对象的功能。装饰模式可以将复杂的功能分解为多个简单的装饰类，每个装饰类只负责一个特定的功能，从而简化了代码的结构，提高了代码的可维护性。\"]},\"93\":{\"h\":\"外观模式\",\"t\":[\"一、定义\",\"外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。\",\"二、结构\",\"外观类（Facade）：外观类是外观模式的核心，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。外观类通常包含一些与子系统相关的业务逻辑，它可以将这些业务逻辑封装起来，对外提供一个简单的接口。\",\"子系统类（Subsystem Classes）：子系统类是外观模式的组成部分，它们是子系统中的具体实现类，负责实现子系统的具体功能。子系统类通常包含一些与子系统相关的业务逻辑，它们可以将这些业务逻辑封装起来，对外提供一个简单的接口。\",\"三、示例代码（C语言汽车举例）\",\"#include <stdio.h> #include <stdlib.h> // 定义汽车类型枚举 typedef enum { SEDAN, SUV, HATCHBACK } CarType; // 定义汽车结构体 typedef struct { char* model; int year; CarType type; } Car; // 创建汽车对象 Car* createCar(CarType type) { Car* car = (Car*)malloc(sizeof(Car)); car->model = \\\"Toyota Camry\\\"; car->year = 2023; car->type = type; return car; } // 定义汽车工厂结构体 typedef struct { Car* (*createCar)(CarType type); } CarFactory; // 创建汽车工厂对象 CarFactory* createCarFactory() { CarFactory* factory = (CarFactory*)malloc(sizeof(CarFactory)); factory->createCar = createCar; return factory; } // 定义汽车经销商结构体 typedef struct { CarFactory* factory; } CarDealer; // 创建汽车经销商对象 CarDealer* createCarDealer() { CarDealer* dealer = (CarDealer*)malloc(sizeof(CarDealer)); dealer->factory = createCarFactory(); return dealer; } // 销售汽车 void sellCar(CarDealer* dealer, CarType type) { Car* car = dealer->factory->createCar(type); printf(\\\"Sold a %s %d\\\\\\\\n\\\", car->model, car->year); free(car); } int main() { // 创建汽车经销商对象 CarDealer* dealer = createCarDealer(); // 销售汽车 sellCar(dealer, SEDAN); sellCar(dealer, SUV); sellCar(dealer, HATCHBACK); // 释放汽车经销商对象 free(dealer); return 0; }\",\"在上述示例代码中，我们定义了一个汽车工厂结构体CarFactory，它包含一个创建汽车对象的函数指针createCar。我们还定义了一个汽车经销商结构体CarDealer，它包含一个汽车工厂对象factory。在main函数中，我们创建了一个汽车经销商对象dealer，并通过调用sellCar函数来销售汽车。在sellCar函数中，我们通过调用汽车工厂对象的createCar函数来创建汽车对象，并将其销售出去。最后，我们释放了汽车经销商对象。\",\"四、优点\",\"简化了客户端的代码：外观模式为子系统中的一组接口提供了一个统一的高层接口，使得客户端的代码更加简洁。客户端只需要与外观类进行交互，而不需要与子系统中的具体实现类进行交互，从而减少了客户端的代码量。\",\"提高了系统的可维护性：外观模式将子系统中的具体实现类隐藏起来，使得客户端只需要与外观类进行交互，而不需要了解子系统的具体实现细节。这样，当子系统中的具体实现类发生变化时，客户端的代码不需要进行修改，从而提高了系统的可维护性。\",\"提高了系统的灵活性：外观模式可以根据客户端的需求，动态地选择不同的子系统实现类，从而提高了系统的灵活性。例如，当客户端需要使用不同的汽车品牌时，只需要修改外观类中的汽车工厂对象，而不需要修改客户端的代码。\",\"五、缺点\",\"可能会增加系统的复杂度：外观模式将子系统中的具体实现类隐藏起来，使得客户端只需要与外观类进行交互，而不需要了解子系统的具体实现细节。这样，当子系统中的具体实现类发生变化时，客户端的代码不需要进行修改，从而提高了系统的可维护性。但是，这也可能会导致系统的复杂度增加，因为外观类需要了解子系统的具体实现细节，以便为客户端提供一个统一的高层接口。\",\"可能会降低系统的性能：外观模式为子系统中的一组接口提供了一个统一的高层接口，使得客户端的代码更加简洁。但是，这也可能会导致系统的性能降低，因为外观类需要将客户端的请求转发给子系统中的具体实现类，从而增加了系统的开销。\",\"六、适用场景\",\"当需要为一个复杂的子系统提供一个简单的接口时：外观模式可以为一个复杂的子系统提供一个简单的接口，使得客户端的代码更加简洁。\",\"当需要提高系统的可维护性时：外观模式可以将子系统中的具体实现类隐藏起来，使得客户端只需要与外观类进行交互，而不需要了解子系统的具体实现细节。这样，当子系统中的具体实现类发生变化时，客户端的代码不需要进行修改，从而提高了系统的可维护性。\",\"当需要提高系统的灵活性时：外观模式可以根据客户端的需求，动态地选择不同的子系统实现类，从而提高了系统的灵活性。\",\"七、总结\",\"外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。外观模式的优点是简化了客户端的代码、提高了系统的可维护性和灵活性；缺点是可能会增加系统的复杂度和降低系统的性能。外观模式适用于当需要为一个复杂的子系统提供一个简单的接口、提高系统的可维护性和灵活性的场景。\"]},\"94\":{\"h\":\"享元模式\",\"t\":[\"一、定义\",\"享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。\",\"二、结构\",\"享元（Flyweight）：包含了一个对象的部分状态，这些状态可以在多个对象之间共享。\",\"具体享元（Concrete Flyweight）：实现了享元接口，包含了具体的共享状态。\",\"享元工厂（Flyweight Factory）：负责创建和管理享元对象。\",\"客户端（Client）：使用享元对象。\",\"三、示例代码（用 C 语言汽车举例）\",\"#include <stdio.h> #include <stdlib.h> // 定义汽车颜色枚举 typedef enum { RED, BLUE, GREEN, WHITE, BLACK } CarColor; // 定义汽车品牌枚举 typedef enum { BMW, AUDI, BENZ, TOYOTA, HONDA } CarBrand; // 定义汽车结构体 typedef struct { CarColor color; CarBrand brand; } Car; // 享元工厂结构体 typedef struct { Car* cars[100]; int numCars; } CarFactory; // 创建享元工厂 CarFactory* createCarFactory() { CarFactory* factory = (CarFactory*)malloc(sizeof(CarFactory)); factory->numCars = 0; return factory; } // 获取汽车享元 Car* getCar(CarFactory* factory, CarColor color, CarBrand brand) { for (int i = 0; i < factory->numCars; i++) { if (factory->cars[i]->color == color && factory->cars[i]->brand == brand) { return factory->cars[i]; } } Car* car = (Car*)malloc(sizeof(Car)); car->color = color; car->brand = brand; factory->cars[factory->numCars++] = car; return car; } // 打印汽车信息 void printCar(Car* car) { printf(\\\"Car: color = %d, brand = %d\\\\\\\\n\\\", car->color, car->brand); } int main() { // 创建享元工厂 CarFactory* factory = createCarFactory(); // 获取汽车享元 Car* car1 = getCar(factory, RED, BMW); Car* car2 = getCar(factory, BLUE, AUDI); Car* car3 = getCar(factory, GREEN, BENZ); Car* car4 = getCar(factory, WHITE, TOYOTA); Car* car5 = getCar(factory, BLACK, HONDA); // 打印汽车信息 printCar(car1); printCar(car2); printCar(car3); printCar(car4); printCar(car5); // 释放内存 free(car1); free(car2); free(car3); free(car4); free(car5); free(factory); return 0; }\",\"在上述示例中，我们定义了汽车颜色和品牌的枚举类型，以及汽车结构体。然后，我们实现了享元工厂，用于创建和管理汽车享元对象。在getCar方法中，我们首先检查工厂中是否已经存在具有相同颜色和品牌的汽车享元对象，如果存在则直接返回该对象，否则创建一个新的汽车享元对象并添加到工厂中。最后，我们在main函数中创建了一个享元工厂，并通过getCar方法获取了多个汽车享元对象，并打印了它们的信息。\",\"四、优点\",\"减少内存占用：通过共享相同的状态，减少了内存的占用。\",\"提高性能：避免了重复创建相同的对象，提高了程序的性能。\",\"增强代码的可维护性：将对象的状态分离出来，使得代码更加清晰易读，易于维护。\",\"五、缺点\",\"增加了系统的复杂性：需要额外的代码来管理享元对象，增加了系统的复杂性。\",\"可能会导致外部状态的问题：如果享元对象需要依赖外部状态，可能会导致一些问题，例如线程安全问题。\",\"不适合用于频繁变化的对象：如果对象的状态经常变化，那么使用享元模式可能会导致性能下降。\",\"六、适用场景\",\"系统中存在大量相似的对象：如果系统中存在大量相似的对象，例如文本编辑器中的字符、图形编辑器中的图形等，那么使用享元模式可以减少内存的占用，提高程序的性能。\",\"对象的状态可以共享：如果对象的状态可以共享，例如汽车的颜色、品牌等，那么使用享元模式可以减少内存的占用，提高程序的性能。\",\"需要提高系统的性能：如果系统的性能是一个关键因素，那么使用享元模式可以提高程序的性能。\",\"七、总结\",\"享元模式是一种通过共享对象来减少内存占用和提高性能的设计模式。它适用于系统中存在大量相似对象且对象的状态可以共享的场景。通过使用享元模式，可以将对象的状态分离出来，使得代码更加清晰易读，易于维护。但是，享元模式也有一些缺点，例如增加了系统的复杂性、可能会导致外部状态的问题以及不适合用于频繁变化的对象等。因此，在使用享元模式时，需要根据具体情况进行权衡和选择。\"]},\"95\":{\"h\":\"代理模式\",\"t\":[\"一、定义\",\"代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。\",\"二、结构\",\"服务接口（Service Interface）：声明了服务接口。代理必须遵循该接口才能伪装成服务对象。\",\"服务（Service）：类提供了一些实用的业务逻辑。\",\"代理（Proxy）：包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理。\",\"客户端（Client）：能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。\",\"三、示例代码（用 C 语言汽车举例）\",\"#include <stdio.h> // 服务接口 typedef struct { void (*drive)(void); } Car; // 服务实现 typedef struct { Car car; } RealCar; void realCarDrive(void) { printf(\\\"Real Car is driving...\\\\\\\\n\\\"); } // 代理 typedef struct { RealCar *realCar; } CarProxy; void carProxyDrive(void) { printf(\\\"Car Proxy is checking...\\\\\\\\n\\\"); if (carProxy->realCar!= NULL) { carProxy->realCar->drive(); } else { printf(\\\"Real Car is not available.\\\\\\\\n\\\"); } } // 客户端 int main() { // 创建代理对象 CarProxy carProxy = {NULL}; // 模拟请求 carProxyDrive(&carProxy); // 创建真实汽车对象 RealCar realCar = {(Car){realCarDrive}}; // 将真实汽车对象与代理关联 carProxy.realCar = &realCar; // 再次模拟请求 carProxyDrive(&carProxy); return 0; }\",\"在上述示例中，我们定义了一个Car接口，其中包含一个drive方法。RealCar结构体实现了Car接口，代表真实的汽车。CarProxy结构体是Car接口的代理，它包含一个指向RealCar对象的指针。\",\"在main函数中，我们首先创建了一个CarProxy对象。然后，我们模拟了一个请求，此时代理会检查真实汽车是否可用。由于我们还没有创建真实汽车对象，所以代理会输出“Real Car is not available.”。\",\"接下来，我们创建了一个RealCar对象，并将其与代理关联。最后，我们再次模拟请求，此时代理会将请求转发给真实汽车对象，输出“Real Car is driving...”。\",\"四、优点\",\"控制请求访问：代理可以控制对真实对象的访问，例如检查权限、缓存结果等。\",\"延迟初始化：代理可以延迟创建真实对象，直到真正需要时才进行创建，从而提高性能。\",\"保护真实对象：代理可以保护真实对象，避免其直接暴露在客户端代码中，从而提高安全性。\",\"实现远程访问：代理可以实现远程访问，例如通过网络连接访问远程对象。\",\"五、缺点\",\"增加系统复杂度：代理模式需要引入额外的代理对象，增加了系统的复杂度。\",\"可能会降低性能：代理模式可能会降低系统的性能，因为代理对象需要进行额外的处理。\",\"可能会导致代码冗余：代理模式可能会导致代码冗余，因为代理对象需要实现与真实对象相同的接口。\",\"六、适用场景\",\"远程代理：适用于需要访问远程对象的场景，例如通过网络连接访问远程服务器上的对象。\",\"虚拟代理：适用于需要延迟初始化的场景，例如创建一个大型对象时，可以先创建一个虚拟代理，等到真正需要时再创建真实对象。\",\"保护代理：适用于需要保护真实对象的场景，例如限制对真实对象的访问权限。\",\"智能引用：适用于需要在没有客户端使用某个重量级对象时立即销毁该对象的场景。\",\"七、总结\",\"代理模式是一种非常有用的设计模式，它可以控制对真实对象的访问，延迟初始化，保护真实对象，实现远程访问等。但是，代理模式也有一些缺点，例如增加系统复杂度，可能会降低性能，可能会导致代码冗余等。因此，在使用代理模式时，需要根据具体情况进行权衡，选择合适的代理模式。\"]},\"96\":{\"h\":\"\"},\"97\":{\"h\":\"责任链模式（Chain of Responsibility Pattern）\",\"t\":[\"定义\",\"责任链模式是一种行为设计模式，它允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。\",\"结构\",\"责任链模式主要包括以下几个部分：\",\"抽象处理者（Handler）：定义处理请求的接口，并包含对下一个处理者的引用。\",\"具体处理者（ConcreteHandler）：实现处理请求的具体处理者，处理它所负责的请求，如果不能处理则将请求传递给下一个处理者。\",\"客户端（Client）：向链上的具体处理者对象提交请求。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，模拟不同的汽车零部件（如引擎、车轮、制动系统）检查的责任链。我们使用责任链模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 抽象处理者：汽车检查器 typedef struct CarInspector { struct CarInspector* nextInspector; void (*inspect)(struct CarInspector*, const char*); } CarInspector; // 设置下一个检查者 void setNextInspector(CarInspector* currentInspector, CarInspector* nextInspector) { currentInspector->nextInspector = nextInspector; } // 引擎检查器 typedef struct EngineInspector { CarInspector base; } EngineInspector; void inspectEngine(CarInspector* inspector, const char* component) { if (strcmp(component, \\\"Engine\\\") == 0) { printf(\\\"Inspecting the engine.\\\\\\\\n\\\"); } else if (inspector->nextInspector != NULL) { inspector->nextInspector->inspect(inspector->nextInspector, component); } else { printf(\\\"No inspector available for component: %s\\\\\\\\n\\\", component); } } EngineInspector* createEngineInspector() { EngineInspector* engineInspector = (EngineInspector*)malloc(sizeof(EngineInspector)); engineInspector->base.nextInspector = NULL; engineInspector->base.inspect = inspectEngine; return engineInspector; } // 车轮检查器 typedef struct WheelInspector { CarInspector base; } WheelInspector; void inspectWheel(CarInspector* inspector, const char* component) { if (strcmp(component, \\\"Wheel\\\") == 0) { printf(\\\"Inspecting the wheel.\\\\\\\\n\\\"); } else if (inspector->nextInspector != NULL) { inspector->nextInspector->inspect(inspector->nextInspector, component); } else { printf(\\\"No inspector available for component: %s\\\\\\\\n\\\", component); } } WheelInspector* createWheelInspector() { WheelInspector* wheelInspector = (WheelInspector*)malloc(sizeof(WheelInspector)); wheelInspector->base.nextInspector = NULL; wheelInspector->base.inspect = inspectWheel; return wheelInspector; } // 制动系统检查器 typedef struct BrakeInspector { CarInspector base; } BrakeInspector; void inspectBrake(CarInspector* inspector, const char* component) { if (strcmp(component, \\\"Brake\\\") == 0) { printf(\\\"Inspecting the brake system.\\\\\\\\n\\\"); } else if (inspector->nextInspector != NULL) { inspector->nextInspector->inspect(inspector->nextInspector, component); } else { printf(\\\"No inspector available for component: %s\\\\\\\\n\\\", component); } } BrakeInspector* createBrakeInspector() { BrakeInspector* brakeInspector = (BrakeInspector*)malloc(sizeof(BrakeInspector)); brakeInspector->base.nextInspector = NULL; brakeInspector->base.inspect = inspectBrake; return brakeInspector; } // 客户端代码 int main() { // 创建具体的检查者对象 EngineInspector* engineInspector = createEngineInspector(); WheelInspector* wheelInspector = createWheelInspector(); BrakeInspector* brakeInspector = createBrakeInspector(); // 设置责任链 setNextInspector((CarInspector*)engineInspector, (CarInspector*)wheelInspector); setNextInspector((CarInspector*)wheelInspector, (CarInspector*)brakeInspector); // 测试责任链 printf(\\\"Testing engine inspection:\\\\\\\\n\\\"); engineInspector->base.inspect((CarInspector*)engineInspector, \\\"Engine\\\"); printf(\\\"\\\\\\\\nTesting wheel inspection:\\\\\\\\n\\\"); engineInspector->base.inspect((CarInspector*)engineInspector, \\\"Wheel\\\"); printf(\\\"\\\\\\\\nTesting brake inspection:\\\\\\\\n\\\"); engineInspector->base.inspect((CarInspector*)engineInspector, \\\"Brake\\\"); printf(\\\"\\\\\\\\nTesting unknown component inspection:\\\\\\\\n\\\"); engineInspector->base.inspect((CarInspector*)engineInspector, \\\"Door\\\"); // 清理内存 free(engineInspector); free(wheelInspector); free(brakeInspector); return 0; }\",\"主要结构说明\",\"抽象处理者（CarInspector）：定义了处理请求的接口inspect，并包含对下一个处理者的引用nextInspector。\",\"具体处理者（EngineInspector、WheelInspector、BrakeInspector）：实现了处理请求的方法inspect，并在处理不了请求时将其传递给下一个处理者。\",\"客户端（main函数）：创建具体处理者对象，设置责任链，并提交请求进行测试。\",\"优点\",\"降低耦合度：将请求的发送者和接收者解耦，使得多个处理者有机会处理该请求。\",\"提高灵活性：可以动态地添加或删除责任链中的处理者，增加了系统的灵活性。\",\"增强可扩展性：新的处理者可以很方便地加入到责任链中。\",\"缺点\",\"调试困难：由于请求是在责任链中传递的，可能会导致调试和跟踪较为困难。\",\"性能问题：如果责任链过长，可能会导致性能问题，因为请求要经过多个处理者。\",\"适用场景\",\"多个对象可以处理同一请求：但是具体由哪个对象处理请求在运行时动态决定。\",\"需要动态指定处理请求的对象：并且可以灵活地改变处理者的顺序。\",\"总结\",\"责任链模式通过将请求沿着处理者链传递，使得多个处理者都有机会处理请求，降低了发送者和接收者的耦合度。在汽车应用中，责任链模式可以用于不同的汽车零部件检查，展示了责任链模式如何在实际项目中使用。\",\"命令模式\"]},\"98\":{\"h\":\"命令模式（Command Pattern）\",\"t\":[\"定义\",\"命令模式是一种行为型设计模式，它将请求封装成对象，从而使你可以用不同的请求对客户进行参数化，并且支持请求的排队、记录日志以及撤销操作。\",\"结构\",\"命令模式主要包括以下几个部分：\",\"命令接口（Command）：定义执行命令的接口。\",\"具体命令（ConcreteCommand）：实现命令接口，绑定接收者对象，调用接收者的相应操作。\",\"接收者（Receiver）：执行具体操作的类。\",\"调用者（Invoker）：持有命令对象并通过命令对象来执行请求。\",\"客户端（Client）：创建具体命令对象并设置其接收者。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，不同的命令可以控制汽车的操作（如启动发动机、停止发动机、加速等）。我们使用命令模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 定义命令接口 typedef struct Command { void (*execute)(struct Command*); void (*undo)(struct Command*); } Command; // 定义接收者：汽车 typedef struct Car { char* model; } Car; void startEngine(Car* car) { printf(\\\"Engine of %s is starting.\\\\\\\\n\\\", car->model); } void stopEngine(Car* car) { printf(\\\"Engine of %s is stopping.\\\\\\\\n\\\", car->model); } void accelerate(Car* car) { printf(\\\"Car %s is accelerating.\\\\\\\\n\\\", car->model); } // 定义具体命令：启动引擎命令 typedef struct StartEngineCommand { Command command; Car* car; } StartEngineCommand; void executeStartEngine(Command* command) { StartEngineCommand* startCommand = (StartEngineCommand*)command; startEngine(startCommand->car); } void undoStartEngine(Command* command) { StartEngineCommand* startCommand = (StartEngineCommand*)command; stopEngine(startCommand->car); } StartEngineCommand* createStartEngineCommand(Car* car) { StartEngineCommand* command = (StartEngineCommand*)malloc(sizeof(StartEngineCommand)); command->car = car; command->command.execute = executeStartEngine; command->command.undo = undoStartEngine; return command; } // 定义具体命令：停止引擎命令 typedef struct StopEngineCommand { Command command; Car* car; } StopEngineCommand; void executeStopEngine(Command* command) { StopEngineCommand* stopCommand = (StopEngineCommand*)command; stopEngine(stopCommand->car); } void undoStopEngine(Command* command) { StopEngineCommand* stopCommand = (StopEngineCommand*)command; startEngine(stopCommand->car); } StopEngineCommand* createStopEngineCommand(Car* car) { StopEngineCommand* command = (StopEngineCommand*)malloc(sizeof(StopEngineCommand)); command->car = car; command->command.execute = executeStopEngine; command->command.undo = undoStopEngine; return command; } // 定义调用者 typedef struct Invoker { Command* command; } Invoker; void setCommand(Invoker* invoker, Command* command) { invoker->command = command; } void executeCommand(Invoker* invoker) { if (invoker->command != NULL) { invoker->command->execute(invoker->command); } } void undoCommand(Invoker* invoker) { if (invoker->command != NULL) { invoker->command->undo(invoker->command); } } // 测试命令模式 int main() { // 创建接收者对象：汽车 Car car = { .model = \\\"Toyota Camry\\\" }; // 创建具体命令对象 StartEngineCommand* startCommand = createStartEngineCommand(&car); StopEngineCommand* stopCommand = createStopEngineCommand(&car); // 创建调用者对象 Invoker invoker = { .command = NULL }; // 客户端设置并执行命令 setCommand(&invoker, (Command*)startCommand); executeCommand(&invoker); // 撤销命令 undoCommand(&invoker); // 设置并执行停止引擎命令 setCommand(&invoker, (Command*)stopCommand); executeCommand(&invoker); // 撤销停止引擎命令 undoCommand(&invoker); // 清理内存 free(startCommand); free(stopCommand); return 0; }\",\"主要结构说明\",\"命令接口（Command）：定义了执行命令和撤销命令的接口。\",\"具体命令（ConcreteCommand）：实现了命令接口，将请求委托给接收者执行。例子中包括启动引擎命令和停止引擎命令。\",\"接收者（Receiver）：执行实际操作的对象，例子中为Car。\",\"调用者（Invoker）：持有命令对象并通过命令对象来执行请求。例子中Invoker负责调用命令的执行和撤销操作。\",\"客户端（Client）：创建具体命令对象并设置其接收者，例子中为main函数。\",\"优点\",\"解耦请求发送者和接收者：命令模式将请求封装成对象，使请求的发送者与接收者解耦。\",\"支持撤销和重做：命令对象可以实现撤销和重做操作。\",\"命令的组合：可以将多个命令组合成一个复合命令，从而支持宏命令。\",\"扩展性强：可以很容易地增加新的命令。\",\"缺点\",\"类数量增加：每个具体命令都需要一个对应的类，可能会导致类数量大幅增加。\",\"增加系统复杂性：引入了许多新类和对象，增加了系统的复杂性。\",\"适用场景\",\"需要对请求排队和记录日志：命令对象可以支持请求的排队、记录日志和事务操作。\",\"需要支持撤销和重做操作：命令模式可以很方便地实现操作的撤销和重做功能。\",\"请求的发送者和接收者需要解耦：通过命令对象来解耦请求的发送者和接收者。\",\"总结\",\"命令模式通过将请求封装成对象，实现了请求发送者与接收者的解耦，并支持请求的撤销和重做操作。它适用于需要对请求进行排队、记录日志以及支持撤销和重做操作的场景。在汽车应用中，命令模式可以用于控制汽车的各种操作，如启动引擎、停止引擎等。\",\"迭代器模式\"]},\"99\":{\"h\":\"迭代器模式（Iterator Pattern）\",\"t\":[\"定义\",\"迭代器模式是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。迭代器模式将遍历聚合对象的责任从聚合对象本身转移到了迭代器对象。\",\"结构\",\"迭代器模式主要包括以下几个部分：\",\"迭代器接口（Iterator）：定义访问和遍历元素的接口。\",\"具体迭代器（ConcreteIterator）：实现迭代器接口，并负责遍历聚合对象中的元素。\",\"聚合接口（Aggregate）：定义创建迭代器对象的接口。\",\"具体聚合（ConcreteAggregate）：实现聚合接口，并提供一个方法来返回具体迭代器的实例。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，管理一系列的汽车对象。我们使用迭代器模式来遍历这些汽车对象。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 汽车结构体 typedef struct { char* model; int year; } Car; // 迭代器接口 typedef struct Iterator { void (*first)(struct Iterator*); void (*next)(struct Iterator*); int (*isDone)(struct Iterator*); Car* (*currentItem)(struct Iterator*); void* aggregate; int currentIndex; } Iterator; // 汽车集合结构体 typedef struct { Car** cars; int size; int capacity; } CarCollection; // 创建汽车集合 CarCollection* createCarCollection(int capacity) { CarCollection* collection = (CarCollection*)malloc(sizeof(CarCollection)); collection->cars = (Car**)malloc(sizeof(Car*) * capacity); collection->size = 0; collection->capacity = capacity; return collection; } // 向汽车集合中添加汽车 void addCar(CarCollection* collection, Car* car) { if (collection->size < collection->capacity) { collection->cars[collection->size++] = car; } } // 迭代器方法实现 void first(Iterator* iterator) { iterator->currentIndex = 0; } void next(Iterator* iterator) { iterator->currentIndex++; } int isDone(Iterator* iterator) { CarCollection* collection = (CarCollection*)iterator->aggregate; return iterator->currentIndex >= collection->size; } Car* currentItem(Iterator* iterator) { CarCollection* collection = (CarCollection*)iterator->aggregate; if (iterator->currentIndex < collection->size) { return collection->cars[iterator->currentIndex]; } return NULL; } // 创建汽车集合的迭代器 Iterator* createIterator(CarCollection* collection) { Iterator* iterator = (Iterator*)malloc(sizeof(Iterator)); iterator->first = first; iterator->next = next; iterator->isDone = isDone; iterator->currentItem = currentItem; iterator->aggregate = collection; iterator->currentIndex = 0; return iterator; } // 测试迭代器模式 int main() { // 创建汽车集合 CarCollection* collection = createCarCollection(3); // 创建汽车对象 Car* car1 = (Car*)malloc(sizeof(Car)); car1->model = \\\"Toyota Camry\\\"; car1->year = 2023; Car* car2 = (Car*)malloc(sizeof(Car)); car2->model = \\\"Honda Accord\\\"; car2->year = 2022; Car* car3 = (Car*)malloc(sizeof(Car)); car3->model = \\\"Tesla Model 3\\\"; car3->year = 2024; // 将汽车对象添加到集合中 addCar(collection, car1); addCar(collection, car2); addCar(collection, car3); // 创建迭代器 Iterator* iterator = createIterator(collection); // 使用迭代器遍历汽车集合 for (iterator->first(iterator); !iterator->isDone(iterator); iterator->next(iterator)) { Car* car = iterator->currentItem(iterator); if (car != NULL) { printf(\\\"Car Model: %s, Year: %d\\\\\\\\n\\\", car->model, car->year); } } // 清理内存 free(car1); free(car2); free(car3); free(collection->cars); free(collection); free(iterator); return 0; }\",\"主要结构说明\",\"迭代器接口（Iterator）：定义了遍历方法 first、next、isDone 和 currentItem。还包含一个指向聚合对象的指针 aggregate 和当前索引 currentIndex。\",\"具体迭代器（ConcreteIterator）：实现了迭代器接口的方法，用于遍历 CarCollection。\",\"聚合接口（Aggregate）：本例中隐含在 CarCollection 中，没有显式定义。\",\"具体聚合（ConcreteAggregate）：实现了 CarCollection，包含汽车对象的集合。\",\"优点\",\"分离遍历算法：将遍历算法与集合对象分离，使得算法可以独立于集合对象变化。\",\"统一接口：通过定义统一的遍历接口，使得不同的集合对象可以使用相同的遍历方法。\",\"支持多种遍历方式：可以根据需要实现不同的迭代器，支持不同的遍历方式。\",\"缺点\",\"额外的开销：由于引入了迭代器对象，可能会增加额外的开销。\",\"复杂性增加：增加了类的数量，可能会使系统变得复杂。\",\"适用场景\",\"需要遍历不同类型的集合对象：并且希望使用统一的遍历接口。\",\"需要支持多种遍历方式：如前序遍历、后序遍历、中序遍历等。\",\"希望分离遍历算法和集合对象：使得两者可以独立变化。\",\"总结\",\"迭代器模式通过定义统一的遍历接口，使得不同的集合对象可以使用相同的遍历方法。它适用于需要遍历不同类型的集合对象，并希望支持多种遍历方式的场景。在汽车应用中，迭代器模式可以用于遍历汽车集合对象，展示了迭代器模式如何在实际项目中使用。\"]},\"100\":{\"h\":\"中介者模式（Mediator Pattern）\",\"t\":[\"定义\",\"中介者模式是一种行为型设计模式，它通过引入一个中介对象来封装一系列对象之间的交互，使各个对象不需要显式地相互引用，从而实现松散耦合，并且可以独立地改变它们之间的交互。\",\"结构\",\"中介者模式主要包括以下几个部分：\",\"中介者接口（Mediator）：定义一个接口用于与各同事对象之间的通信。\",\"具体中介者（ConcreteMediator）：实现中介者接口，协调各同事对象之间的交互。\",\"同事类（Colleague）：各同事类只知道中介者，而不知道其他同事类。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，其中包括不同的汽车部件（如引擎、变速箱）相互通信。我们使用中介者模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 定义中介者接口 typedef struct Mediator { void (*notify)(struct Mediator*, const char* event); } Mediator; // 定义同事类接口 typedef struct Colleague { Mediator* mediator; } Colleague; // 定义具体同事类：引擎 typedef struct Engine { Colleague colleague; void (*startEngine)(struct Engine*); } Engine; void startEngine(Engine* engine) { printf(\\\"Engine started.\\\\\\\\n\\\"); engine->colleague.mediator->notify(engine->colleague.mediator, \\\"EngineStarted\\\"); } Engine* createEngine(Mediator* mediator) { Engine* engine = (Engine*)malloc(sizeof(Engine)); engine->colleague.mediator = mediator; engine->startEngine = startEngine; return engine; } // 定义具体同事类：变速箱 typedef struct Transmission { Colleague colleague; void (*shiftGear)(struct Transmission*); } Transmission; void shiftGear(Transmission* transmission) { printf(\\\"Transmission shifting gear.\\\\\\\\n\\\"); transmission->colleague.mediator->notify(transmission->colleague.mediator, \\\"GearShifted\\\"); } Transmission* createTransmission(Mediator* mediator) { Transmission* transmission = (Transmission*)malloc(sizeof(Transmission)); transmission->colleague.mediator = mediator; transmission->shiftGear = shiftGear; return transmission; } // 定义具体中介者 typedef struct CarMediator { Mediator mediator; Engine* engine; Transmission* transmission; } CarMediator; void notify(Mediator* mediator, const char* event) { CarMediator* carMediator = (CarMediator*)mediator; if (strcmp(event, \\\"EngineStarted\\\") == 0) { printf(\\\"Mediator: Engine has started, now shifting gear.\\\\\\\\n\\\"); carMediator->transmission->shiftGear(carMediator->transmission); } else if (strcmp(event, \\\"GearShifted\\\") == 0) { printf(\\\"Mediator: Gear has been shifted.\\\\\\\\n\\\"); } } CarMediator* createCarMediator() { CarMediator* mediator = (CarMediator*)malloc(sizeof(CarMediator)); mediator->mediator.notify = notify; mediator->engine = NULL; mediator->transmission = NULL; return mediator; } // 测试中介者模式 int main() { // 创建中介者 CarMediator* carMediator = createCarMediator(); // 创建同事类对象并设置中介者 Engine* engine = createEngine((Mediator*)carMediator); Transmission* transmission = createTransmission((Mediator*)carMediator); // 设置中介者的同事类 carMediator->engine = engine; carMediator->transmission = transmission; // 启动引擎 engine->startEngine(engine); // 清理内存 free(engine); free(transmission); free(carMediator); return 0; }\",\"主要结构说明\",\"中介者接口（Mediator）：定义了一个通知方法 notify，用于同事类之间的通信。\",\"具体中介者（ConcreteMediator）：实现了中介者接口，协调同事类之间的交互。在本例中是 CarMediator。\",\"同事类（Colleague）：包括引擎（Engine）和变速箱（Transmission），它们通过中介者进行通信。\",\"优点\",\"降低耦合：中介者模式通过引入一个中介对象，使各同事类不需要显式地相互引用，降低了对象之间的耦合度。\",\"简化对象交互：中介者封装了对象之间的交互逻辑，使得系统更容易理解和维护。\",\"集中控制：中介者模式将交互逻辑集中到中介者中，使得修改和扩展交互行为更加方便。\",\"缺点\",\"中介者复杂性：随着同事类的增加，中介者的复杂性也会增加，可能会变得难以维护。\",\"性能问题：中介者模式引入了额外的中介对象，可能会对系统性能产生一定的影响。\",\"适用场景\",\"对象之间存在复杂的引用关系：需要通过一个中介对象来管理这些关系。\",\"需要解耦多个对象之间的交互：避免对象之间的直接依赖。\",\"希望集中控制交互逻辑：使得系统更易于理解和维护。\",\"总结\",\"中介者模式通过引入一个中介对象，使各同事类不需要显式地相互引用，降低了对象之间的耦合度，并简化了对象之间的交互。在汽车应用中，中介者模式可以用于协调汽车部件（如引擎、变速箱）之间的交互，展示了中介者模式如何在实际项目中使用。\"]},\"101\":{\"h\":\"备忘录模式（Memento Pattern）\",\"t\":[\"定义\",\"备忘录模式是一种行为型设计模式，它允许在不破坏封装的前提下，捕获和恢复对象的内部状态。备忘录模式将对象的状态保存到一个备忘录对象中，以便以后恢复到之前的状态。\",\"结构\",\"备忘录模式主要包括以下几个部分：\",\"发起人（Originator）：创建一个包含其当前内部状态的备忘录对象，并使用备忘录对象恢复其内部状态。\",\"备忘录（Memento）：存储发起人的内部状态，并防止其他对象访问备忘录。备忘录一般是不可变的。\",\"负责人（Caretaker）：负责保存和恢复备忘录，但不能操作或检查备忘录的内容。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，汽车的状态（如速度、燃油量）可以保存和恢复。我们使用备忘录模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #include <string.h> // 定义汽车状态结构体 typedef struct { int speed; int fuel; } CarState; // 定义备忘录结构体 typedef struct { CarState state; } Memento; // 定义汽车结构体 typedef struct { int speed; int fuel; } Car; // 创建备忘录 Memento* createMemento(Car* car) { Memento* memento = (Memento*)malloc(sizeof(Memento)); memento->state.speed = car->speed; memento->state.fuel = car->fuel; return memento; } // 从备忘录恢复状态 void restoreFromMemento(Car* car, Memento* memento) { car->speed = memento->state.speed; car->fuel = memento->state.fuel; } // 打印汽车状态 void printCarState(Car* car) { printf(\\\"Car state - Speed: %d, Fuel: %d\\\\\\\\n\\\", car->speed, car->fuel); } // 测试备忘录模式 int main() { // 创建汽车对象 Car* car = (Car*)malloc(sizeof(Car)); car->speed = 100; car->fuel = 50; // 打印初始状态 printCarState(car); // 创建备忘录并保存当前状态 Memento* memento = createMemento(car); // 改变汽车状态 car->speed = 150; car->fuel = 20; printCarState(car); // 从备忘录恢复状态 restoreFromMemento(car, memento); printCarState(car); // 清理内存 free(memento); free(car); return 0; }\",\"主要结构说明\",\"发起人（Originator）：Car 结构体，包括汽车的状态（速度和燃油量），并包含创建备忘录和从备忘录恢复状态的方法。\",\"备忘录（Memento）：Memento 结构体，存储汽车的状态。\",\"负责人（Caretaker）：本例中由 main 函数充当，负责保存和恢复备忘录。\",\"优点\",\"封装性：备忘录模式通过封装对象的状态，保持了对象的封装性，不会暴露对象的内部细节。\",\"简化状态管理：通过备忘录，可以方便地保存和恢复对象的状态，简化了状态管理。\",\"支持撤销操作：备忘录模式可以用于实现撤销操作，方便恢复到之前的状态。\",\"缺点\",\"内存消耗：如果对象的状态非常复杂，保存多个备忘录会占用较多内存。\",\"性能开销：创建和恢复备忘录需要额外的计算开销，可能会影响性能。\",\"实现复杂性：在某些情况下，实现备忘录模式可能会比较复杂，特别是涉及到对象的深拷贝。\",\"适用场景\",\"需要保存和恢复对象的状态：适用于需要频繁保存和恢复对象状态的场景，如撤销操作、历史记录等。\",\"需要避免暴露对象的内部状态：通过备忘录模式，可以保持对象的封装性，避免暴露内部细节。\",\"需要支持撤销操作：备忘录模式可以方便地实现撤销操作，恢复到之前的状态。\",\"总结\",\"备忘录模式通过封装对象的状态，提供了一种保存和恢复对象状态的方法。它保持了对象的封装性，简化了状态管理，并且可以用于实现撤销操作。在汽车应用中，备忘录模式可以用于保存和恢复汽车的状态，如速度和燃油量，展示了备忘录模式如何在实际项目中使用。\"]},\"102\":{\"h\":\"观察者模式（Observer Pattern）\",\"t\":[\"定义\",\"观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，其相关依赖对象会得到通知并自动更新。这种模式有时也被称为发布-订阅模式。\",\"结构\",\"观察者模式主要包括以下几个部分：\",\"主题（Subject）：维护一个观察者列表，并提供注册、移除和通知观察者的方法。\",\"观察者（Observer）：定义一个更新接口，当主题的状态发生变化时通知观察者。\",\"具体主题（ConcreteSubject）：实现主题接口，维护主题的状态，并在状态改变时通知所有观察者。\",\"具体观察者（ConcreteObserver）：实现观察者接口，定义在接收到通知时的行为。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，当汽车的状态（如速度、燃油量）发生变化时，通知相关的监控系统（如仪表盘、导航系统）。我们使用观察者模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> #define MAX_OBSERVERS 10 // 定义观察者接口 typedef struct Observer { void (*update)(struct Observer*, int, int); } Observer; // 定义主题接口 typedef struct Subject { void (*registerObserver)(struct Subject*, Observer*); void (*removeObserver)(struct Subject*, Observer*); void (*notifyObservers)(struct Subject*); Observer* observers[MAX_OBSERVERS]; int observerCount; int speed; int fuel; } Subject; // 具体观察者：仪表盘 typedef struct { Observer observer; void (*update)(struct Observer*, int, int); } Dashboard; void updateDashboard(Observer* observer, int speed, int fuel) { printf(\\\"Dashboard: Speed = %d, Fuel = %d\\\\\\\\n\\\", speed, fuel); } Dashboard* createDashboard() { Dashboard* dashboard = (Dashboard*)malloc(sizeof(Dashboard)); dashboard->observer.update = updateDashboard; return dashboard; } // 具体观察者：导航系统 typedef struct { Observer observer; void (*update)(struct Observer*, int, int); } Navigation; void updateNavigation(Observer* observer, int speed, int fuel) { printf(\\\"Navigation: Speed = %d, Fuel = %d\\\\\\\\n\\\", speed, fuel); } Navigation* createNavigation() { Navigation* navigation = (Navigation*)malloc(sizeof(Navigation)); navigation->observer.update = updateNavigation; return navigation; } // 具体主题：汽车 typedef struct { Subject subject; } Car; void registerObserver(Subject* subject, Observer* observer) { if (subject->observerCount < MAX_OBSERVERS) { subject->observers[subject->observerCount++] = observer; } } void removeObserver(Subject* subject, Observer* observer) { for (int i = 0; i < subject->observerCount; i++) { if (subject->observers[i] == observer) { for (int j = i; j < subject->observerCount - 1; j++) { subject->observers[j] = subject->observers[j + 1]; } subject->observerCount--; break; } } } void notifyObservers(Subject* subject) { for (int i = 0; i < subject->observerCount; i++) { subject->observers[i]->update(subject->observers[i], subject->speed, subject->fuel); } } Car* createCar() { Car* car = (Car*)malloc(sizeof(Car)); car->subject.registerObserver = registerObserver; car->subject.removeObserver = removeObserver; car->subject.notifyObservers = notifyObservers; car->subject.observerCount = 0; car->subject.speed = 0; car->subject.fuel = 0; return car; } void setCarState(Car* car, int speed, int fuel) { car->subject.speed = speed; car->subject.fuel = fuel; car->subject.notifyObservers((Subject*)car); } // 测试观察者模式 int main() { // 创建汽车对象 Car* car = createCar(); // 创建观察者对象 Dashboard* dashboard = createDashboard(); Navigation* navigation = createNavigation(); // 注册观察者 car->subject.registerObserver((Subject*)car, (Observer*)dashboard); car->subject.registerObserver((Subject*)car, (Observer*)navigation); // 改变汽车状态，通知观察者 setCarState(car, 100, 50); setCarState(car, 150, 20); // 移除一个观察者 car->subject.removeObserver((Subject*)car, (Observer*)dashboard); // 再次改变汽车状态，通知剩余观察者 setCarState(car, 200, 10); // 清理内存 free(dashboard); free(navigation); free(car); return 0; }\",\"主要结构说明\",\"主题接口（Subject）：定义了注册、移除和通知观察者的方法。\",\"观察者接口（Observer）：定义了更新方法 update，当主题的状态发生变化时调用。\",\"具体主题（ConcreteSubject）：Car 结构体，实现了主题接口，并维护主题的状态（速度和燃油量）。\",\"具体观察者（ConcreteObserver）：Dashboard 和 Navigation 结构体，实现了观察者接口，定义了在接收到通知时的行为。\",\"优点\",\"解耦：观察者模式使得主题和观察者之间的依赖关系减少，从而实现低耦合。\",\"易于扩展：可以方便地增加或删除观察者，符合开放-关闭原则。\",\"广播通信：主题可以向所有注册的观察者广播更新通知，简化了消息的传递。\",\"缺点\",\"通知延迟：如果观察者较多，或者通知的频率较高，可能会导致通知延迟。\",\"复杂性增加：如果观察者和主题之间的依赖关系过于复杂，可能会增加系统的复杂性和维护成本。\",\"无序更新：观察者接收通知的顺序可能是不确定的，如果顺序很重要，需要额外处理。\",\"适用场景\",\"状态变化通知：需要在一个对象状态发生变化时通知其他对象。\",\"多级联动更新：一个对象的更新需要触发其他对象的更新，如图形界面中的数据绑定。\",\"事件处理系统：用于实现事件处理和广播机制，如订阅-发布系统。\",\"总结\",\"观察者模式通过定义一对多的依赖关系，使得主题和观察者之间的交互更加灵活和松散耦合。在汽车应用中，观察者模式可以用于监控汽车状态的变化，并通知相关的监控系统，如仪表盘和导航系统，展示了观察者模式如何在实际项目中使用。\"]},\"103\":{\"h\":\"状态模式（State Pattern）\",\"t\":[\"定义\",\"状态模式是一种行为型设计模式，它允许对象在其内部状态改变时改变其行为。状态模式将状态的相关行为封装到独立的状态类中，使得状态切换更加明确和可管理。\",\"结构\",\"状态模式主要包括以下几个部分：\",\"状态接口（State）：定义一个接口，封装与上下文的一个特定状态相关的行为。\",\"具体状态（ConcreteState）：实现状态接口的具体状态类，每一个类实现一个与上下文的一个状态相关的行为。\",\"上下文（Context）：维护一个当前状态，并且可以切换状态。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，汽车有不同的状态（如启动、行驶、停止）。我们使用状态模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> // 定义状态接口 typedef struct Car Car; // 前向声明 typedef struct State { void (*start)(Car*); void (*drive)(Car*); void (*stop)(Car*); } State; // 定义汽车结构体 struct Car { State* currentState; }; // 启动状态 typedef struct { State state; } StartState; void startStateStart(Car* car); void startStateDrive(Car* car); void startStateStop(Car* car); StartState* createStartState() { StartState* state = (StartState*)malloc(sizeof(StartState)); state->state.start = startStateStart; state->state.drive = startStateDrive; state->state.stop = startStateStop; return state; } void startStateStart(Car* car) { printf(\\\"Car is already started.\\\\\\\\n\\\"); } void startStateDrive(Car* car) { printf(\\\"Car is now driving.\\\\\\\\n\\\"); // 切换到行驶状态 extern State* drivingState; car->currentState = drivingState; } void startStateStop(Car* car) { printf(\\\"Car is stopping from start state.\\\\\\\\n\\\"); // 切换到停止状态 extern State* stoppedState; car->currentState = stoppedState; } // 行驶状态 typedef struct { State state; } DrivingState; void drivingStateStart(Car* car); void drivingStateDrive(Car* car); void drivingStateStop(Car* car); DrivingState* createDrivingState() { DrivingState* state = (DrivingState*)malloc(sizeof(DrivingState)); state->state.start = drivingStateStart; state->state.drive = drivingStateDrive; state->state.stop = drivingStateStop; return state; } void drivingStateStart(Car* car) { printf(\\\"Car is already driving.\\\\\\\\n\\\"); } void drivingStateDrive(Car* car) { printf(\\\"Car is already driving.\\\\\\\\n\\\"); } void drivingStateStop(Car* car) { printf(\\\"Car is stopping from driving state.\\\\\\\\n\\\"); // 切换到停止状态 extern State* stoppedState; car->currentState = stoppedState; } // 停止状态 typedef struct { State state; } StoppedState; void stoppedStateStart(Car* car); void stoppedStateDrive(Car* car); void stoppedStateStop(Car* car); StoppedState* createStoppedState() { StoppedState* state = (StoppedState*)malloc(sizeof(StoppedState)); state->state.start = stoppedStateStart; state->state.drive = stoppedStateDrive; state->state.stop = stoppedStateStop; return state; } void stoppedStateStart(Car* car) { printf(\\\"Car is starting from stop state.\\\\\\\\n\\\"); // 切换到启动状态 extern State* startState; car->currentState = startState; } void stoppedStateDrive(Car* car) { printf(\\\"Car needs to be started first before driving.\\\\\\\\n\\\"); } void stoppedStateStop(Car* car) { printf(\\\"Car is already stopped.\\\\\\\\n\\\"); } // 全局状态实例 State* startState; State* drivingState; State* stoppedState; // 初始化全局状态 void initializeStates() { startState = (State*)createStartState(); drivingState = (State*)createDrivingState(); stoppedState = (State*)createStoppedState(); } // 释放全局状态 void releaseStates() { free(startState); free(drivingState); free(stoppedState); } // 创建汽车 Car* createCar() { Car* car = (Car*)malloc(sizeof(Car)); car->currentState = stoppedState; // 初始状态为停止 return car; } // 测试状态模式 int main() { initializeStates(); Car* car = createCar(); car->currentState->start(car); car->currentState->drive(car); car->currentState->stop(car); car->currentState->drive(car); car->currentState->stop(car); free(car); releaseStates(); return 0; }\",\"主要结构说明\",\"状态接口（State）：定义了汽车的状态接口，包括 start、drive 和 stop 方法。\",\"具体状态（ConcreteState）：包括 StartState、DrivingState 和 StoppedState，分别实现了状态接口的具体行为。\",\"上下文（Context）：Car 结构体，维护当前状态并委托状态处理具体行为。\",\"优点\",\"状态切换清晰：状态模式将状态相关的行为封装在独立的状态类中，使状态切换更加清晰。\",\"易于扩展：可以方便地添加新的状态或修改现有状态，而无需改变上下文的代码。\",\"符合单一职责原则：每个状态类只负责与其状态相关的行为。\",\"缺点\",\"类的数量增加：每个具体状态都需要定义一个类，可能会导致类的数量增加。\",\"状态切换的管理：需要手动管理状态的切换逻辑，可能会增加一定的复杂性。\",\"适用场景\",\"对象的行为依赖于其状态：对象的行为随状态变化而变化。\",\"需要明确状态转换的场景：需要明确地定义对象在不同状态下的行为。\",\"状态切换频繁：对象在运行时需要频繁切换状态。\",\"总结\",\"状态模式通过将状态相关的行为封装到独立的状态类中，使得状态切换更加清晰和可管理。在汽车应用中，状态模式可以用于表示汽车的不同状态（启动、行驶、停止），并根据状态的变化执行相应的行为，展示了状态模式如何在实际项目中使用。\"]},\"104\":{\"h\":\"策略模式（Strategy Pattern）\",\"t\":[\"定义\",\"策略模式是一种行为型设计模式，它定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换，算法的变化不会影响使用算法的客户。策略模式使得算法可以独立于使用它的客户而变化。\",\"结构\",\"策略模式主要包括以下几个部分：\",\"策略接口（Strategy）：定义所有支持的算法的公共接口。\",\"具体策略（ConcreteStrategy）：实现策略接口的具体算法。\",\"上下文（Context）：维护一个策略对象的引用，并且可以动态地更换策略。\",\"示例代码\",\"假设我们要设计一个汽车应用程序，汽车有不同的驾驶模式（如经济模式、运动模式、普通模式）。我们使用策略模式来实现这一点。\",\"#include <stdio.h> #include <stdlib.h> // 定义策略接口 typedef struct Car Car; typedef struct { void (*drive)(Car*); } DriveStrategy; // 定义汽车结构体 struct Car { DriveStrategy* strategy; }; // 具体策略：经济模式 typedef struct { DriveStrategy strategy; } EconomicMode; void driveEconomic(Car* car) { printf(\\\"Driving in economic mode: Saving fuel.\\\\\\\\n\\\"); } EconomicMode* createEconomicMode() { EconomicMode* mode = (EconomicMode*)malloc(sizeof(EconomicMode)); mode->strategy.drive = driveEconomic; return mode; } // 具体策略：运动模式 typedef struct { DriveStrategy strategy; } SportMode; void driveSport(Car* car) { printf(\\\"Driving in sport mode: Enhanced performance.\\\\\\\\n\\\"); } SportMode* createSportMode() { SportMode* mode = (SportMode*)malloc(sizeof(SportMode)); mode->strategy.drive = driveSport; return mode; } // 具体策略：普通模式 typedef struct { DriveStrategy strategy; } NormalMode; void driveNormal(Car* car) { printf(\\\"Driving in normal mode: Balanced performance.\\\\\\\\n\\\"); } NormalMode* createNormalMode() { NormalMode* mode = (NormalMode*)malloc(sizeof(NormalMode)); mode->strategy.drive = driveNormal; return mode; } // 设置策略 void setStrategy(Car* car, DriveStrategy* strategy) { car->strategy = strategy; } // 创建汽车 Car* createCar() { Car* car = (Car*)malloc(sizeof(Car)); car->strategy = NULL; // 初始没有策略 return car; } // 测试策略模式 int main() { Car* car = createCar(); EconomicMode* economicMode = createEconomicMode(); SportMode* sportMode = createSportMode(); NormalMode* normalMode = createNormalMode(); setStrategy(car, (DriveStrategy*)economicMode); car->strategy->drive(car); setStrategy(car, (DriveStrategy*)sportMode); car->strategy->drive(car); setStrategy(car, (DriveStrategy*)normalMode); car->strategy->drive(car); // 清理内存 free(economicMode); free(sportMode); free(normalMode); free(car); return 0; }\",\"主要结构说明\",\"策略接口（Strategy）：定义了 drive 方法，表示不同的驾驶模式。\",\"具体策略（ConcreteStrategy）：包括 EconomicMode、SportMode 和 NormalMode，分别实现了不同的驾驶模式。\",\"上下文（Context）：Car 结构体，维护一个策略对象的引用，并提供设置策略的方法。\",\"优点\",\"算法的封装：策略模式将算法的实现和使用分离，使得算法可以独立于使用它的客户而变化。\",\"易于扩展：可以方便地增加新的策略而无需修改上下文类，符合开放-关闭原则。\",\"动态切换：可以在运行时动态切换策略，提供了更大的灵活性。\",\"缺点\",\"策略数目增加：如果策略过多，会导致类的数量增加，增加系统的复杂性。\",\"上下文需要了解策略：上下文必须知道所有的策略，并根据需要选择合适的策略。\",\"适用场景\",\"需要动态选择算法：在运行时需要根据不同的条件选择不同的算法。\",\"算法多变且易于扩展：算法经常变化并且需要增加新的算法。\",\"避免多重条件语句：使用策略模式可以避免在上下文中使用大量的条件语句来选择算法。\",\"总结\",\"策略模式通过定义一系列算法，并将每一个算法封装起来，使得它们可以相互替换，算法的变化不会影响使用算法的客户。在汽车应用中，策略模式可以用于实现不同的驾驶模式（如经济模式、运动模式、普通模式），展示了策略模式如何在实际项目中使用。\"]},\"105\":{\"h\":\"模板方法模式（Template Method Pattern）\",\"t\":[\"定义\",\"模板方法模式是一种行为型设计模式，定义了一个算法的骨架，将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。\",\"结构\",\"模板方法模式通常由以下几个部分组成：\",\"抽象类（Abstract Class）：定义了算法的骨架，包括一些抽象方法来延迟到子类实现。\",\"具体子类（Concrete Class）：实现抽象类中的抽象方法，完成算法中特定步骤的具体实现。\",\"示例代码\",\"假设我们要设计一个汽车制造的程序，其中有两种具体的汽车制造流程：制造经济型汽车和制造豪华型汽车。这两种汽车制造过程中的某些步骤是相同的，而某些步骤则因车型不同而有所差异。我们可以使用模板方法模式来实现这一设计。\",\"#include <stdio.h> // 抽象类：汽车制造过程 typedef struct { void (*assembleBody)(); void (*installEngine)(); void (*installWheels)(); void (*paint)(); void (*finalize)(); } CarManufacturingProcess; // 具体类：制造经济型汽车 typedef struct { CarManufacturingProcess super; } EconomyCar; void assembleBodyEconomy() { printf(\\\"Assembling body of Economy Car.\\\\\\\\n\\\"); } void installEngineEconomy() { printf(\\\"Installing engine of Economy Car.\\\\\\\\n\\\"); } void installWheelsEconomy() { printf(\\\"Installing wheels of Economy Car.\\\\\\\\n\\\"); } void paintEconomy() { printf(\\\"Painting Economy Car.\\\\\\\\n\\\"); } void finalizeEconomy() { printf(\\\"Economy Car manufacturing finalized.\\\\\\\\n\\\"); } void constructEconomyCar() { EconomyCar economyCar = { .super = { .assembleBody = assembleBodyEconomy, .installEngine = installEngineEconomy, .installWheels = installWheelsEconomy, .paint = paintEconomy, .finalize = finalizeEconomy } }; economyCar.super.assembleBody(); economyCar.super.installEngine(); economyCar.super.installWheels(); economyCar.super.paint(); economyCar.super.finalize(); } // 具体类：制造豪华型汽车 typedef struct { CarManufacturingProcess super; } LuxuryCar; void assembleBodyLuxury() { printf(\\\"Assembling body of Luxury Car.\\\\\\\\n\\\"); } void installEngineLuxury() { printf(\\\"Installing powerful engine of Luxury Car.\\\\\\\\n\\\"); } void installWheelsLuxury() { printf(\\\"Installing large wheels of Luxury Car.\\\\\\\\n\\\"); } void paintLuxury() { printf(\\\"Painting Luxury Car with metallic paint.\\\\\\\\n\\\"); } void finalizeLuxury() { printf(\\\"Luxury Car manufacturing finalized with additional features.\\\\\\\\n\\\"); } void constructLuxuryCar() { LuxuryCar luxuryCar = { .super = { .assembleBody = assembleBodyLuxury, .installEngine = installEngineLuxury, .installWheels = installWheelsLuxury, .paint = paintLuxury, .finalize = finalizeLuxury } }; luxuryCar.super.assembleBody(); luxuryCar.super.installEngine(); luxuryCar.super.installWheels(); luxuryCar.super.paint(); luxuryCar.super.finalize(); } int main() { printf(\\\"Manufacturing Economy Car:\\\\\\\\n\\\"); constructEconomyCar(); printf(\\\"\\\\\\\\n\\\"); printf(\\\"Manufacturing Luxury Car:\\\\\\\\n\\\"); constructLuxuryCar(); return 0; }\",\"主要结构说明\",\"抽象类（CarManufacturingProcess）：定义了汽车制造过程的骨架，包括一系列步骤（方法），其中某些步骤是抽象的，延迟到具体子类实现。\",\"具体类（EconomyCar 和 LuxuryCar）：实现了抽象类中的抽象方法，完成了制造过程中的具体步骤。\",\"优点\",\"代码复用：模板方法将公共的步骤实现在抽象类中，避免了代码重复。\",\"扩展性：子类可以通过覆盖抽象方法来改变算法的某些步骤，同时保持算法的整体结构不变。\",\"控制流程：抽象类中的模板方法定义了算法的框架和步骤顺序，提高了代码的逻辑清晰性和可维护性。\",\"缺点\",\"复杂度增加：可能会导致类的数量增加，特别是有多个变种的算法时。\",\"限制子类的灵活性：模板方法定义了算法的骨架，有时子类想要改变骨架可能比较困难。\",\"适用场景\",\"多个算法有共同的流程：有多个算法，且它们之间有一些共同的步骤。\",\"避免代码重复：需要在多个类中实现相同的代码，但有些步骤因子类而异。\",\"控制子类扩展：框架需要控制子类扩展，以确保它们不改变算法的结构。\",\"总结\",\"模板方法模式通过定义一个算法的骨架，将一些步骤延迟到子类中实现，从而使得不同的子类可以在不改变算法结构的情况下重新定义算法的某些步骤。在汽车制造的示例中，展示了如何通过模板方法模式实现经济型汽车和豪华型汽车的制造过程，突出了模板方法在实际项目中的应用。\"]},\"106\":{\"h\":\"访问者模式（Visitor Pattern）\",\"t\":[\"定义\",\"访问者模式是一种行为型设计模式，它允许你定义一些操作，而无需修改要操作的元素类。通过将操作封装在访问者对象中，可以在不改变各元素类的情况下增加新操作。访问者模式的核心思想是将数据结构与数据操作分离，使得操作可以独立变化而不影响数据结构。\",\"结构\",\"访问者模式的结构包括以下几个主要组成部分：\",\"抽象访问者（Visitor）：定义了对每个具体元素类（如 Car, SUV, Truck）中的各种操作，它包含一系列的 visit 方法，每个方法对应一个具体元素类。\",\"具体访问者（ConcreteVisitor）：实现了抽象访问者中声明的各种 visit 方法，完成对具体元素的操作。\",\"元素（Element）：定义了一个接收访问者对象的 accept 方法，通常是一个抽象类或接口，可以有多个具体子类。\",\"具体元素（ConcreteElement）：实现了 accept 方法，在其中调用访问者对象的对应方法以便对自身进行操作。\",\"对象结构（Object Structure）：一个元素的集合，提供 accept 方法以便访问者访问它的元素。\",\"示例代码\",\"以下是使用访问者模式实现的一个简单汽车应用示例：\",\"#include <stdio.h> // 前置声明 typedef struct Car Car; typedef struct SUV SUV; typedef struct Truck Truck; typedef struct Visitor Visitor; // 抽象访问者 struct Visitor { void (*visitCar)(Car*); void (*visitSUV)(SUV*); void (*visitTruck)(Truck*); }; // 抽象元素：汽车 struct Car { char* model; int year; void (*accept)(Car*, Visitor*); }; // 抽象元素：SUV struct SUV { char* model; int year; void (*accept)(SUV*, Visitor*); }; // 抽象元素：卡车 struct Truck { char* model; int year; void (*accept)(Truck*, Visitor*); }; // 具体访问者：汽车特性展示访问者 typedef struct { Visitor super; } CarFeaturesVisitor; void visitCar(Car* car) { printf(\\\"Visiting Car: Model %s, Year %d\\\\\\\\n\\\", car->model, car->year); } void visitSUV(SUV* suv) { printf(\\\"Visiting SUV: Model %s, Year %d\\\\\\\\n\\\", suv->model, suv->year); } void visitTruck(Truck* truck) { printf(\\\"Visiting Truck: Model %s, Year %d\\\\\\\\n\\\", truck->model, truck->year); } // 具体元素实现 accept 方法 void carAccept(Car* car, Visitor* visitor) { car->accept = carAccept; visitor->visitCar(car); } void suvAccept(SUV* suv, Visitor* visitor) { suv->accept = suvAccept; visitor->visitSUV(suv); } void truckAccept(Truck* truck, Visitor* visitor) { truck->accept = truckAccept; visitor->visitTruck(truck); } // 测试代码 int main() { CarFeaturesVisitor carFeaturesVisitor = { .super = { .visitCar = visitCar, .visitSUV = visitSUV, .visitTruck = visitTruck } }; Car car = { .model = \\\"Toyota Camry\\\", .year = 2023, .accept = carAccept }; SUV suv = { .model = \\\"Honda CR-V\\\", .year = 2022, .accept = suvAccept }; Truck truck = { .model = \\\"Ford F-150\\\", .year = 2021, .accept = truckAccept }; car.accept(&car, (Visitor*)&carFeaturesVisitor); suv.accept(&suv, (Visitor*)&carFeaturesVisitor); truck.accept(&truck, (Visitor*)&carFeaturesVisitor); return 0; }\",\"优点\",\"分离关注点：访问者模式将数据结构与操作分离，使得可以在不改变元素类的情况下增加新操作。\",\"增加新操作：通过增加新的具体访问者，可以方便地在现有系统中添加新的操作，符合开闭原则。\",\"集中相关操作：将相关的操作集中到一个访问者中，使得代码更加易于维护和理解。\",\"缺点\",\"增加新元素困难：如果需要在系统中增加新的元素类型，需要修改所有具体访问者类，可能导致系统的复杂性增加。\",\"破坏封装：访问者模式要求访问者对象访问元素的内部状态，这可能会破坏元素对象的封装性。\",\"适用场景\",\"当一个对象结构包含多个类型的对象，且希望对这些对象进行不同的操作时，可以考虑使用访问者模式。\",\"当需要对现有的对象结构添加新的操作而不改变其结构时，访问者模式是一个比较好的选择。\",\"当对象结构中的元素类经常变化，但操作算法相对稳定时，访问者模式可以帮助我们避免在每个元素类中增加新操作。\",\"总结\",\"访问者模式通过将数据结构与数据操作分离，提供了一种灵活的方式来处理多种类型的元素及其操作。它能够有效地增加新的操作而不改变元素类结构，但也可能会导致系统的复杂性增加，特别是在增加新元素类型时需要谨慎设计。在示例中，我们展示了如何通过访问者模式来访问不同类型的汽车并执行特定的操作，以便更好地理解和应用这种设计模式。\"]},\"107\":{\"h\":\"\",\"t\":[\"《深入设计模式》\",\"《设计模式：可复用面向对象软件的基础》\",\"《重构与模式》\",\"《代码整洁之道》\",\"《敏捷软件开发：原则、模式与实践》\",\"《Head First 设计模式》\",\"《Effective Java》\",\"《设计模式解析》\",\"《大话设计模式》\",\"《重构：改善既有代码的设计》\"]},\"108\":{\"c\":[\"使用指南\"]},\"109\":{\"c\":[\"设计模式\",\"C\"]},\"110\":{\"h\":\"《炒股的智慧》读书笔记\",\"t\":[\"《炒股的智慧》读书笔记\"]},\"111\":{\"h\":\"引言\",\"t\":[\"因为赚钱时，你不知自己为何赚了钱，你不知下次要怎么办才能重复赚钱的经历；亏钱时，你不明白自己为何亏了钱，下次要怎么做才能防止亏钱的再次发生。我希望你能在这本书中找到解决这些问题的答案。\",\"朋友，你开始看这本书，准备玩全世界最刺激的游戏并要成为专家时，我要给你这样的忠告：不要怕，也不要悔；玩游戏之前，先搞清游戏的规则，面对人为操纵的赌局，一定要摸清对方的心理；最后提醒你，小偷的本事不在偷，而在于危急的时候怎么逃。\",\"何以一般股民败多胜少，那就是：人性使然！说的全面些，就是这些永远不变的人性——讨厌风险、急着发财、自以为是、赶潮跟风、因循守旧和耿于报复\",\"我慢慢感悟这些聪明人失败的原因大约有两个：一、炒股的技能太活了；二，他们太聪明，选择太多。\",\"“贪”是人性，“不贪”是经验。\",\"你们选择太多，所以成功的机会不大。\",\"股票的迷惑性不在于股票所基于的价值，而在于它给炒股者提供的幻想。\",\"股市这一恒久的赌局却要求你每时每刻都要做理性的决定且为决定的结果负全部的责任！这就淘汰了一大部分股民，因为他们没有办法长期承担这样的心理压力。\",\"这一恒久变动的股市还有一致命的特点：它能使你亏掉较预期多得多的\",\"使股民蒙受超出预期损失的第二个原因则是人性中的吃不得小亏的心理，具体分析见下节\",\"这种赚大钱的可能以及挣了大钱后对你的生活方式、虚荣心及权力的幻 想，是极其危险的\",\"你常常面对两个选择，即选择正确或选择赚钱，在股市，它们常常并不同步。\",\"句话，股市没有即定的运行准则\",\"这一方面是人性中亏不起的心态，另一方面是报复赌场，报复赌场让他们亏钱。\"]},\"112\":{\"h\":\"环境\"},\"113\":{\"h\":\"大环境\",\"t\":[\"1．利率\",\"2．税收\",\"3．汇率\",\"4．银根松紧\",\"5．经济周期\",\"6．通货膨胀\",\"7．政治环境\",\"8、政府的产业政策\"]},\"114\":{\"h\":\"小环境\",\"t\":[\"1．营业收入\",\"2．盈利\",\"3．固定资产\",\"4．类似公司的情况\",\"5．品牌的价值\",\"大环境的变化是谈天的好材料，用来炒股的实用性不大。大的政治动乱和经济震荡当然例外。\"]},\"115\":{\"h\":\"影响股票的三个因素\",\"t\":[\"1.盈利的增长\",\"2.新产品\",\"3.公司回购自己的股票\"]},\"116\":{\"h\":\"股票的走势及走势线\",\"t\":[\"在升势图中，请注意交易量的变化。在上升阶段，交易量增加，下调阶段，交易量减少。\",\"典型的跌势图\",\"在跌势时，交易量没有特别之处，但跌波的每个波峰较上一波峰为低，波谷也较上一波谷为低。\",\"无势图\",\"一只无势的股票通常不适合炒作。\",\"影响投资者决定的最重要因素是对未来的预期。\",\"股票的运动有点像推石球上山，要往上推，你要很大的力，但石球往下 滚，用不着很多力气。\",\"华尔街有过调查，使一般投资者入场买股票的原因最主要的就是因为股票在升！\",\"一般投资者入场买股票主要不是因为股票的成本收益比率低或红利高，而是因为股票在升！升！升！ 除了股票在升的理由之外，其它因素都是次要的。这就是为什么股票一开始升势，它往上一波高过一波，不会马上停止。要想学习养成对股票运动的感觉，你必须牢牢记住这一点。\",\"现在你能体会到为什么股票升时常常升得离谱，跌时跌到惨不忍睹的原因了吧？记住股民买卖股票的真正原因，耐心地观察市场，你很快就会发现股票运动是有迹可循的。\",\"2．支撑线和阻力线\",\"3．双肩图和头肩图\",\"4．平均线\",\"我自己习惯用200天平均线来衡量股票的长期走势，50天平均线来衡量中期走势。\",\"股票短期的运动方向我注重股价及交易量。\",\"我通常不买股价在200天平均线下的股票，做短线时例外\"]},\"117\":{\"h\":\"综合看图\",\"t\":[\"把图2-10倒过来，我们就有了最常见的买入理想点。记住如果这是升势开始的话，交易量通常增大\",\"支撑线和阻力线：一旦阻力线被突破，股票应该继续上升，虽然可能有反调，便反调不应该跌到阻力线之下，否则便是不正常运动。同样，一旦支撑线被突破，股票应往下跌，否则的话，便是不正常运动。如果股票一跌破支撑线便反弹到支撑线之上，可能是买股的好时机。\",\"以下我简单地解释经济周期怎样在股价上反映出来。这些知识能加深你对股市的认识（\",\"。必须强调，股市操纵可能改变每天的或短期的波动，但不可能改变大势。 道氏理论特点指出这一点\",\"马克思的政治经济学主要目的便是解决不断重复的资本广义经济周期对社会负面的影响。\",\"由于我自己以中短期炒作为主，技术分析是我买进卖出的主要参考。\",\"不要把技术分析孤立起来看。\",\"股票大市的重要性的：“炒股的诀窍便是在牛市中全力投入，在牛市结束或接近结束的时候卖掉你的所有股票。\",\"要确定大市的走向，最重要的是每天要追踪股票指数的运动\",\"留意每天的交易总量。如果股市交易总量很大，但指数不升，或开市走 高，收市低收盘，这就给你危险信号了\",\"判断大市走向是极其重要的\",\"炒股是概率的游戏，逆大潮流而动，你的获胜概率就被大打折扣了。\",\"，但一定要在心理上不断提醒自己：大市不好时，别买任何股票。\",\"综合指数有时会被几只大股票糊弄\",\"最流行的“现金值法”是怎么判断合理股价的。\",\"要得到股票的现金值需要2个假设。一个是通货膨胀，另一个是未来盈利\",\"我们生活在从工业社会转型到信息社会的关口。互联网公司属于信息社会的产业。\",\"现今流行的企业评估标尺如本利比、现金值、固定资产值等等是用来评估工业社会企业的，它取代了农业社会丈量土地的方法；但它用来评估信息社会的企业可能并不十分合适。\"]},\"118\":{\"h\":\"成功的要素\",\"t\":[\"么投机的原理是什么呢? 它的精华可以浓缩成两句话：(1)败而不倒(2)追求卓越。\",\"具体的做法就是分层下注\",\"把“保本”这个概念牢牢地记在心里，你在炒股时每次犯错，你的体会就会深一层，时间一久，你就知道该怎样做了。\",\"但我常听到炒股的人居然会为亏钱而自豪！这其实便是炒股艰难的地方。看不见、摸不着的股票使一般人的判断力走了样。\",\"在这里我要强调的是：只要股票运动正常，便必须按兵不动\",\"你如果有60%的胜算，下注的数额比你有80%的胜算时应该为少。至于你怎么知道有60%的胜算或80%的胜算，完全决定于你自己的经验。\",\"股票从来不是恒定不动的，它有时很活跃，有时很安静，要么上一下，要么下一点，在一固定的区间波动，一旦股票开始一个新的走势，它通常循着一条比较固定的路径运行。华尔街将这条线称为“最少阻力线”。\",\"如果读者觉得还很抽象的话，我以下用数字来描述一遍，因为掌握股票正常运动的特点对炒股成功是极其重要的。\",\"一只正常运动的股票，每次上冲的强度通常较上一次更为猛烈。\",\"炒股的最基本信条是在任何时候，你手上持有股票的上升潜力必须大过下跌的可能，否则你就不应留在手里。\",\"但炒友们必须牢牢记住：股市从来都不错，它总是走自己要走的路，会错的只有人自己\",\"华尔街曾经对一般的股民做过调查，其结果是惊人的：80%的股民入市并非以赚钱为主要目的\",\"欲望必须由努力做基础，否则只是白日梦，白日梦不是欲望是梦。\",\"这个世界充满聪明而失意的人，受过良好教育但成日感叹怀才不遇的人，……他们有个共性，缺少锲而不舍的精神\",\"它是在忍无可忍的时候，再忍下去的毅力！\",\"最痛苦的不是亏钱的数目，钱亏掉不可怕，可怕的是不知有无本事再赚回来\",\"成功的秘诀不外乎是“在忍无可忍的时候，再忍一忍”。\",\"一位成功的炒手必须如一位成功的商人，正确地预见未来的需求，适时进货，耐心地等待盈利的时刻。\",\"要甘于做孤独者\",\"但炒股需要不同的思维方式。\",\"反之如果大多数股民不看好股市，他们都已经脱手出场，那么股市的继续下跌区间也已不大。\",\"你如果随大流，则你将常常在高点入市，低点出市，你将成为失败者。\",\"当然，何为大多数股民看好大市或大多数股民不看好大市是很难计量的，你主要通过研究“股势”来得到答案。\",\"你从小学习的那些讨人喜欢的性格，如听话、合群、不标新立异等等都成为炒股成功的障碍。\",\"必须具有耐心和自制力\",\"你不把“苦工”当成习惯，你在这行成功的机会就不大。\",\"在正确的时间和环境做正确的事才有可能得到预想的效果。\",\"对业余炒手而言，往往不是没有耐心，也不是不知道危险，他们也知道春天是播种的时机，但问题是他们没有足够的知识和经验判定何时是春天\",\"大多数人注重于今天发生的一切并假设今天发生的一切会不断延续，但优秀的投资者会看得更远一步，预想在什么情况下今天的情形会停滞甚或产生逆转。\",\"成功的投资者绝不幻想\",\"按原来的预想，这只股票的运动不对，你会怎么办？一般人常常想像出各种理由把这一不正常的运动“合理化”。\",\"要有应用知识的毅力\",\"因为人们常常做不到自己知道该做的事情！\",\"在炒股问题上，我是坚信“知易行难”之说的。\"]},\"119\":{\"h\":\"\",\"t\":[\"买点的最最重要点是选择止损点。\",\"这个止损点不应超出投资额的20%。请读者切切牢记，否则这里讲的一切都是空的。\",\"买股票的依据主要是三点：基础分析、技术分析及大市走向。\",\"说到底，我差不多就等于在开赌场，每次入场时我的获胜概率都超过50%，而且我只下小注，所以我久赌必赢\",\"操作技巧\",\"假如这是一个正常的升势，A、B点分别是波峰和波谷。一旦股价超过A点，便是好的买入点。\",\"阻力线和支撑线的操作\",\"我自己的经验，最有用的概念是阻力线和支撑线，从心理上它们最容易解释，在实际中它们也最为有效\"]},\"120\":{\"h\":\"买入的要点归纳\",\"t\":[\"第一，在买入之前，一定要参照一下股票的走势图，因为它是大众投资心理的反映。\",\"第二，在买入之前，先定好止损点，搞清楚你最多愿亏多少钱。切记照 办。\",\"第三，选择临界点，记住你不可能每次正确，所以入场点的获胜概率应大过失败概率。\",\"第四，最好在升势或突破阻力线，准备开始升势的时候买入。\",\"第五，绝不要在跌势时入市。\",\"第六，不要把“股票已跌了很低了”作为买入的理由，你不知道它还会跌多少！\",\"第七，不要把“好消息”或“专家推荐”作为买的理由，特别在这些好消息公布之前，股票已升了一大截的情况下。\",\"第八，记住这些要点及点点照办。\",\"但有一点可以确定，短线操作的资金都是热钱，它不会长久留在某只股票上，除非大户真的认为该股有潜力。\",\"如果交易量没有增加，突破阻力线的现象并没有很大意义，请读者自己思考一下其中的原由\",\"只有在交易量增加的前提下，突破阻力线才可以认为股票的运动进入新的阶段。\",\"大户的花招其实明显的很。讲白了，他们想买进的股票要么静悄悄地，要么想法引起大众的恐慌性抛售，前者你会看到交易量增加，但不明显，股价慢慢地一步步升高，后者便是搞一些大家公认的好卖点\",\"想像你的对手是谁！如果是大户的话，你炒股大概常亏钱，如果是小股民的话，你大约已赢多过输。\",\"买股的时机固然重要，买什么股票有同样的分量。\"]},\"121\":{\"h\":\"选择股票的步骤\",\"t\":[\"第一，什么是大市的走向？如果大市不好，你最好什么都别买，安坐不 动。\",\"第二，哪些类别的股票“牛劲”最足？\",\"第三，当你判定股票大市属于“牛市”，选好“牛劲”最足的类别股后，余下的工作就是“牛劲”最足的股类中选择一两只“龙头”股\",\"第三点怎么办？在“牛劲”最足的类别股中，怎样找最有潜力的股票？\",\"形成自己的风格模式\",\"用你自己发现的临界点，按自己定好的规则买进卖出，训练自己的耐性，留意市场提供的危险信号，你就走上了学股的正确道路。\"]},\"122\":{\"h\":\"何时卖股票\",\"t\":[\"不要试图寻找股票的最高点，你永远不知股票会升多高。\",\"和买股票一样，卖股票的点也是“临界点”\",\"寻找临界点的过程便是你的学股过程\"]},\"123\":{\"h\":\"小结一下何时及怎样卖股票\",\"t\":[\"1．注意危险信号\",\"2．保本第一\",\"3．亏小钱\",\"只要条件允许，越小越好\",\"我自己喜欢把止损点定在入市当天的最低点。比如我今天以10.75元买进股票，今天的最高价是11元，最低价是10元，我便以10元作为止损点。以我的经验，如果我的入场点选的正确，股票开始上升，它不应跌回我当天入场的最低点。\",\"4．遇有暴利，拿了再说\",\"5．小心交易量猛增，股价却不升\",\"6．用移动止损点来卖股票\"]},\"124\":{\"h\":\"华尔街家训\",\"t\":[\"时刻牢记：市场从来不会错，而你的想法常常是错的。\",\"止损，止损，止损\",\"分散风险\",\"避免买太多股票\",\"将注意力集中在三至五只最有潜力的股票，随着经验的增加，逐渐将留意的股票增加到十至十五只。我自己的极限是二十只股票。\",\"有疑问的时候，离场\",\"忘掉你的入场价\",\"别频繁交易\",\"不要向下摊平\",\"不要向下摊也可用另一种说法：第一次入场后，纸面上没有利润的话不要加码。纸面有利润了，表示你第一次入场的判断正确，那么可以扩大战果，适当加注，否则即刻止损离场，另寻机会。\",\"就算进价较你第一次进价为低也没有关系。这样做的思想基础不是为了解套，而是你“知道”股票的升势还在继续。\",\"别让利润变成亏损\",\"跟着股市走，别跟朋友走！\",\"别将“股价很低了”当成买的理由，也别将“股价很高了”当成卖的理由！\",\"别爱上任何股票！\",\"要在投资领域成功，他相信以下的六点素质是必备的\",\"第一，你要有点贪念，但不能太多。\",\"第二，你必须有耐心\",\"第三，你必须独立思考\",\"第四，你必须有自信\",\"第五，不要不懂装懂，要有自知之明。\",\"第六，对投资的对象可以有弹性\",\"他列出下面几点作为选择公司的参考。\",\"：一，我们的投资将基于股票的价值而不是股票是否热门；二，我们的管理将尽量使损失降至最低（有别于股价的短期波动）。\",\"一位成功投资者的重要素质之一便是市场情况不允许时，离开市场。\",\"第一，不要第一次就入市太深，从小开始，如果进展顺利，再加码。\",\"第二，市场是愚蠢的，你也非不着太聪明。\",\"索罗斯建议投资研究越简化越好。他自己从不在经济研究上花大量的时间，不读华尔街证券行的研究报告。\",\"。索罗斯认为这一理论根本就是错的。\",\"他自己提出了“反馈理论”（theory of reflexivity）。这个理论的简单解释便是：想法改变了事件，事件的改变又反过来改变想法。\",\"我对所有的炒股规则都抱有怀疑，所以很不愿意多谈。但就我的亲身经历，以下的几点或许能帮助你自律：\",\"1．除非你能将炒股当成全时工作，否则别冒险\",\"2．对任何给你‘内幕消息’的人士，无论是理发师、美容师还是餐馆跑 堂，都要小心\",\"3．在你买股票之前，找出公司的所有资料，它的管理层、竞争者，它的盈利及增长的可能性。\",\"4．别试着在最低点买股、最高点卖股，这是不可能的，除非你撒谎。\",\"5．学习快速干净地止损。别希望自己每次都正确。如果犯了错，越快止损越好。\",\"6．别买太多股票，最好只买九只股票，以保证你能够仔细地观察它们。\",\"7．定期有计划地检查你的投资，看看有什么新的发展可能改变你的想法。\",\"8．研究税务情况，在卖股时争取最大的税务效益\",\"9．永远持有一部分现金，不要将钱全部投入股市\",\"10．不要尝试成为万事通，专心于你了解最多的行业。\",\"大钱不存在于股票的日常小波动，大钱只存在大势之内。因此你需要判定大势的走向\",\"我赚到大钱的诀窍不在于我怎么思考，而在于我能安坐不动，坐着不动！\",\"我只在升势的时候买股票，此时我才觉得舒服。我每多进一手都一定较上一手的价格更高。\",\"记住，股票从来就没有太高了不能买或太低了不能卖这回事，但进场 后，如果第一手没给你利润，别进第二手。\",\"所有的专业炒手都不在乎赚钱或亏钱，他们在乎在正确时间做正确的事。他们知道利润会随之而来\",\"1．确定你对炒手生涯感兴趣\",\"2．检查你买卖的动机\",\"3．你的交易方式必须和你的个性相符合\",\"4．你必须有“胜算”\",\"5．找一个方法\",\"6．好的交易方法应毫不费力\",\"7．风险控制\",\"8．自律\",\"9．独立思维和自信\",\"10．亏损是游戏的一部分\",\"11．耐心\",\"12．该出手时就出手\",\"13．发现压力的根源，解除压力\",\"14．尊重自己的直觉\",\"15．价格的变动不是随机的，你能战胜市场\"]},\"125\":{\"h\":\"\",\"t\":[\"第一，获得炒股的基本知识； 第二，制定切实可行的炒股计划； 第三，严格按照这个计划实行。\",\"你对“未随大流”的恐惧和失去“赚大钱”机会的贪婪常使你在股票的最高点入股。\",\"无论得到什么，得到多少，你总会编出理由来证明你应该得到更多\",\"一旦怀抱“希望”，你每天都在寻找对你有利的信息，忽略对你不利的信息。\",\"成功的投资必须基于对今天和未来所发生的事件对股价的可能影响做理性判断，“希望”在这个判断过程中不应占有任何地位。\",\"什么是正确的心态？\",\"这些正确的心态至少包括以下几方面：\",\"1．你要相信自己\",\"2．诚实地面对自己，评价自己\",\"3．独立的判断能力\",\"4．自我督促\",\"5．改变的能力\",\"6．热爱你选择的行业\",\"所见到的大多是玩股的，把炒股当成业余消遣，这些人永远都达不到专业的层次。\",\"在本书的最后一章“和炒手们谈谈天”里我会较为详细地谈谈学股经历的几个过程。从什么都不懂到有信心不断地从股市赚到钱，我也用了近六年的时间，那还不算我业余炒股的经验及金融硕士的知识背景。所以，你要准备“长期抗战”。\"]},\"126\":{\"h\":\"\",\"t\":[\"当年也不是没有头脑清醒的人，但他们太早了一步，他们指出这个泡沫会破碎，但市场用不断升高证明他们论断的错误。开始还有人听听他们的警钟，随后便嘲笑他们的短视。骗案层出不穷是所有“疯”到了晚期的特征之一\",\"所有的疯狂都有梦醒时分。\",\"气球吹胀的初期，气球后面一定有一动人的故事，提供给人们无穷的想像。发财的希望，促使投资大众开始投入\",\"每一个更高的波浪都带动更多的贪婪心理，吸引更多的股民加入。股票将节节升高，这就形成了所谓的升势。\",\"“疯”的特性\",\"1．可信的想法、概念或产品，能提供快速的增长，带来巨额的财富\",\"2．社会游资甚多，或通过某些方式“创造”出游资。一时这些资金集中在某个领域，必定带来滚雪球效应\",\"3．这个想法必须具备即简单又复杂的特性。简单到普通民众能“觉”得是好主意，但必须复杂到很难用事实证明其对错。否则气球吹不起来。\",\"4．有人赚到钱！没有什么比轻松和快速来钱更能吸引普通民众，它传染的速度远超过瘟疫。\",\"5．气球胀到一定地步，有“专家”背书：这气球会继续胀。这些“专 家”通常是偶像人物，代表智慧、权威、依赖。民众相信自己在模仿成功人士。\",\"6．气球胀的时间比常人想像得更久。最初指出气球会破的人随着气球的不断胀大而被嘲笑。\",\"经济史是一部基于假象和谎言的连续剧，经济史的演绎从不基于真实的剧本，但它铺平了累积巨额财富的道路。做法就是认清其假象，投入其中，在假象被公众认识之前退出游戏。\"]},\"127\":{\"h\":\"炒手访谈\",\"t\":[\"你做什么都可以，只要你自己喜欢！但我希望你能有一个不求人的一技之长。”\",\"体验风险阶段\",\"我每次赚了大钱，随即常常来一次亏大钱，因为每次赚了大钱，都让我自己觉得自己”懂了”\",\"任何有输的可能的行为都是赌。把钱存银行不是赌，因为一定有利息。可炒股就是赌钱，两者没有区别。\"]},\"128\":{\"h\":\"\",\"t\":[\"成功不是达到目的，应该是达到这一目的的过程。\",\"你可能较其它行的从业者富有，但成为富豪在天不在人\",\"别想着在股市赚钱\",\"别将股市当成是赚钱的地方，将它当成是娱乐场所，当成小赌怡情、陶冶性情的场所；这样你就可以据此制定一系列游戏规则，按这些游戏规则，你将以最少的代价得到最多的乐趣。\",\"一、多玩几种游戏，将玩的费用分散些！\",\"二、开心的游戏玩久些，不开心的游戏便快些离开！\",\"三、别把痛苦带回家！\",\"华尔街有个说法：第一损失往往是代价最小的损失。\"]},\"129\":{\"h\":\"\",\"t\":[\"正常”或“不正常”涉及一个很重要的数学概念：概率！想在股市谋生，每次买卖都要有50％以上的胜率，任何持有的股票都应有超过50％的上升几率，否则你无法从股市长久赚到钱。有了判断“正常”或“不正常”的能力，你在股市就有了50％以上的胜率，你就有了生存的可能。想有这样的判断力，除了熬和交学费外，似乎还没有什么其他方法——而最重要的是熬！\",\"小小做，快快止损\",\"为自己立些规矩，按规矩做，你会成功的\"]},\"130\":{\"c\":[\"使用指南\"]},\"131\":{\"c\":[\"炒股的智慧\",\"读书笔记\"]},\"132\":{\"h\":\"SOME/IP Service Discovery 原理与工程实践\"},\"133\":{\"h\":\"一、什么是 SOME/IP SD？\",\"t\":[\"SOME/IP SD (Service Discovery) 是 AUTOSAR 定义的一种基于 IP 网络的服务发现协议，是 SOME/IP 协议族的重要组成部分。\",\"它的目标是：\",\"让软件组件 SWC 在不预知对方 IP/端口的情况下，能够在运行时动态发现服务并实现通信绑定。\"]},\"134\":{\"h\":\"📦 SD 解决了什么？\",\"t\":[\"动态获取服务的地址和端口\",\"接收服务状态改变通知（提供中 / 未提供）\",\"支持 Client 主动搜索服务 (FindService)\",\"支持 Provider 先行广播服务 (OfferService)\",\"支持事件组订阅与 TTL 保活机制\"]},\"135\":{\"h\":\"🔗 应用场景\",\"t\":[\"ECU 动态上线 / 下线切换\",\"多 Client 相互竞争服务实例\",\"路由 / 软件控制器 / ADAS 实时组织\",\"TTL 控制通信生命周期\"]},\"136\":{\"h\":\"🧠 核心特性\",\"t\":[\"功能\",\"说明\",\"服务发现\",\"FindService / OfferService\",\"订阅组织\",\"SubscribeEventGroup / ACK\",\"基于 UDP\",\"使用组播和点播\",\"ECU 通用\",\"IP + 服务性架构\",\"RTE 系接\",\"RTE 调用自动调用 SD\"]},\"137\":{\"h\":\"🗺 工作流程简图\",\"t\":[\"Provider: OfferService → 广播服务 Client : FindService → 搜索服务 Provider: OfferService → 响应 Client : Subscribe → 订阅事件 Provider: ACK + Data → 确认 + 常规推送\"]},\"138\":{\"h\":\"💬 一句话总结\",\"t\":[\"“SOME/IP SD 是软件服务分布和动态绑定的基础，使 Client 无需预置 IP 也能自动联系服务。”\"]},\"139\":{\"h\":\"二、协议格式 & 组成\",\"t\":[\"SOME/IP SD 使用 UDP 30490 端口，消息结构：\",\"+--------------------+ | SOME/IP Header | | Protocol ID = 0xFFFF +--------------------+ | SD Header | | Entries[] | | Options[] | +--------------------+\",\"Entry：表达动作意图 (Offer, Find, Subscribe)\",\"Option：配置结构 (IP, Port, TTL, Config)\"]},\"140\":{\"h\":\"三、正常通信流程\",\"t\":[\"[Provider] → OfferService (multi-cast) [Client] → FindService (multi-cast) [Provider] → OfferService (response) [Client] → SubscribeEventGroup (uni-cast) [Provider] → ACK + push event periodically\"]},\"141\":{\"h\":\"⏱ Provider 与 Client 的交互时序图（文字示意）\",\"t\":[\"Provider Client | | |---OfferService->| (多播) | | |<--FindService---| (多播) |---OfferService->| (回应) |<--Subscribe------| (点播订阅) |---ACK----------->| (确认) |=== 事件推送周期性发送 ===>\"]},\"142\":{\"h\":\"四、Provider 与 Consumer 状态机模型\"},\"143\":{\"h\":\"✅ Provider 状态机结构图\",\"t\":[\"alt text\",\"该图展示了 Provider 所经历的 4 个典型状态：\",\"Not Ready\",\"Initial Wait Phase\",\"Repetition Phase\",\"Main Phase（AVAILABLE）\",\"每个状态通过定时器或接收报文事件进行转换，OfferService 报文会在不同阶段以不同频率发送。\"]},\"144\":{\"h\":\"✅ Consumer（Client）状态机结构图\",\"t\":[\"alt text\",\"Client 状态机结构较复杂，包含服务未见、搜索中、已见、订阅中、已订阅、停止等状态，核心转换基于：\",\"是否收到 OfferService\",\"TTL 是否过期\",\"是否完成订阅/取消订阅行为\",\"这些状态图清晰呈现了 AUTOSAR SOME/IP SD 协议在实际运行中的时序机制与控制逻辑。\"]},\"145\":{\"h\":\"✅ Provider 状态机\",\"t\":[\"状态\",\"描述\",\"DOWN\",\"服务未初始化或未就绪\",\"INITIAL_WAIT\",\"等待广播窗口开始\",\"REPETITION\",\"重复广播 OfferService\",\"AVAILABLE\",\"开始接受订阅请求，定期推送事件\"]},\"146\":{\"h\":\"✅ Consumer（Client）状态机\",\"t\":[\"状态\",\"描述\",\"INIT\",\"启动后准备寻找服务\",\"WAIT_FOR_OFFER\",\"已发送 FindService，等待回应\",\"SUBSCRIBED\",\"成功订阅事件组，处于活跃状态\",\"REFRESH\",\"正在续订以保持 TTL 不失效\",\"工具如 Wireshark 抓包可见每次状态跳转时对应的 SD 报文（Entry 类型 + Option 地址）\"]},\"147\":{\"h\":\"五、实际 SubscribeEventGroup 抽象\",\"t\":[\"字段\",\"示例\",\"含义\",\"Service ID\",\"0x1234\",\"服务唯一标识\",\"Instance ID\",\"0x0001\",\"服务实例 ID\",\"EventGroup ID\",\"0x8001\",\"要订阅的事件组\",\"TTL\",\"5s\",\"订阅有效期\",\"Endpoint\",\"192.168.0.10:30500\",\"接收推送的地址\"]},\"148\":{\"h\":\"六、协议细节 & 行为解析\"},\"149\":{\"h\":\"📑 SD 报文类型概览（AUTOSAR 官方定义）\",\"t\":[\"根据 AUTOSAR SD 规范文档中的 Table 5.2，Entry 的语义由 EntryType 字段和 TTL 字段共同决定。下表是官方支持的报文类型组合：\",\"EntryType\",\"十六进制\",\"TTL > 0 （正常行为）\",\"TTL = 0 （终止行为）\",\"0\",\"0x00\",\"FindService\",\"✖️（不支持 TTL=0）\",\"1\",\"0x01\",\"OfferService\",\"StopOfferService\",\"2\",\"0x02\",\"SubscribeEventGroup\",\"StopSubscribeEventGroup\",\"3\",\"0x03\",\"SubscribeEventGroupAck\",\"SubscribeEventGroupNack\",\"📌 注：TTL = 0 仅在 EntryType ≠ 0x00 的情况下有效，用于表示“释放”或“拒绝”类行为。FindService 是 Client 主动查找服务的行为，其 TTL 字段始终无效。\",\"该表定义了 SD 报文在实际通信中支持的行为类型，是理解服务提供/发现/订阅/释放等动作的根本依据。\",\"SOME/IP SD 报文中的行为由 EntryType 和 TTL 联合决定，标准定义如下：\",\"TTL 条件\",\"EntryType (十六进制)\",\"报文类型\",\"描述\",\"TTL > 0\",\"0x00\",\"FindService\",\"Client 查找服务\",\"TTL > 0\",\"0x01\",\"OfferService\",\"Provider 提供服务\",\"TTL > 0\",\"0x02\",\"SubscribeEventGroup\",\"Client 请求订阅事件组\",\"TTL > 0\",\"0x03\",\"SubscribeEventGroupAck\",\"Provider 确认接受订阅\",\"TTL = 0\",\"0x01\",\"StopOfferService\",\"Provider 停止提供服务\",\"TTL = 0\",\"0x02\",\"StopSubscribeEventGroup\",\"Client 取消事件组订阅\",\"TTL = 0\",\"0x03\",\"SubscribeEventGroupNack\",\"Provider 拒绝订阅请求\",\"📌 注意：EntryType 为 0x00（FindService）报文在 TTL = 0 时无效，FindService 本身无 TTL 字段。\"]},\"150\":{\"h\":\"🧹 服务释放机制（Unsubscribe / Stop Offer）\",\"t\":[\"SOME/IP SD 协议通过以下两种方式完成服务释放或断开订阅：\"]},\"151\":{\"h\":\"✅ 1. Provider 停止提供服务\",\"t\":[\"Provider 可以通过发送 StopOfferService Entry（即将 TTL 设置为 0 的 Offer）告知所有 Client 服务下线；\",\"之后，Provider 进入 DOWN 状态，不再接受订阅，也不再发送事件。\"]},\"152\":{\"h\":\"✅ 2. Client 主动取消订阅\",\"t\":[\"Client 可以发送一个带 TTL = 0 的 SubscribeEventGroup 报文，表示取消订阅；\",\"Provider 接收后应停止向该 Client 推送事件。\",\"📌 这两个机制可用于系统下电、网络退出或软件模块重启时的服务注销，保持网络资源清洁。\"]},\"153\":{\"h\":\"🔁 OfferService 报文的发送时机\",\"t\":[\"即使 Client 已完成订阅，Provider 仍会继续发送 OfferService 报文，但发送频率随状态机阶段变化：\",\"在 REPETITION 状态：Provider 会在启动阶段快速多次发送 Offer，用于确保所有潜在 Client 能收到服务信息；\",\"在 AVAILABLE 状态：Provider 以较长周期（通常每 5 秒或更长）继续广播 OfferService，用于支持新加入网络的 Client完成绑定；\",\"Provider 并不会因为某个 Client 已订阅而停止 Offer，它是“面向所有潜在 Client”的广播机制。\"]},\"154\":{\"h\":\"🔍 Client 的 FindService 触发时机\",\"t\":[\"Client 启动后进入 INIT 状态，会立即发送 FindService 报文，主动寻找目标服务；\",\"若在一定时间内未收到 Provider 的 Offer（即超时），Client 会周期性重发 FindService，直到收到有效 Offer；\",\"一旦 Client 完成了订阅并进入 SUBSCRIBED 状态，按照标准规范，它将不再发送 FindService 报文，而是通过定期重新 Subscribe 来维持服务绑定。\",\"📌 所以：FindService 是 Client 在发现阶段使用的唯一探测方式，完成订阅后其功能由订阅续期机制替代。\",\"TTL 表示订阅有效时长 (sec)\",\"Client 必须在 TTL 到期前重新 Subscribe\",\"Provider 如未收到续订，则退出推送\"]},\"155\":{\"h\":\"七、实战故障排查\",\"t\":[\"环节\",\"问题\",\"Subscribe 失败\",\"TTL = 0 ／ Option 配置错误\",\"未收接事件\",\"Provider 未处于 Main Phase（未启用周期推送）或未正确触发事件发送逻辑\",\"ACK 遗失\",\"端口错误 ／ IP 错误\",\"Wireshark 抓包\",\"udp.port == 30490 筛选\"]},\"156\":{\"h\":\"八、与 AUTOSAR RTE 组成\",\"t\":[\"通常配置于 .arxml 中，并由 RTE 生成 API：\",\"Application SWC ↓ RTE SOME/IP Adapter ↓ SOME/IP + SD Stack (UDP/IP)\"]},\"157\":{\"h\":\"九、结论\",\"t\":[\"组件\",\"角色\",\"SD 协议\",\"服务发现 / 绑定机制\",\"Entry\",\"操作意图（Offer / Find / Sub…）\",\"Option\",\"网络参数 (IP / TTL / Port)\",\"TTL 机制\",\"维持订阅有效性\",\"Provider\",\"提供服务，推送事件\",\"Client\",\"订阅服务，解析回复\"]},\"158\":{\"h\":\"github代理配置指南\",\"t\":[\"本文主要介绍github system、global、local三个级别的代理配置及优先级\"]},\"159\":{\"h\":\"指令介绍\"},\"160\":{\"h\":\"设置代理\",\"t\":[\"git config --global http.proxy http://127.0.0.1:[Port] git config --global https.proxy https://127.0.0.1:1080:[Port]\"]},\"161\":{\"h\":\"取消代理\",\"t\":[\"git config --global --unset http.proxy git config --global --unset https.proxy\",\"提示\",\"[Port]替换为你本地代理的端口 --global 可替换为--system、--local\"]},\"162\":{\"h\":\"生效优先级\",\"t\":[\"system级指的是程序级别的配置，配置文件在程序的配置目录中 global级是用户级别的配置，配置文件在用户目录中 local级是仓库级别的配置，配置文件在仓库下的.git目录中\",\"提示\",\"优先级：local > global > system\"]},\"163\":{\"h\":\"案例\",\"t\":[\"在一个git脚本中当执行取消代理指令\",\"Alt text\",\"遇到报错\",\"Alt text\",\"通过执行代理查看指令\",\"git config --global --get http.proxy git config --global --get https.proxy\",\"发现global级别配置了代理地址，取消global级别的代理配置后，问题解决\"]},\"164\":{\"c\":[\"使用指南\"]},\"165\":{\"c\":[\"github\",\"使用指南\"]},\"166\":{\"h\":\"C/C++语法报错集合汇总\",\"t\":[\"本文主要汇总C/C++语法报错问题\"]},\"167\":{\"h\":\"在C++类中vector声明，报错 “expected parameter declarator”\",\"t\":[\"class A{ private: vector<int> nums(5); };\",\"错误原因是：编译器无法区分该语句是成员变量声明还是成员函数声明。\"]},\"168\":{\"c\":[\"编程语言\"]},\"169\":{\"c\":[\"C\",\"C++\",\"报错\"]},\"170\":{\"h\":\"C++中两种字符串拼接的区别\",\"t\":[\"本文探讨C++中 s = s + 'A' 和 s += 'A' 的区别\"]},\"171\":{\"h\":\"原理\",\"t\":[\"在C++中，当你执行s = s + 'A'时，实际上是创建了一个新的字符串。这是因为C++中字符串的+运算符被重载以连接字符串，其结果是一个新的字符串。\",\"另一方面，当你执行s += 'A'时，这是一种原地操作，它通过将字符'A'附加到现有字符串s上来修改现有字符串。字符串的+=运算符被设计为修改现有字符串对象，而不是创建新的对象。\",\"从效率的角度来看，s += 'A'可能比s = s + 'A'更高效，因为它有可能避免创建新的字符串对象，直接修改现有对象。\",\"简而言之：\",\"s = s + 'A'：通过将现有字符串s和字符'A'连接起来创建一个新的字符串对象，然后将这个新字符串赋给s。\",\"s += 'A'：通过将字符'A'附加到现有字符串s上来修改现有字符串。\",\"一般来说，如果你不需要保留原始字符串，使用+=可能更高效，因为它修改现有对象。然而，如果你想保留原始字符串不变，应该使用s = s + 'A'。\"]},\"172\":{\"h\":\"案例\",\"t\":[\"参考链接：\"]},\"173\":{\"c\":[\"编程语言\"]},\"174\":{\"c\":[\"C++\",\"+字符串拼接\"]},\"175\":{\"h\":\"C语言extern关键字作用分析\",\"t\":[\"本文主要介绍C语言中extern的作用分析\"]},\"176\":{\"h\":\"前提\",\"t\":[\"首先理解声明和定义：\",\"声明是告诉编译器有一个这样的变量或函数存在，定义是为变量分配内存空间或者实现函数本体(body)\",\"提示\",\"在c语言中声明和定义一个变量是同时进行的，但extern仅用于声明\"]},\"177\":{\"h\":\"extern作用\",\"t\":[\"在C语言中，关键字extern用于声明一个变量或函数，以便告诉编译器它们的存在，但并不会分配实际的存储空间。具体来说，extern的作用有以下几点：\",\"变量声明：当extern用于变量声明时，它告诉编译器该变量在其他文件中已经定义，因此在当前文件中不需要为其分配存储空间。这样做可以避免重复定义变量，而只是声明它的存在。\",\"// 在一个文件中声明变量 extern int x;\",\"函数声明：类似地，extern也可以用于函数声明，以便告诉编译器该函数在其他文件中已经定义。\",\"// 声明函数的存在 extern void someFunction();\",\"全局变量：在全局范围内使用extern可以使变量在当前文件中具有全局作用域，但实际的定义在其他文件中。这在大型项目中很有用，因为它允许多个文件共享相同的全局变量。\",\"// 在一个文件中使用 extern 声明全局变量 extern int globalVariable;\",\"总之，extern关键字用于声明变量或函数的存在，但不会分配实际的存储空间。这使得程序可以跨多个文件共享变量和函数，同时避免了重复定义的问题。\"]},\"178\":{\"h\":\"案例： 使用extern模拟面向对象编程\",\"t\":[\"在C语言中，使用extern关键字可以实现一定程度的面向对象编程。下面是一个详细的例子，展示了如何使用extern来模拟类和对象的概念。\",\"首先，我们创建一个头文件myclass.h，其中定义了一个类MyClass和相关的方法和属性：\",\"// myclass.h #ifndef MYCLASS_H #define MYCLASS_H typedef struct { int data; void (*printData)(); } MyClass; extern MyClass myObject; void MyClass_init(); void MyClass_printData(); #endif\",\"然后，我们创建一个源文件myclass.c，实现了类的初始化和打印数据的方法：\",\"// myclass.c #include <stdio.h> #include \\\"myclass.h\\\" MyClass myObject; void MyClass_init() { myObject.data = 2023; myObject.printData = MyClass_printData; } void MyClass_printData() { printf(\\\"Data: %d\\\\\\\\n\\\", myObject.data); }\",\"接下来，我们创建一个主文件main.c，在其中使用类和对象：\",\"// main.c #include \\\"myclass.h\\\" extern MyClass myObject; int main() { MyClass_init(); myObject.printData(); return 0; }\",\"运行结果\",\"运行结果图\",\"在这个例子中，我们使用extern关键字在main.c中引用了在myclass.c中定义的myObject对象。通过调用MyClass_init()方法初始化对象，并通过myObject.printData()调用对象的方法。\",\"编译这些文件并运行程序，你将看到输出结果为Data: 2023，表示成功使用extern实现了面向对象编程的模拟。\",\"需要注意的是，虽然使用extern可以模拟类和对象的概念，但C语言本身并不直接支持面向对象编程。这只是一种基于C语言的技巧或模式来实现一些面向对象的思想。\",\"参考链接：Difference between Definition and Declaration - GeeksforGeeks\"]},\"179\":{\"c\":[\"编程语言\"]},\"180\":{\"c\":[\"C语言\",\"extern\"]},\"181\":{\"h\":\"深入 GCC 优化原理：原理分析与实战最佳实践\",\"t\":[\"在嵌入式开发与高性能计算领域，代码的运行效率往往比语言特性更关键。本文将深入剖析 GCC（GNU Compiler Collection）编译优化的核心原理，结合实际示例，探讨其优化等级对性能的影响，并总结一套实用的优化实践指南。\"]},\"182\":{\"h\":\"一、GCC 优化等级概览\",\"t\":[\"GCC 提供多个优化等级，用于平衡性能、编译时间与可调试性：\",\"优化等级\",\"含义与特点\",\"-O0\",\"默认关闭所有优化，保留源代码语义，便于调试\",\"-O1\",\"启用基本优化，不显著影响编译时间\",\"-O2\",\"推荐等级：平衡性能和编译速度，包含大多数通用优化\",\"-O3\",\"启用激进优化，如循环展开和函数内联\",\"-Os\",\"针对体积优化，适用于嵌入式系统\",\"-Ofast\",\"包含 -O3 并启用一些违反标准的优化（如 -ffast-math）\"]},\"183\":{\"h\":\"二、GCC 优化原理深入解析\",\"t\":[\"GCC 优化大致分为三个阶段：前端优化、中间代码优化和后端生成优化。其原理包括：\"]},\"184\":{\"h\":\"1. 前端优化（源代码层面）\",\"t\":[\"常量折叠：编译期将常量表达式计算完成\",\"死代码删除：移除永远不会执行的代码\"]},\"185\":{\"h\":\"2. 中间代码优化（GIMPLE / SSA）\",\"t\":[\"公共子表达式消除（CSE）\",\"循环不变量外提（LICM）\",\"强度削弱：如 x * 2 替换为 x + x\",\"自动向量化（需 -ftree-vectorize）：将标量操作改为 SIMD 指令\"]},\"186\":{\"h\":\"3. 后端优化（RTL）\",\"t\":[\"寄存器分配：通过图着色算法分配物理寄存器\",\"指令调度：重排指令以避免流水线冲突\",\"循环展开：减少分支判断频率，提高并行度\",\"目标架构优化：启用如 -march=native 的平台专属优化\"]},\"187\":{\"h\":\"三、示例实战分析：数组求和优化对比\",\"t\":[\"以一段简单的 C 语言程序为例，观察在不同优化等级下的性能变化：\",\"int sum(int *arr, int size) { int s = 0; for (int i = 0; i < size; i++) { s += arr[i]; } return s; }\",\"在一台 x86_64 架构主机上，我们对该代码进行不同等级的编译并测试运行时间，结果如下：\",\"优化等级\",\"执行时间（处理 1 亿元素）\",\"相对性能提升\",\"-O0\",\"0.41 秒\",\"基线\",\"-O2\",\"0.06 秒\",\"🚀 提升约 6.8 倍\",\"-O3\",\"0.06 秒\",\"与 -O2 持平\",\"-Ofast\",\"0.07 秒\",\"与 -O3 接近\"]},\"188\":{\"h\":\"🔬 汇编分析亮点\",\"t\":[\"-O0：所有变量存栈，内存访问频繁，执行慢\",\"-O2：变量使用寄存器，循环被优化，内联函数展开\",\"-O3：加入循环展开，适用于复杂逻辑但对本例提升有限\",\"-Ofast：启用非标准浮点优化，未显著提升整数性能\"]},\"189\":{\"h\":\"四、最佳实践总结\",\"t\":[\"实战建议\",\"原因与说明\",\"✅ 使用 -O2 作为默认优化等级\",\"性能与稳定性的最佳平衡点\",\"🔍 使用 -O3 对性能关键路径\",\"需验证代码尺寸与副作用\",\"📦 嵌入式场景采用 -Os\",\"在资源受限设备上优化体积\",\"⚡ 加入 -march=native\",\"根据当前 CPU 自动启用高级指令集（如 AVX2）\",\"📊 启用 PGO (-fprofile-generate/use)\",\"基于真实运行数据进行反馈优化\",\"📈 使用 perf, gprof, valgrind 等工具分析瓶颈\",\"实现更细粒度的调优\"]},\"190\":{\"h\":\"五、进一步探索方向\",\"t\":[\"向量化优化与 AVX 指令分析\",\"内联汇编与手动 SIMD 实现\",\"GCC 插件与 __attribute__((optimize)) 局部优化控制\",\"与 Clang/LLVM 编译器的优化能力对比\"]},\"191\":{\"h\":\"结语\",\"t\":[\"在现代编译器的加持下，代码优化的方式多种多样。GCC 的多层次优化机制不仅提升了程序性能，也让C语言在高性能计算、嵌入式开发中继续焕发活力。理解并善用这些优化手段，是每位系统级开发者的必修课。\",\"✨ 星光不问赶路人，优化之路永无止境。愿你也能用最小的代码跑出最极致的性能。\"]},\"192\":{\"h\":\"C语言sizeof宏分析\",\"t\":[\"本文主要介绍C语言中sizeof的原理分析\"]},\"193\":{\"h\":\"原理\",\"t\":[\"sizeof 是 C 语言的一个运算符，用于返回一个对象或数据类型的大小，以字节为单位。sizeof 运算符在编译时计算，不会执行实际的运算。\",\"由于 sizeof 是编译时计算大小的，其实现是由编译器提供的，而不是由标准 C 库提供的函数。因此，sizeof 的实现通常依赖于编译器和目标体系结构。\"]},\"194\":{\"h\":\"实现方式\",\"t\":[\"以下是 sizeof 运算符的一种可能的简化实现，假设一个字节等于 8 比特：\",\"test.c文件\",\"#define SIZEOF(type) ((size_t)(&((type*)0)[1])) // 示例用法 int main() { size_t size = SIZEOF(int); return 0; }\",\"这个宏的工作原理是，将一个空指针转换为类型 type*，然后取数组的第一个元素的地址。由于数组索引是从零开始的，&((type*)0)[1] 计算出第一个元素之后的地址。然后，整个表达式被强制转换为 size_t 类型，以表示大小。\",\"需要注意的是，这只是一个简化的例子，实际的实现可能更为复杂，以处理各种类型和体系结构。实际的 sizeof 实现通常是由编译器内部提供的，因为它需要考虑各种编译器和目标平台的特定细节。\"]},\"195\":{\"h\":\"代码分析\",\"t\":[\"(size_t)(&((type*)0)[1]) 的运算顺序可以分解为以下步骤：\",\"(type*)0: 将整数 0 转换为指向类型 type 的指针，得到一个指向类型 type 的空指针。\",\"((type*)0)[1]: 使用上一步得到的空指针进行数组操作，取得数组的第二个元素。这等效于 ( ((type*)0) + 1)。请注意，这里并没有实际的数组，只是利用了指针运算的语法。\",\"&((type*)0)[1]: 取得数组第二个元素的地址。\",\"(size_t)(&((type*)0)[1]): 将这个地址转换为 size_t 类型。\",\"整个表达式的目的是计算一个指向类型 type 的指针，指向一个虚构的数组的第二个元素，然后获取这个元素的地址，并将其转换为 size_t 类型。这种技巧通常用于计算结构体或数组的大小，而无需创建实际的实例。\",\"通过将test.c文件编译成汇编文件可发现：\",\"SIZEOF(int) 对应汇编文件中的 movq $4, -8(%rbp)，将值 4 存储在相对于 %rbp 偏移为 -8 的位置。\",\"SIZEOF(double) 对应汇编文件中的movq $8, -8(%rbp)，将值 8 存储在相对于 %rbp 偏移为 -8 的位置。\",\"可见将整数 0 转换为指向类型 type 的指针，得到一个指向类型 type 的空指针时type[0]的地址为0，((type*)0)[1]的偏移量即为type的字节大小，从而可获取type的字节大小\"]},\"196\":{\"c\":[\"编程语言\"]},\"197\":{\"c\":[\"C语言\",\"siezof\"]},\"198\":{\"h\":\"为什么程序栈地址是向下增长的？\",\"t\":[\"💡 本文从体系结构、内存布局、寄存器设计、调试回溯角度全面分析“栈向下增长”的合理性。\"]},\"199\":{\"h\":\"一、什么是“栈向下增长”？\",\"t\":[\"现代计算机中，内存地址从低到高排列：\",\" 0x00000000 → 低地址 ... 0xFFFFFFFF → 高地址\",\"所谓**“栈向下增长”，指的是栈顶指针（如 x86_64 的 %rsp）在每次 push 或局部变量分配时向低地址方向移动**，从而使新的数据被压入更低的地址：\",\"push %rbx ; %rsp -= 8，数据压入低地址\"]},\"200\":{\"h\":\"二、进程内存布局：栈在什么位置？\",\"t\":[\"以下是典型的 Linux 进程虚拟内存布局：\",\"高地址 ↑ +------------------------+ ← 栈 Stack（向下增长） | 局部变量、返回地址等 | +------------------------+ | 空闲区 | +------------------------+ | 堆 Heap（向上增长） | +------------------------+ | .bss / .data / .text | +------------------------+ ← 低地址\",\"✅ 栈与堆背靠背扩展，是现代进程最灵活的内存布局方式。\"]},\"201\":{\"h\":\"三、为什么程序栈向下增长？\"},\"202\":{\"h\":\"✅ 1. 与堆对称增长，避免冲突\",\"t\":[\"堆区从低地址向上扩展（如 malloc）。\",\"栈从高地址向下扩展，两者互不干扰。\",\"如果中间空间不足，可检测“栈溢出”或“堆撞栈”。\"]},\"203\":{\"h\":\"✅ 2. 地址计算自然，负偏移更高效\",\"t\":[\"以 C 函数为例：\",\"void func() { int x = 1; int y = 2; }\",\"栈帧如下（向下增长）：\",\"[rbp] ← 保存的旧帧地址 [rbp-4] ← y [rbp-8] ← x\",\"汇编：\",\"movl $1, -8(%rbp) movl $2, -4(%rbp)\",\"📌 编译器只需不断“向下分配”变量偏移，非常简单。\",\"❗ 若是“向上增长”，则需要不断维护最大正偏移，还要避免覆盖参数区，增加管理复杂度。\"]},\"204\":{\"h\":\"✅ 3. 页式管理高效，防溢出安全\",\"t\":[\"栈的“底部”通常由操作系统加一页保护区（guard page），用于防止无限栈增长。\",\"向下增长的设计使得每次扩展栈只需申请“更低地址的一页”，逻辑更简洁。\"]},\"205\":{\"h\":\"✅ 4. 向后兼容旧架构\",\"t\":[\"PDP-11、x86 等早期架构都默认向下增长。\",\"为兼容早期汇编、调试器与 ABI，现代系统继续采用此设计。\"]},\"206\":{\"h\":\"四、参数在栈中哪里？\",\"t\":[\"现代系统如 x86_64 (System V ABI)，参数主要通过寄存器传递：\",\"参数编号\",\"寄存器\",\"1\",\"%rdi\",\"2\",\"%rsi\",\"3\",\"%rdx\",\"4\",\"%rcx\",\"5\",\"%r8\",\"6\",\"%r9\",\"第 7 个及之后\",\"压栈，在 %rbp 上方\",\"📌 溢出的参数、结构体等会存入“当前栈帧上方”，也就是“正偏移”部分：\",\"[rbp+0] ← 上一个 %rbp（保存） [rbp+8] ← 返回地址 [rbp+16] ← 参数7（如果有）\"]},\"207\":{\"h\":\"五、“上一个 %rbp” 是什么？是否占空间？\",\"t\":[\"是的，占用 8 字节（x86_64 下）！\",\"每个函数在进入时都会执行：\",\"push %rbp ; 保存上一个函数的基址 mov %rsp, %rbp ; 建立当前栈帧基址\",\"📌 push %rbp 把调用者的栈帧基址压入栈中，构成“链式调用栈”。\",\"这个设计的好处包括：\",\"支持 gdb, perf 等调试器追踪函数调用链（backtrace）\",\"编译器可以通过 %rbp 统一管理局部变量和参数偏移\"]},\"208\":{\"h\":\"六、如果栈向上增长，会怎样？\"},\"209\":{\"h\":\"❌ 问题一：变量管理复杂\",\"t\":[\"int x = 1; int y = 2;\",\"若使用“向上栈”，可能写成：\",\"movl $1, 8(%rbp) movl $2, 12(%rbp)\",\"难以保证不越界覆盖参数区\",\"每次添加变量都要重新分配正偏移\",\"参数和变量容易冲突\"]},\"210\":{\"h\":\"❌ 问题二：编译器和调试器成本增加\",\"t\":[\"gdb 回溯函数时，需要逐级读取 [rbp] 链接的旧帧\",\"如果帧方向改变，堆栈解引用逻辑复杂化，影响可维护性\"]},\"211\":{\"h\":\"七、总结对比\",\"t\":[\"项目\",\"向下增长 ✅\",\"向上增长 ❌\",\"与堆布局互补\",\"✅ 背靠背，空间灵活\",\"❌ 可能冲突\",\"偏移寻址逻辑\",\"✅ 负偏移统一\",\"❌ 需维护正偏移边界\",\"参数和变量分区\",\"✅ 清晰\",\"❌ 重叠管理复杂\",\"调试器栈回溯\",\"✅ 简单，链式回溯\",\"❌ 成本高\",\"页式扩展与 guard page\",\"✅ 自然扩展防溢出\",\"❌ 控制复杂\",\"向后兼容性\",\"✅ ABI 一致\",\"❌ 不兼容主流系统\"]},\"212\":{\"h\":\"结语：原理即美学\",\"t\":[\"程序栈向下增长的设计并不是偶然，而是对架构一致性、内存效率、调试能力和软件兼容性的深思熟虑结果。\",\"理解它，不只是为了写好 C 程序，更是通往底层世界的大门。\",\"📬 如果本文有帮助，欢迎留言、收藏或分享到你的朋友圈。\"]},\"213\":{\"h\":\"Python项目生成requirements文件\",\"t\":[\"如何生成requirements依赖文件\"]},\"214\":{\"h\":\"ppireqs 安装\",\"t\":[\"pip install pipreqs\"]},\"215\":{\"h\":\"使用\",\"t\":[\"Usage: pipreqs [options] [<path>] Arguments: <path> The path to the directory containing the application files for which a requirements file should be generated (defaults to the current working directory) Options: --use-local Use ONLY local package info instead of querying PyPI --pypi-server <url> Use custom PyPi server --proxy <url> Use Proxy, parameter will be passed to requests library. You can also just set the environments parameter in your terminal: $ export HTTP_PROXY=\\\"http://10.10.1.10:3128\\\" $ export HTTPS_PROXY=\\\"https://10.10.1.10:1080\\\" --debug Print debug information --ignore <dirs>... Ignore extra directories, each separated by a comma --no-follow-links Do not follow symbolic links in the project --encoding <charset> Use encoding parameter for file open --savepath <file> Save the list of requirements in the given file --print Output the list of requirements in the standard output --force Overwrite existing requirements.txt --diff <file> Compare modules in requirements.txt to project imports --clean <file> Clean up requirements.txt by removing modules that are not imported in project --mode <scheme> Enables dynamic versioning with <compat>, <gt> or <non-pin> schemes <compat> | e.g. Flask~=1.1.2 <gt> | e.g. Flask>=1.1.2 <no-pin> | e.g. Flask\"]},\"216\":{\"h\":\"使用案例\",\"t\":[\"生成requirements\",\"pipreqs /home/project/location\",\"Successfully saved requirements file in /home/project/location/requirements.txt\",\"更新requirements\",\"pipreqs --force [location]\"]},\"217\":{\"h\":\"参考链接\",\"t\":[\"pipreqs\"]},\"218\":{\"c\":[\"编程语言\"]},\"219\":{\"c\":[\"Python\",\"pipreqs\"]},\"220\":{\"h\":\"Python虚拟环境配置及其工作原理\",\"t\":[\"venv in python\"]},\"221\":{\"h\":\"工作原理\",\"t\":[\"当Python解释器在虚拟环境中运行时，sys.prefix和sys.exec_prefix指向虚拟环境的目录，而sys.prefix则指向虚拟环境的目录。sys.base_prefix和 sys.base_exec_prefix指向用于创建环境的基本Python。检查sys.prefix != sys.base_prefix来确定当前解释器是否从虚拟环境中运行。\",\"虚拟环境可以使用其二进制目录(bin on POSIX; Scripts on Windows)。这将把该目录添加到您的PATH中，以便运行python将调用环境的python解释器，并且您可以运行已安装的脚本而不必使用它们的完整路径。激活脚本的调用是特定于平台的(<venv>必须被包含虚拟环境的目录的路径所替换)\"]},\"222\":{\"h\":\"配置方法\",\"t\":[\"在Windows/Linux上，你可以使用Python的内置工具venv来创建指定版本的虚拟环境。以下以Window环境为例创建指定版本虚拟环境的步骤：\",\"确保你已经安装了指定版本的Python解释器。你可以在Python官方网站上下载和安装所需的Python版本\",\"打开命令提示符（CMD）或者PowerShell。\",\"导航到你希望创建虚拟环境的目录。例如，如果你想在C:\\\\\\\\Projects目录下创建虚拟环境，可以使用以下命令：\",\"cd C:\\\\\\\\Projects\",\"创建虚拟环境。使用python命令和m venv参数，后面跟着虚拟环境的名称和Python解释器的路径。例如，如果你想创建一个名为myenv的虚拟环境，并使用Python 3.7版本，可以使用以下命令：\",\"python -m venv myenv\",\"如果你的系统上同时安装了多个版本的Python，你可以指定要使用的Python解释器的完径。例如：\",\"python -m venv --python=C:\\\\\\\\Python37\\\\\\\\python.exe myenv\",\"激活虚拟环境。在命令提示符或者PowerShell中，使用以下命令激活虚拟环境：\",\"myenv\\\\\\\\Scripts\\\\\\\\activate\",\"激活后，你将看到命令提示符或者PowerShell的提示符前面有(myenv)字样，表示你进入了虚拟环境。\",\"现在，你已经成功创建了指定版本的虚拟环境，并且可以在该环境中安装和运行特定版本的Python程序。\"]},\"223\":{\"h\":\"参考链接\",\"t\":[\"https://docs.python.org/3/library/venv.html\"]},\"224\":{\"c\":[\"编程语言\"]},\"225\":{\"c\":[\"Python\",\"venv\"]},\"226\":{\"h\":\"davinci developer classic Port auto-connect\",\"t\":[\"本文主要讲解developer Port auto-connect 规则\"]},\"227\":{\"h\":\"连接原则\"},\"228\":{\"h\":\"auto-connect\"},\"229\":{\"h\":\"simple pattern\"},\"230\":{\"h\":\"enhanced patterns\"},\"231\":{\"h\":\"Reference\",\"t\":[\"官方文档\"]},\"232\":{\"c\":[\"Autosar\"]},\"233\":{\"c\":[\"tool\",\"developer\"]},\"234\":{\"h\":\"Autosar davinci developer classic使用教程\",\"t\":[\"本文主要讲解Autosar davinci developer classic基本使用\"]},\"235\":{\"h\":\"1.介绍\",\"t\":[\"为autosar ECU 设计软件组件架构，位于V形流程的Application Software Development; 通过图形视图或文本网格视图，可以设计包括端口、数据在内的软件组件类型、连接器和内部行为。\"]},\"236\":{\"h\":\"2.工作空间(workspace)\",\"t\":[\"Alt text\",\"Alt text\"]},\"237\":{\"h\":\"3. SWC 设计\",\"t\":[\"Alt text\",\"应用组件(Application Components)\",\"端口、端口初始值和数据元素(Ports, Port Init Values and Data Elements)\",\"连接(Connections)\",\"可运行实体(Runnables)\",\"触发器(Triggers)\",\"端口访问(Port Access)\",\"数据映射(Data Mapping)\"]},\"238\":{\"h\":\"1. 创建 Application Components\",\"t\":[\"在 object browser界面有三种视图：Type-oriented、Package-oriented 和 File-oriented\",\"在 Type-oriented 视图右键即可创建新Application Component type\",\"Alt text\"]},\"239\":{\"h\":\"2. 理解类型、原型和接口(Types, Prototypes and Interfaces)\",\"t\":[\"在Object Browser中，软件组件是类型，端口是接口。只要你 使用它们，它们就变成了原型\",\"Port Interface used by a component type -> Port Prototype\",\"Component Type in Object Browser used in software design view -> Component Prototype\",\"Alt text\"]},\"240\":{\"h\":\"3. 端口、端口初始值和 数据元素(元数据的一个原子数据单元)\",\"t\":[\"在使用应用程序端口之前，必须定义应用程序端口接口。要完全定义端口接口，如果不想使用预定义的数据类型，则必须首先定义数据类型。 端口有以下几个类别\",\"Sender Ports to provide information\",\"Receiver Ports to receive information\",\"Sender/Receiver Ports to provide and receive information within one port\",\"Server Ports to provide services (operations)\",\"Client Ports to use services (operations)\",\"Calibration Ports to hand over calibration parameters\",\"Mode Ports to e.g. trigger or not trigger runnables within certain modes\"]},\"241\":{\"h\":\"4. 在应用程序组件中配置服务端口\"},\"242\":{\"h\":\"5. 定义runnables\"},\"243\":{\"h\":\"6. 为runnable配置触发器、 Port Access\"},\"244\":{\"h\":\"7. 生成模板\",\"t\":[\"如果计划手动实现SWC(而不是使用基于模型的代码生成器)，可以生成SWC模板和合约头文件。 要生成代码，可以在对象浏览器中选择SWC，并通过上下文调用代码生成器菜单\",\"Alt text\"]},\"245\":{\"c\":[\"Autosar\"]},\"246\":{\"c\":[\"tool\",\"developer\"]},\"247\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"248\":{\"h\":\"关于我\"},\"249\":{\"h\":\"Autosar\"},\"250\":{\"h\":\"技术笔记\"},\"251\":{\"h\":\"工具\"},\"252\":{\"h\":\"算法\"},\"253\":{\"h\":\"设计模式\"},\"254\":{\"h\":\"投资理财\"},\"255\":{\"h\":\"生活随想\"},\"256\":{\"h\":\"SOMEIP\"},\"257\":{\"h\":\"Github\"},\"258\":{\"h\":\"C\"},\"259\":{\"h\":\"编程语言\"},\"260\":{\"h\":\"Python\"},\"261\":{\"h\":\"Auto Connect Port Prototypes\"},\"262\":{\"h\":\"Da Vinci Configurator Classic\"},\"263\":{\"h\":\"User Manual\"}},\"dirtCount\":0,\"index\":[[\"投资理财\",{\"0\":{\"254\":1}}],[\"投入其中\",{\"1\":{\"126\":1}}],[\"技术笔记\",{\"0\":{\"250\":1}}],[\"技术分析及大市走向\",{\"1\":{\"119\":1}}],[\"技术分析是我买进卖出的主要参考\",{\"1\":{\"117\":1}}],[\"视图右键即可创建新application\",{\"1\":{\"238\":1}}],[\"触发器\",{\"1\":{\"237\":1}}],[\"触发时机\",{\"0\":{\"154\":1}}],[\"位于v形流程的application\",{\"1\":{\"235\":1}}],[\"介绍\",{\"0\":{\"235\":1}}],[\"介绍页\",{\"0\":{\"1\":1}}],[\"官方文档\",{\"1\":{\"231\":1}}],[\"官方定义\",{\"0\":{\"149\":1}}],[\"激活后\",{\"1\":{\"222\":1}}],[\"激活虚拟环境\",{\"1\":{\"222\":1}}],[\"激活脚本的调用是特定于平台的\",{\"1\":{\"221\":1}}],[\"导航到你希望创建虚拟环境的目录\",{\"1\":{\"222\":1}}],[\"导航系统\",{\"1\":{\"102\":2}}],[\"打开命令提示符\",{\"1\":{\"222\":1}}],[\"打印初始状态\",{\"1\":{\"101\":1}}],[\"打印汽车状态\",{\"1\":{\"101\":1}}],[\"打印汽车信息\",{\"1\":{\"86\":2,\"87\":1,\"94\":2}}],[\"querying\",{\"1\":{\"215\":1}}],[\"收藏或分享到你的朋友圈\",{\"1\":{\"212\":1}}],[\"收市低收盘\",{\"1\":{\"117\":1}}],[\"欢迎留言\",{\"1\":{\"212\":1}}],[\"程序\",{\"1\":{\"212\":1}}],[\"程序栈向下增长的设计并不是偶然\",{\"1\":{\"212\":1}}],[\"页式扩展与\",{\"1\":{\"211\":1}}],[\"页式管理高效\",{\"0\":{\"204\":1}}],[\"成本高\",{\"1\":{\"211\":1}}],[\"成功订阅事件组\",{\"1\":{\"146\":1}}],[\"成功不是达到目的\",{\"1\":{\"128\":1}}],[\"成功的投资必须基于对今天和未来所发生的事件对股价的可能影响做理性判断\",{\"1\":{\"125\":1}}],[\"成功的投资者绝不幻想\",{\"1\":{\"118\":1}}],[\"成功的秘诀不外乎是\",{\"1\":{\"118\":1}}],[\"成功的要素\",{\"0\":{\"118\":1}}],[\"偏移寻址逻辑\",{\"1\":{\"211\":1}}],[\"偏移为\",{\"1\":{\"195\":2}}],[\"空间灵活\",{\"1\":{\"211\":1}}],[\"空闲区\",{\"1\":{\"200\":1}}],[\"背靠背\",{\"1\":{\"211\":1}}],[\"背书\",{\"1\":{\"126\":1}}],[\"链式回溯\",{\"1\":{\"211\":1}}],[\"链式调用栈\",{\"1\":{\"207\":1}}],[\"链接的旧帧\",{\"1\":{\"210\":1}}],[\"回溯函数时\",{\"1\":{\"210\":1}}],[\"回应\",{\"1\":{\"141\":1}}],[\"统一管理局部变量和参数偏移\",{\"1\":{\"207\":1}}],[\"统一接口\",{\"1\":{\"99\":1}}],[\"构成\",{\"1\":{\"207\":1}}],[\"构建汽车\",{\"1\":{\"85\":1}}],[\"构建\",{\"1\":{\"57\":1}}],[\"建立当前栈帧基址\",{\"1\":{\"207\":1}}],[\"建议\",{\"1\":{\"21\":1}}],[\"占用\",{\"1\":{\"207\":1}}],[\"返回地址\",{\"1\":{\"206\":1}}],[\"返回地址等\",{\"1\":{\"200\":1}}],[\"溢出的参数\",{\"1\":{\"206\":1}}],[\"压栈\",{\"1\":{\"206\":1}}],[\"个及之后\",{\"1\":{\"206\":1}}],[\"个典型状态\",{\"1\":{\"143\":1}}],[\"逻辑更简洁\",{\"1\":{\"204\":1}}],[\"底部\",{\"1\":{\"204\":1}}],[\"防溢出安全\",{\"0\":{\"204\":1}}],[\"❗\",{\"1\":{\"203\":1}}],[\"负偏移统一\",{\"1\":{\"211\":1}}],[\"负偏移更高效\",{\"0\":{\"203\":1}}],[\"负责保存和恢复备忘录\",{\"1\":{\"101\":2}}],[\"负责人\",{\"1\":{\"101\":2}}],[\"负责创建和管理享元对象\",{\"1\":{\"94\":1}}],[\"负责创建具体的产品对象\",{\"1\":{\"83\":1,\"84\":1,\"85\":1}}],[\"负责实现子系统的具体功能\",{\"1\":{\"93\":1}}],[\"负责使用生成器对象创建产品\",{\"1\":{\"85\":1}}],[\"负责对象间的高效沟通和职责委派\",{\"1\":{\"79\":1}}],[\"负责的字段\",{\"1\":{\"19\":1}}],[\"堆栈解引用逻辑复杂化\",{\"1\":{\"210\":1}}],[\"堆撞栈\",{\"1\":{\"202\":1}}],[\"堆区从低地址向上扩展\",{\"1\":{\"202\":1}}],[\"堆\",{\"1\":{\"200\":1}}],[\"局部变量\",{\"1\":{\"200\":1}}],[\"局部优化控制\",{\"1\":{\"190\":1}}],[\"←\",{\"1\":{\"200\":2,\"203\":3,\"206\":3}}],[\"↑\",{\"1\":{\"200\":1}}],[\"栈的\",{\"1\":{\"204\":1}}],[\"栈帧如下\",{\"1\":{\"203\":1}}],[\"栈溢出\",{\"1\":{\"202\":1}}],[\"栈从高地址向下扩展\",{\"1\":{\"202\":1}}],[\"栈与堆背靠背扩展\",{\"1\":{\"200\":1}}],[\"栈\",{\"1\":{\"200\":1}}],[\"栈在什么位置\",{\"0\":{\"200\":1}}],[\"栈向下增长\",{\"0\":{\"199\":1},\"1\":{\"198\":1,\"199\":1}}],[\"低地址\",{\"1\":{\"199\":1,\"200\":1}}],[\"低点出市\",{\"1\":{\"118\":1}}],[\"寄存器\",{\"1\":{\"206\":1}}],[\"寄存器设计\",{\"1\":{\"198\":1}}],[\"寄存器分配\",{\"1\":{\"186\":1}}],[\"$\",{\"1\":{\"215\":2}}],[\"$2\",{\"1\":{\"203\":1,\"209\":1}}],[\"$1\",{\"1\":{\"203\":1,\"209\":1}}],[\"$8\",{\"1\":{\"195\":1}}],[\"$4\",{\"1\":{\"195\":1}}],[\"指的是栈顶指针\",{\"1\":{\"199\":1}}],[\"指向一个虚构的数组的第二个元素\",{\"1\":{\"195\":1}}],[\"指令分析\",{\"1\":{\"190\":1}}],[\"指令调度\",{\"1\":{\"186\":1}}],[\"指令\",{\"1\":{\"185\":1}}],[\"指令介绍\",{\"0\":{\"159\":1}}],[\"取得数组第二个元素的地址\",{\"1\":{\"195\":1}}],[\"取得数组的第二个元素\",{\"1\":{\"195\":1}}],[\"取消global级别的代理配置后\",{\"1\":{\"163\":1}}],[\"取消代理\",{\"0\":{\"161\":1}}],[\"取消事件组订阅\",{\"1\":{\"149\":1}}],[\"取消订阅行为\",{\"1\":{\"144\":1}}],[\"转换为指向类型\",{\"1\":{\"195\":2}}],[\"转发\",{\"1\":{\"9\":1}}],[\"整个表达式的目的是计算一个指向类型\",{\"1\":{\"195\":1}}],[\"整个表达式被强制转换为\",{\"1\":{\"194\":1}}],[\"整体层次结构的场景\",{\"1\":{\"91\":1}}],[\"整体层次结构\",{\"1\":{\"91\":1}}],[\"整体\",{\"1\":{\"91\":1}}],[\"计算出第一个元素之后的地址\",{\"1\":{\"194\":1}}],[\"比特\",{\"1\":{\"194\":1}}],[\"比如我今天以10\",{\"1\":{\"123\":1}}],[\"比如wsgi\",{\"1\":{\"81\":1}}],[\"比如django或者spring\",{\"1\":{\"81\":1}}],[\"库提供的函数\",{\"1\":{\"193\":1}}],[\"愿你也能用最小的代码跑出最极致的性能\",{\"1\":{\"191\":1}}],[\"星光不问赶路人\",{\"1\":{\"191\":1}}],[\"✨\",{\"1\":{\"191\":1}}],[\"嵌入式开发中继续焕发活力\",{\"1\":{\"191\":1}}],[\"嵌入式场景采用\",{\"1\":{\"189\":1}}],[\"插件与\",{\"1\":{\"190\":1}}],[\"进程虚拟内存布局\",{\"1\":{\"200\":1}}],[\"进程内存布局\",{\"0\":{\"200\":1}}],[\"进一步探索方向\",{\"0\":{\"190\":1}}],[\"进入\",{\"1\":{\"151\":1}}],[\"⚡\",{\"1\":{\"189\":1}}],[\"作为默认优化等级\",{\"1\":{\"189\":1}}],[\"作为买的理由\",{\"1\":{\"120\":1}}],[\"作为买入的理由\",{\"1\":{\"120\":1}}],[\"加入\",{\"1\":{\"189\":1}}],[\"加入循环展开\",{\"1\":{\"188\":1}}],[\"加速等\",{\"1\":{\"98\":1}}],[\"加速\",{\"1\":{\"27\":1}}],[\"汇编\",{\"1\":{\"203\":1}}],[\"汇编分析亮点\",{\"0\":{\"188\":1}}],[\"汇率\",{\"1\":{\"113\":1}}],[\"持平\",{\"1\":{\"187\":1}}],[\"持有命令对象并通过命令对象来执行请求\",{\"1\":{\"98\":2}}],[\"倍\",{\"1\":{\"187\":1}}],[\"秒\",{\"1\":{\"187\":4}}],[\"秒或更长\",{\"1\":{\"153\":1}}],[\"亿元素\",{\"1\":{\"187\":1}}],[\"观察在不同优化等级下的性能变化\",{\"1\":{\"187\":1}}],[\"观察者接收通知的顺序可能是不确定的\",{\"1\":{\"102\":1}}],[\"观察者接口\",{\"1\":{\"102\":1}}],[\"观察者\",{\"1\":{\"102\":1}}],[\"观察者模式可以用于监控汽车状态的变化\",{\"1\":{\"102\":1}}],[\"观察者模式通过定义一对多的依赖关系\",{\"1\":{\"102\":1}}],[\"观察者模式使得主题和观察者之间的依赖关系减少\",{\"1\":{\"102\":1}}],[\"观察者模式主要包括以下几个部分\",{\"1\":{\"102\":1}}],[\"观察者模式是一种行为型设计模式\",{\"1\":{\"102\":1}}],[\"观察者模式\",{\"0\":{\"102\":1},\"1\":{\"79\":1}}],[\"数组求和优化对比\",{\"0\":{\"187\":1}}],[\"数据元素\",{\"0\":{\"240\":1}}],[\"数据映射\",{\"1\":{\"237\":1}}],[\"数据在内的软件组件类型\",{\"1\":{\"235\":1}}],[\"数据在mcu\",{\"1\":{\"33\":1}}],[\"数据压入低地址\",{\"1\":{\"199\":1}}],[\"数据库连接池等\",{\"1\":{\"87\":1}}],[\"数据源不唯一\",{\"1\":{\"13\":1}}],[\"循环被优化\",{\"1\":{\"188\":1}}],[\"循环展开\",{\"1\":{\"186\":1}}],[\"循环不变量外提\",{\"1\":{\"185\":1}}],[\"强度削弱\",{\"1\":{\"185\":1}}],[\"强调职责清晰\",{\"1\":{\"21\":1}}],[\"公共子表达式消除\",{\"1\":{\"185\":1}}],[\"公司回购自己的股票\",{\"1\":{\"115\":1}}],[\"死代码删除\",{\"1\":{\"184\":1}}],[\"源代码层面\",{\"0\":{\"184\":1}}],[\"源接口\",{\"1\":{\"89\":1}}],[\"推荐等级\",{\"1\":{\"182\":1}}],[\"推送事件\",{\"1\":{\"152\":1,\"157\":1}}],[\"启用\",{\"1\":{\"189\":1}}],[\"启用非标准浮点优化\",{\"1\":{\"188\":1}}],[\"启用如\",{\"1\":{\"186\":1}}],[\"启用激进优化\",{\"1\":{\"182\":1}}],[\"启用基本优化\",{\"1\":{\"182\":1}}],[\"启动后进入\",{\"1\":{\"154\":1}}],[\"启动后准备寻找服务\",{\"1\":{\"146\":1}}],[\"启动\",{\"1\":{\"103\":1}}],[\"启动状态\",{\"1\":{\"103\":1}}],[\"启动引擎\",{\"1\":{\"100\":1}}],[\"启动引擎命令\",{\"1\":{\"98\":1}}],[\"默认关闭所有优化\",{\"1\":{\"182\":1}}],[\"探讨其优化等级对性能的影响\",{\"1\":{\"181\":1}}],[\"虽然使用extern可以模拟类和对象的概念\",{\"1\":{\"178\":1}}],[\"虽然可能有反调\",{\"1\":{\"117\":1}}],[\"运算符的一种可能的简化实现\",{\"1\":{\"194\":1}}],[\"运算符在编译时计算\",{\"1\":{\"193\":1}}],[\"运行结果图\",{\"1\":{\"178\":1}}],[\"运行结果\",{\"1\":{\"178\":1}}],[\"运动模式\",{\"1\":{\"104\":3}}],[\"首先\",{\"1\":{\"178\":1}}],[\"首先理解声明和定义\",{\"1\":{\"176\":1}}],[\"x86\",{\"1\":{\"187\":1,\"199\":1,\"205\":1,\"206\":1,\"207\":1}}],[\"x\",{\"1\":{\"177\":1,\"185\":3,\"203\":2,\"209\":1}}],[\"变量管理复杂\",{\"0\":{\"209\":1}}],[\"变量偏移\",{\"1\":{\"203\":1}}],[\"变量使用寄存器\",{\"1\":{\"188\":1}}],[\"变量声明\",{\"1\":{\"177\":1}}],[\"变速箱\",{\"1\":{\"100\":3}}],[\"直接修改现有对象\",{\"1\":{\"171\":1}}],[\"直到收到有效\",{\"1\":{\"154\":1}}],[\"直到有一个对象处理它为止\",{\"1\":{\"97\":1}}],[\"直到真正需要时才进行创建\",{\"1\":{\"95\":1}}],[\"字样\",{\"1\":{\"222\":1}}],[\"字节\",{\"1\":{\"207\":1}}],[\"字符串的+=运算符被设计为修改现有字符串对象\",{\"1\":{\"171\":1}}],[\"字段始终无效\",{\"1\":{\"149\":1}}],[\"字段共同决定\",{\"1\":{\"149\":1}}],[\"字段和\",{\"1\":{\"149\":1}}],[\"字段\",{\"1\":{\"147\":1,\"149\":1}}],[\"附加到现有字符串s上来修改现有字符串\",{\"1\":{\"171\":2}}],[\"编译器和调试器成本增加\",{\"0\":{\"210\":1}}],[\"编译器可以通过\",{\"1\":{\"207\":1}}],[\"编译器只需不断\",{\"1\":{\"203\":1}}],[\"编译器的优化能力对比\",{\"1\":{\"190\":1}}],[\"编译器无法区分该语句是成员变量声明还是成员函数声明\",{\"1\":{\"167\":1}}],[\"编译期将常量表达式计算完成\",{\"1\":{\"184\":1}}],[\"编译时间与可调试性\",{\"1\":{\"182\":1}}],[\"编译优化的核心原理\",{\"1\":{\"181\":1}}],[\"编译这些文件并运行程序\",{\"1\":{\"178\":1}}],[\"编程语言\",{\"0\":{\"259\":1},\"2\":{\"168\":1,\"173\":1,\"179\":1,\"196\":1,\"218\":1,\"224\":1}}],[\"遇到报错\",{\"1\":{\"163\":1}}],[\"遇有暴利\",{\"1\":{\"123\":1}}],[\"案例\",{\"0\":{\"163\":1,\"172\":1,\"178\":1}}],[\"替换为\",{\"1\":{\"185\":1}}],[\"替换为你本地代理的端口\",{\"1\":{\"161\":1}}],[\"替代方案\",{\"0\":{\"14\":1}}],[\"维持订阅有效性\",{\"1\":{\"157\":1}}],[\"维护当前状态并委托状态处理具体行为\",{\"1\":{\"103\":1}}],[\"维护一个策略对象的引用\",{\"1\":{\"104\":2}}],[\"维护一个当前状态\",{\"1\":{\"103\":1}}],[\"维护一个观察者列表\",{\"1\":{\"102\":1}}],[\"维护主题的状态\",{\"1\":{\"102\":1}}],[\"机制\",{\"1\":{\"157\":1}}],[\"机会的贪婪常使你在股票的最高点入股\",{\"1\":{\"125\":1}}],[\"绑定机制\",{\"1\":{\"157\":1}}],[\"绑定接收者对象\",{\"1\":{\"98\":1}}],[\"角色\",{\"1\":{\"157\":1}}],[\"九\",{\"0\":{\"157\":1}}],[\"筛选\",{\"1\":{\"155\":1}}],[\"抓包\",{\"1\":{\"155\":1}}],[\"抓包可见每次状态跳转时对应的\",{\"1\":{\"146\":1}}],[\"错误原因是\",{\"1\":{\"167\":1}}],[\"错误\",{\"1\":{\"155\":1}}],[\"错误连接\",{\"0\":{\"11\":1,\"13\":1}}],[\"遗失\",{\"1\":{\"155\":1}}],[\"失败\",{\"1\":{\"155\":1}}],[\"问题二\",{\"0\":{\"210\":1}}],[\"问题一\",{\"0\":{\"209\":1}}],[\"问题解决\",{\"1\":{\"163\":1}}],[\"问题\",{\"1\":{\"155\":1}}],[\"环节\",{\"1\":{\"155\":1}}],[\"环境\",{\"0\":{\"112\":1}}],[\"若使用\",{\"1\":{\"209\":1}}],[\"若是\",{\"1\":{\"203\":1}}],[\"若在一定时间内未收到\",{\"1\":{\"154\":1}}],[\"若参考上面项目构建链接\",{\"1\":{\"59\":1}}],[\"继续广播\",{\"1\":{\"153\":1}}],[\"继承了component\",{\"1\":{\"92\":1}}],[\"继承is是\",{\"1\":{\"81\":1}}],[\"继承代表类之间的\",{\"1\":{\"81\":1}}],[\"仍会继续发送\",{\"1\":{\"153\":1}}],[\"告知所有\",{\"1\":{\"151\":1}}],[\"🧹\",{\"0\":{\"150\":1}}],[\"🧠\",{\"0\":{\"136\":1}}],[\"查找服务\",{\"1\":{\"149\":1}}],[\"查看本地分支\",{\"1\":{\"59\":1}}],[\"条件\",{\"1\":{\"149\":1}}],[\"标准定义如下\",{\"1\":{\"149\":1}}],[\"标识符描述了数据的含义\",{\"1\":{\"29\":1}}],[\"联合决定\",{\"1\":{\"149\":1}}],[\"拒绝订阅请求\",{\"1\":{\"149\":1}}],[\"拒绝\",{\"1\":{\"149\":1}}],[\"≠\",{\"1\":{\"149\":1}}],[\"✖️\",{\"1\":{\"149\":1}}],[\"终止行为\",{\"1\":{\"149\":1}}],[\"规则\",{\"1\":{\"226\":1}}],[\"规范文档中的\",{\"1\":{\"149\":1}}],[\"规定一类对象的行为\",{\"1\":{\"73\":1}}],[\"示例用法\",{\"1\":{\"194\":1}}],[\"示例实战分析\",{\"0\":{\"187\":1}}],[\"示例\",{\"1\":{\"147\":1}}],[\"示例代码\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"地址计算自然\",{\"0\":{\"203\":1}}],[\"地址\",{\"1\":{\"146\":1}}],[\"处理\",{\"1\":{\"187\":1}}],[\"处理它所负责的请求\",{\"1\":{\"97\":1}}],[\"处于活跃状态\",{\"1\":{\"146\":1}}],[\"描述\",{\"1\":{\"145\":1,\"146\":1,\"149\":1}}],[\"描述问题和解决方案\",{\"1\":{\"77\":1}}],[\"已完成订阅\",{\"1\":{\"153\":1}}],[\"已发送\",{\"1\":{\"146\":1}}],[\"已订阅而停止\",{\"1\":{\"153\":1}}],[\"已订阅\",{\"1\":{\"144\":1}}],[\"已见\",{\"1\":{\"144\":1}}],[\"搜索中\",{\"1\":{\"144\":1}}],[\"搜索服务\",{\"1\":{\"137\":1}}],[\"点播订阅\",{\"1\":{\"141\":1}}],[\"⏱\",{\"0\":{\"141\":1}}],[\"表达动作意图\",{\"1\":{\"139\":1}}],[\"表示你进入了虚拟环境\",{\"1\":{\"222\":1}}],[\"表示你第一次入场的判断正确\",{\"1\":{\"124\":1}}],[\"表示成功使用extern实现了面向对象编程的模拟\",{\"1\":{\"178\":1}}],[\"表示订阅有效时长\",{\"1\":{\"154\":1}}],[\"表示取消订阅\",{\"1\":{\"152\":1}}],[\"表示不同的驾驶模式\",{\"1\":{\"104\":1}}],[\"表示不同类型的汽车\",{\"1\":{\"83\":1}}],[\"表示叶节点对象\",{\"1\":{\"91\":1}}],[\"表示汽车的基本信息\",{\"1\":{\"89\":1}}],[\"表示汽车的类型\",{\"1\":{\"89\":1}}],[\"表示被创建的复杂对象\",{\"1\":{\"85\":1}}],[\"表示私有\",{\"1\":{\"72\":1}}],[\"|===\",{\"1\":{\"141\":1}}],[\"|<\",{\"1\":{\"141\":2}}],[\"|\",{\"1\":{\"139\":9,\"141\":9,\"200\":8,\"215\":3}}],[\"||\",{\"1\":{\"91\":1}}],[\"消息结构\",{\"1\":{\"139\":1}}],[\"端口有以下几个类别\",{\"1\":{\"240\":1}}],[\"端口初始值和\",{\"0\":{\"240\":1}}],[\"端口初始值和数据元素\",{\"1\":{\"237\":1}}],[\"端口是接口\",{\"1\":{\"239\":1}}],[\"端口访问\",{\"1\":{\"237\":1}}],[\"端口错误\",{\"1\":{\"155\":1}}],[\"端口\",{\"0\":{\"240\":1},\"1\":{\"139\":1,\"237\":1}}],[\"端口的情况下\",{\"1\":{\"133\":1}}],[\"常量折叠\",{\"1\":{\"184\":1}}],[\"常规推送\",{\"1\":{\"137\":1}}],[\"常见误区与连接限制\",{\"0\":{\"10\":1}}],[\"常见误区以及最佳实践建议\",{\"1\":{\"2\":1}}],[\"响应\",{\"1\":{\"137\":1}}],[\"系接\",{\"1\":{\"136\":1}}],[\"系统中存在大量相似的对象\",{\"1\":{\"94\":1}}],[\"订阅服务\",{\"1\":{\"157\":1}}],[\"订阅\",{\"1\":{\"149\":1}}],[\"订阅有效期\",{\"1\":{\"147\":1}}],[\"订阅中\",{\"1\":{\"144\":1}}],[\"订阅事件\",{\"1\":{\"137\":1}}],[\"订阅组织\",{\"1\":{\"136\":1}}],[\"订阅模式\",{\"1\":{\"102\":1}}],[\"功能\",{\"1\":{\"136\":1}}],[\"功能安全服务\",{\"1\":{\"46\":1}}],[\"核心转换基于\",{\"1\":{\"144\":1}}],[\"核心特性\",{\"0\":{\"136\":1}}],[\"核心概念\",{\"1\":{\"22\":1}}],[\"路由\",{\"1\":{\"135\":1}}],[\"应用组件\",{\"1\":{\"237\":1}}],[\"应用场景\",{\"0\":{\"135\":1}}],[\"应该使用s\",{\"1\":{\"171\":1}}],[\"应该是达到这一目的的过程\",{\"1\":{\"128\":1}}],[\"应该递归调用子节点的操作\",{\"1\":{\"91\":1}}],[\"应该将高层模块和低层模块之间的依赖关系倒置过来\",{\"1\":{\"81\":1}}],[\"应该将接口拆分成更小的接口\",{\"1\":{\"81\":1}}],[\"未显著提升整数性能\",{\"1\":{\"188\":1}}],[\"未启用周期推送\",{\"1\":{\"155\":1}}],[\"未处于\",{\"1\":{\"155\":1}}],[\"未收接事件\",{\"1\":{\"155\":1}}],[\"未提供\",{\"1\":{\"134\":1}}],[\"未随大流\",{\"1\":{\"125\":1}}],[\"📬\",{\"1\":{\"212\":1}}],[\"💡\",{\"1\":{\"198\":1}}],[\"📈\",{\"1\":{\"189\":1}}],[\"📊\",{\"1\":{\"189\":1}}],[\"🔬\",{\"0\":{\"188\":1}}],[\"🚀\",{\"1\":{\"187\":1}}],[\"🔍\",{\"0\":{\"154\":1},\"1\":{\"189\":1}}],[\"🔁\",{\"0\":{\"153\":1}}],[\"📑\",{\"0\":{\"149\":1}}],[\"💬\",{\"0\":{\"138\":1}}],[\"🗺\",{\"0\":{\"137\":1}}],[\"🔗\",{\"0\":{\"135\":1}}],[\"📦\",{\"0\":{\"134\":1},\"1\":{\"189\":1}}],[\"📌\",{\"0\":{\"20\":1},\"1\":{\"9\":1,\"15\":1,\"149\":2,\"152\":1,\"154\":1,\"203\":1,\"206\":1,\"207\":1}}],[\"网络参数\",{\"1\":{\"157\":1}}],[\"网络退出或软件模块重启时的服务注销\",{\"1\":{\"152\":1}}],[\"网络的服务发现协议\",{\"1\":{\"133\":1}}],[\"网络连接等\",{\"1\":{\"87\":1}}],[\"快快止损\",{\"1\":{\"129\":1}}],[\"似乎还没有什么其他方法\",{\"1\":{\"129\":1}}],[\"涉及一个很重要的数学概念\",{\"1\":{\"129\":1}}],[\"正偏移\",{\"1\":{\"206\":1}}],[\"正在续订以保持\",{\"1\":{\"146\":1}}],[\"正常行为\",{\"1\":{\"149\":1}}],[\"正常通信流程\",{\"0\":{\"140\":1}}],[\"正常\",{\"1\":{\"129\":2}}],[\"正确地预见未来的需求\",{\"1\":{\"118\":1}}],[\"正确做法\",{\"0\":{\"12\":1}}],[\"陶冶性情的场所\",{\"1\":{\"128\":1}}],[\"两者互不干扰\",{\"1\":{\"202\":1}}],[\"两者没有区别\",{\"1\":{\"127\":1}}],[\"两种类型\",{\"1\":{\"30\":1}}],[\"任何持有的股票都应有超过50\",{\"1\":{\"129\":1}}],[\"任何有输的可能的行为都是赌\",{\"1\":{\"127\":1}}],[\"任一节点可在任一时刻主动发送\",{\"1\":{\"29\":1}}],[\"懂了\",{\"1\":{\"127\":1}}],[\"都让我自己觉得自己\",{\"1\":{\"127\":1}}],[\"都要小心\",{\"1\":{\"124\":1}}],[\"体验风险阶段\",{\"1\":{\"127\":1}}],[\"炒手访谈\",{\"0\":{\"127\":1}}],[\"炒股是概率的游戏\",{\"1\":{\"117\":1}}],[\"炒股的最基本信条是在任何时候\",{\"1\":{\"118\":1}}],[\"炒股的诀窍便是在牛市中全力投入\",{\"1\":{\"117\":1}}],[\"炒股的技能太活了\",{\"1\":{\"111\":1}}],[\"炒股的智慧\",{\"0\":{\"110\":1},\"1\":{\"110\":1},\"2\":{\"131\":1}}],[\"做法就是认清其假象\",{\"1\":{\"126\":1}}],[\"做短线时例外\",{\"1\":{\"116\":1}}],[\"民众相信自己在模仿成功人士\",{\"1\":{\"126\":1}}],[\"依赖\",{\"1\":{\"126\":1}}],[\"依赖倒置原则\",{\"1\":{\"81\":1}}],[\"权威\",{\"1\":{\"126\":1}}],[\"家\",{\"1\":{\"126\":1}}],[\"得到一个指向类型\",{\"1\":{\"195\":2}}],[\"得到多少\",{\"1\":{\"125\":1}}],[\"得是好主意\",{\"1\":{\"126\":1}}],[\"觉\",{\"1\":{\"126\":1}}],[\"必定带来滚雪球效应\",{\"1\":{\"126\":1}}],[\"必须定义应用程序端口接口\",{\"1\":{\"240\":1}}],[\"必须在\",{\"1\":{\"154\":1}}],[\"必须具有耐心和自制力\",{\"1\":{\"118\":1}}],[\"必须强调\",{\"1\":{\"117\":1}}],[\"出游资\",{\"1\":{\"126\":1}}],[\"创造\",{\"1\":{\"126\":1}}],[\"创建虚拟环境\",{\"1\":{\"222\":1}}],[\"创建观察者对象\",{\"1\":{\"102\":1}}],[\"创建和恢复备忘录需要额外的计算开销\",{\"1\":{\"101\":1}}],[\"创建备忘录并保存当前状态\",{\"1\":{\"101\":1}}],[\"创建备忘录\",{\"1\":{\"101\":1}}],[\"创建同事类对象并设置中介者\",{\"1\":{\"100\":1}}],[\"创建中介者\",{\"1\":{\"100\":1}}],[\"创建迭代器\",{\"1\":{\"99\":1}}],[\"创建调用者对象\",{\"1\":{\"98\":1}}],[\"创建接收者对象\",{\"1\":{\"98\":1}}],[\"创建真实汽车对象\",{\"1\":{\"95\":1}}],[\"创建代理对象\",{\"1\":{\"95\":1}}],[\"创建享元工厂\",{\"1\":{\"94\":2}}],[\"创建汽车\",{\"1\":{\"103\":1,\"104\":1}}],[\"创建汽车集合的迭代器\",{\"1\":{\"99\":1}}],[\"创建汽车集合\",{\"1\":{\"99\":2}}],[\"创建汽车经销商对象\",{\"1\":{\"93\":2}}],[\"创建汽车工厂对象\",{\"1\":{\"93\":1}}],[\"创建汽车装饰对象\",{\"1\":{\"92\":2}}],[\"创建汽车对象\",{\"1\":{\"92\":2,\"93\":1,\"99\":1,\"101\":1,\"102\":1}}],[\"创建了多个叶子节点\",{\"1\":{\"91\":1}}],[\"创建组合节点\",{\"1\":{\"91\":1}}],[\"创建叶子节点\",{\"1\":{\"91\":1}}],[\"创建扩展抽象部分对象\",{\"1\":{\"90\":1}}],[\"创建具体命令对象\",{\"1\":{\"98\":1}}],[\"创建具体命令对象并设置其接收者\",{\"1\":{\"98\":2}}],[\"创建具体处理者对象\",{\"1\":{\"97\":1}}],[\"创建具体的检查者对象\",{\"1\":{\"97\":1}}],[\"创建具体实现部分对象\",{\"1\":{\"90\":1}}],[\"创建具体生成器\",{\"1\":{\"85\":1}}],[\"创建适配器对象\",{\"1\":{\"89\":1}}],[\"创建传统燃油汽车对象\",{\"1\":{\"89\":1}}],[\"创建复杂对象\",{\"1\":{\"86\":1}}],[\"创建原型汽车\",{\"1\":{\"86\":1}}],[\"创建新的汽车实例\",{\"1\":{\"86\":1}}],[\"创建主管\",{\"1\":{\"85\":2}}],[\"创建掀背车\",{\"1\":{\"83\":2,\"84\":2}}],[\"创建\",{\"0\":{\"238\":1},\"1\":{\"83\":2,\"84\":2}}],[\"创建轿车\",{\"1\":{\"83\":2,\"84\":2}}],[\"创建一个包含其当前内部状态的备忘录对象\",{\"1\":{\"101\":1}}],[\"创建一个\",{\"1\":{\"81\":1}}],[\"创建型模式包括工厂方法模式\",{\"1\":{\"79\":1}}],[\"创建型模式提供了创建对象的机制\",{\"1\":{\"79\":1}}],[\"创建型模式\",{\"1\":{\"79\":2}}],[\"创建型模式主要用于创建对象\",{\"1\":{\"79\":1}}],[\"创建本地分支\",{\"1\":{\"59\":2}}],[\"社会游资甚多\",{\"1\":{\"126\":1}}],[\"带来巨额的财富\",{\"1\":{\"126\":1}}],[\"概率\",{\"1\":{\"129\":1}}],[\"概念或产品\",{\"1\":{\"126\":1}}],[\"概述\",{\"2\":{\"56\":1}}],[\"吸引更多的股民加入\",{\"1\":{\"126\":1}}],[\"促使投资大众开始投入\",{\"1\":{\"126\":1}}],[\"促进团队协作\",{\"1\":{\"70\":1}}],[\"气球胀的时间比常人想像得更久\",{\"1\":{\"126\":1}}],[\"气球胀到一定地步\",{\"1\":{\"126\":1}}],[\"气球后面一定有一动人的故事\",{\"1\":{\"126\":1}}],[\"气球吹胀的初期\",{\"1\":{\"126\":1}}],[\"到期前重新\",{\"1\":{\"154\":1}}],[\"到了晚期的特征之一\",{\"1\":{\"126\":1}}],[\"到内部\",{\"1\":{\"9\":1}}],[\"疯\",{\"1\":{\"126\":2}}],[\"骗案层出不穷是所有\",{\"1\":{\"126\":1}}],[\"随即常常来一次亏大钱\",{\"1\":{\"127\":1}}],[\"随后便嘲笑他们的短视\",{\"1\":{\"126\":1}}],[\"随着经验的增加\",{\"1\":{\"124\":1}}],[\"随着同事类的增加\",{\"1\":{\"100\":1}}],[\"随着软件开发技术的不断发展\",{\"1\":{\"69\":1}}],[\"开始接受订阅请求\",{\"1\":{\"145\":1}}],[\"开始还有人听听他们的警钟\",{\"1\":{\"126\":1}}],[\"开心的游戏玩久些\",{\"1\":{\"128\":1}}],[\"开闭原则\",{\"1\":{\"81\":1}}],[\"开闭原则的基础\",{\"1\":{\"73\":1}}],[\"长期抗战\",{\"1\":{\"125\":1}}],[\"热爱你选择的行业\",{\"1\":{\"125\":1}}],[\"独立的判断能力\",{\"1\":{\"125\":1}}],[\"独立思维和自信\",{\"1\":{\"124\":1}}],[\"评价自己\",{\"1\":{\"125\":1}}],[\"诚实地面对自己\",{\"1\":{\"125\":1}}],[\"忽略对你不利的信息\",{\"1\":{\"125\":1}}],[\"赚大钱\",{\"1\":{\"125\":1}}],[\"严格按照这个计划实行\",{\"1\":{\"125\":1}}],[\"获得炒股的基本知识\",{\"1\":{\"125\":1}}],[\"获取汽车享元\",{\"1\":{\"94\":2}}],[\"获取单例实例\",{\"1\":{\"87\":1}}],[\"获取单例实例的方法\",{\"1\":{\"87\":1}}],[\"获取各字段值\",{\"1\":{\"18\":1}}],[\"价格的变动不是随机的\",{\"1\":{\"124\":1}}],[\"尊重自己的直觉\",{\"1\":{\"124\":1}}],[\"耐心\",{\"1\":{\"124\":1}}],[\"耐心地等待盈利的时刻\",{\"1\":{\"118\":1}}],[\"耐心地观察市场\",{\"1\":{\"116\":1}}],[\"风险控制\",{\"1\":{\"124\":1}}],[\"找一个方法\",{\"1\":{\"124\":1}}],[\"找出公司的所有资料\",{\"1\":{\"124\":1}}],[\"胜算\",{\"1\":{\"124\":1}}],[\"检查sys\",{\"1\":{\"221\":1}}],[\"检查你买卖的动机\",{\"1\":{\"124\":1}}],[\"检查的责任链\",{\"1\":{\"97\":1}}],[\"确认接受订阅\",{\"1\":{\"149\":1}}],[\"确认\",{\"1\":{\"137\":1,\"141\":1}}],[\"确定你对炒手生涯感兴趣\",{\"1\":{\"124\":1}}],[\"确保你已经安装了指定版本的python解释器\",{\"1\":{\"222\":1}}],[\"确保在重写方法时与超类中的版本兼容是很重要的\",{\"1\":{\"81\":1}}],[\"确保新行为与基类中的版本兼容意味着你需要保持方法的签名\",{\"1\":{\"81\":1}}],[\"确保每个\",{\"1\":{\"19\":1}}],[\"坐着不动\",{\"1\":{\"124\":1}}],[\"专\",{\"1\":{\"126\":1}}],[\"专家\",{\"1\":{\"126\":1}}],[\"专家推荐\",{\"1\":{\"120\":1}}],[\"专心于你了解最多的行业\",{\"1\":{\"124\":1}}],[\"永远持有一部分现金\",{\"1\":{\"124\":1}}],[\"9\",{\"1\":{\"124\":2}}],[\"研究税务情况\",{\"1\":{\"124\":1}}],[\"看看有什么新的发展可能改变你的想法\",{\"1\":{\"124\":1}}],[\"看不见\",{\"1\":{\"118\":1}}],[\"定期推送事件\",{\"1\":{\"145\":1}}],[\"定期有计划地检查你的投资\",{\"1\":{\"124\":1}}],[\"定义runnables\",{\"0\":{\"242\":1}}],[\"定义是为变量分配内存空间或者实现函数本体\",{\"1\":{\"176\":1}}],[\"定义的一种基于\",{\"1\":{\"133\":1}}],[\"定义策略接口\",{\"1\":{\"104\":1}}],[\"定义所有支持的算法的公共接口\",{\"1\":{\"104\":1}}],[\"定义状态接口\",{\"1\":{\"103\":1}}],[\"定义主题接口\",{\"1\":{\"102\":1}}],[\"定义观察者接口\",{\"1\":{\"102\":1}}],[\"定义在接收到通知时的行为\",{\"1\":{\"102\":1}}],[\"定义一个接口\",{\"1\":{\"103\":1}}],[\"定义一个接口用于与各同事对象之间的通信\",{\"1\":{\"100\":1}}],[\"定义一个更新接口\",{\"1\":{\"102\":1}}],[\"定义备忘录结构体\",{\"1\":{\"101\":1}}],[\"定义具体中介者\",{\"1\":{\"100\":1}}],[\"定义具体同事类\",{\"1\":{\"100\":2}}],[\"定义具体命令\",{\"1\":{\"98\":2}}],[\"定义同事类接口\",{\"1\":{\"100\":1}}],[\"定义中介者接口\",{\"1\":{\"100\":1}}],[\"定义创建迭代器对象的接口\",{\"1\":{\"99\":1}}],[\"定义访问和遍历元素的接口\",{\"1\":{\"99\":1}}],[\"定义调用者\",{\"1\":{\"98\":1}}],[\"定义接收者\",{\"1\":{\"98\":1}}],[\"定义命令接口\",{\"1\":{\"98\":1}}],[\"定义执行命令的接口\",{\"1\":{\"98\":1}}],[\"定义处理请求的接口\",{\"1\":{\"97\":1}}],[\"定义汽车状态结构体\",{\"1\":{\"101\":1}}],[\"定义汽车品牌枚举\",{\"1\":{\"94\":1}}],[\"定义汽车颜色枚举\",{\"1\":{\"94\":1}}],[\"定义汽车经销商结构体\",{\"1\":{\"93\":1}}],[\"定义汽车工厂结构体\",{\"1\":{\"93\":1}}],[\"定义汽车装饰函数\",{\"1\":{\"92\":1}}],[\"定义汽车装饰结构体\",{\"1\":{\"92\":1}}],[\"定义汽车结构体\",{\"1\":{\"92\":1,\"93\":1,\"94\":1,\"101\":1,\"103\":1,\"104\":1}}],[\"定义汽车类型枚举\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":1}}],[\"定义组合节点\",{\"1\":{\"91\":1}}],[\"定义组件接口\",{\"1\":{\"91\":1}}],[\"定义叶子节点\",{\"1\":{\"91\":1}}],[\"定义对象的接口\",{\"1\":{\"91\":1}}],[\"定义实现接口\",{\"1\":{\"90\":1}}],[\"定义高层接口\",{\"1\":{\"90\":1}}],[\"定义适配器结构体\",{\"1\":{\"89\":1}}],[\"定义传统燃油汽车接口\",{\"1\":{\"89\":1}}],[\"定义电动汽车接口\",{\"1\":{\"89\":1}}],[\"定义\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"定义了对每个具体元素类\",{\"1\":{\"106\":1}}],[\"定义了汽车制造过程的骨架\",{\"1\":{\"105\":1}}],[\"定义了汽车的状态接口\",{\"1\":{\"103\":1}}],[\"定义了算法的骨架\",{\"1\":{\"105\":1}}],[\"定义了\",{\"1\":{\"104\":1}}],[\"定义了在接收到通知时的行为\",{\"1\":{\"102\":1}}],[\"定义了更新方法\",{\"1\":{\"102\":1}}],[\"定义了注册\",{\"1\":{\"102\":1}}],[\"定义了遍历方法\",{\"1\":{\"99\":1}}],[\"定义了执行命令和撤销命令的接口\",{\"1\":{\"98\":1}}],[\"定义了处理请求的接口inspect\",{\"1\":{\"97\":1}}],[\"定义了一个接收访问者对象的\",{\"1\":{\"106\":1}}],[\"定义了一个算法的骨架\",{\"1\":{\"105\":1}}],[\"定义了一个通知方法\",{\"1\":{\"100\":1}}],[\"定义了一个具体的对象\",{\"1\":{\"92\":1}}],[\"定义了一个对象接口\",{\"1\":{\"92\":1}}],[\"定义了一个创建产品的接口\",{\"1\":{\"83\":1}}],[\"定义了统一的接口\",{\"1\":{\"91\":1}}],[\"定义了sedan和suv\",{\"1\":{\"90\":1}}],[\"定义了car\",{\"1\":{\"90\":1}}],[\"定义了carsystem接口\",{\"1\":{\"90\":1}}],[\"定义了androidauto和applecarplay\",{\"1\":{\"90\":1}}],[\"定义了产品的共性\",{\"1\":{\"83\":1,\"84\":1}}],[\"定义了应用程序的整体结构和行为\",{\"1\":{\"81\":1}}],[\"定义了通信速率为\",{\"1\":{\"28\":2}}],[\"定义了该组件与外界的交互边界\",{\"1\":{\"3\":1}}],[\"越快止损越好\",{\"1\":{\"124\":1}}],[\"越小越好\",{\"1\":{\"123\":1}}],[\"学习快速干净地止损\",{\"1\":{\"124\":1}}],[\"竞争者\",{\"1\":{\"124\":1}}],[\"堂\",{\"1\":{\"124\":1}}],[\"美容师还是餐馆跑\",{\"1\":{\"124\":1}}],[\"事件推送周期性发送\",{\"1\":{\"141\":1}}],[\"事件的改变又反过来改变想法\",{\"1\":{\"124\":1}}],[\"事件处理系统\",{\"1\":{\"102\":1}}],[\"反馈理论\",{\"1\":{\"124\":1}}],[\"反之如果大多数股民不看好股市\",{\"1\":{\"118\":1}}],[\"索罗斯认为这一理论根本就是错的\",{\"1\":{\"124\":1}}],[\"索罗斯建议投资研究越简化越好\",{\"1\":{\"124\":1}}],[\"市场是愚蠢的\",{\"1\":{\"124\":1}}],[\"市场从来不会错\",{\"1\":{\"124\":1}}],[\"离开市场\",{\"1\":{\"124\":1}}],[\"离场\",{\"1\":{\"124\":1}}],[\"他自己提出了\",{\"1\":{\"124\":1}}],[\"他自己从不在经济研究上花大量的时间\",{\"1\":{\"124\":1}}],[\"他列出下面几点作为选择公司的参考\",{\"1\":{\"124\":1}}],[\"他相信以下的六点素质是必备的\",{\"1\":{\"124\":1}}],[\"他们指出这个泡沫会破碎\",{\"1\":{\"126\":1}}],[\"他们知道利润会随之而来\",{\"1\":{\"124\":1}}],[\"他们在乎在正确时间做正确的事\",{\"1\":{\"124\":1}}],[\"他们想买进的股票要么静悄悄地\",{\"1\":{\"120\":1}}],[\"他们也知道春天是播种的时机\",{\"1\":{\"118\":1}}],[\"他们都已经脱手出场\",{\"1\":{\"118\":1}}],[\"他们有个共性\",{\"1\":{\"118\":1}}],[\"他们太聪明\",{\"1\":{\"111\":1}}],[\"跟着股市走\",{\"1\":{\"124\":1}}],[\"知道\",{\"1\":{\"124\":1}}],[\"知易行难\",{\"1\":{\"118\":1}}],[\"另寻机会\",{\"1\":{\"124\":1}}],[\"另一方面\",{\"1\":{\"171\":1}}],[\"另一方面是报复赌场\",{\"1\":{\"111\":1}}],[\"另一个是未来盈利\",{\"1\":{\"117\":1}}],[\"纸面有利润了\",{\"1\":{\"124\":1}}],[\"纸面上没有利润的话不要加码\",{\"1\":{\"124\":1}}],[\"别把痛苦带回家\",{\"1\":{\"128\":1}}],[\"别想着在股市赚钱\",{\"1\":{\"128\":1}}],[\"别进第二手\",{\"1\":{\"124\":1}}],[\"别买太多股票\",{\"1\":{\"124\":1}}],[\"别买任何股票\",{\"1\":{\"117\":1}}],[\"别希望自己每次都正确\",{\"1\":{\"124\":1}}],[\"别试着在最低点买股\",{\"1\":{\"124\":1}}],[\"别爱上任何股票\",{\"1\":{\"124\":1}}],[\"别将股市当成是赚钱的地方\",{\"1\":{\"128\":1}}],[\"别将\",{\"1\":{\"124\":1}}],[\"别跟朋友走\",{\"1\":{\"124\":1}}],[\"别让利润变成亏损\",{\"1\":{\"124\":1}}],[\"别频繁交易\",{\"1\":{\"124\":1}}],[\"忘掉你的入场价\",{\"1\":{\"124\":1}}],[\"逐渐将留意的股票增加到十至十五只\",{\"1\":{\"124\":1}}],[\"止损\",{\"1\":{\"124\":3}}],[\"时\",{\"1\":{\"171\":2}}],[\"时无效\",{\"1\":{\"149\":1}}],[\"时刻牢记\",{\"1\":{\"124\":1}}],[\"时间一久\",{\"1\":{\"118\":1}}],[\"拿了再说\",{\"1\":{\"123\":1}}],[\"今天的最高价是11元\",{\"1\":{\"123\":1}}],[\"今信息安全服务\",{\"1\":{\"46\":1}}],[\"亏损是游戏的一部分\",{\"1\":{\"124\":1}}],[\"亏小钱\",{\"1\":{\"123\":1}}],[\"亏钱时\",{\"1\":{\"111\":1}}],[\"寻找临界点的过程便是你的学股过程\",{\"1\":{\"122\":1}}],[\"临界点\",{\"1\":{\"122\":1}}],[\"卖股票的点也是\",{\"1\":{\"122\":1}}],[\"留意市场提供的危险信号\",{\"1\":{\"121\":1}}],[\"留意每天的交易总量\",{\"1\":{\"117\":1}}],[\"训练自己的耐性\",{\"1\":{\"121\":1}}],[\"形成自己的风格模式\",{\"1\":{\"121\":1}}],[\"形成中间层次的组件\",{\"1\":{\"81\":1}}],[\"怎样找最有潜力的股票\",{\"1\":{\"121\":1}}],[\"龙头\",{\"1\":{\"121\":1}}],[\"选好\",{\"1\":{\"121\":1}}],[\"选择股票的步骤\",{\"0\":{\"121\":1}}],[\"选择临界点\",{\"1\":{\"120\":1}}],[\"选择太多\",{\"1\":{\"111\":1}}],[\"选择合适的代理模式\",{\"1\":{\"95\":1}}],[\"牛市\",{\"1\":{\"121\":1}}],[\"牛劲\",{\"1\":{\"121\":4}}],[\"哪些类别的股票\",{\"1\":{\"121\":1}}],[\"安装\",{\"0\":{\"214\":1}}],[\"安坐不\",{\"1\":{\"121\":1}}],[\"安全问题\",{\"1\":{\"86\":1}}],[\"讲白了\",{\"1\":{\"120\":1}}],[\"突破阻力线才可以认为股票的运动进入新的阶段\",{\"1\":{\"120\":1}}],[\"突破阻力线的现象并没有很大意义\",{\"1\":{\"120\":1}}],[\"突出了模板方法在实际项目中的应用\",{\"1\":{\"105\":1}}],[\"除非你撒谎\",{\"1\":{\"124\":1}}],[\"除非你能将炒股当成全时工作\",{\"1\":{\"124\":1}}],[\"除非大户真的认为该股有潜力\",{\"1\":{\"120\":1}}],[\"除了熬和交学费外\",{\"1\":{\"129\":1}}],[\"除了股票在升的理由之外\",{\"1\":{\"116\":1}}],[\"除了将原始对象的数据复制到克隆体中之外\",{\"1\":{\"86\":1}}],[\"短线操作的资金都是热钱\",{\"1\":{\"120\":1}}],[\"短帧结构\",{\"1\":{\"29\":1}}],[\"好的交易方法应毫不费力\",{\"1\":{\"124\":1}}],[\"好消息\",{\"1\":{\"120\":1}}],[\"好莱坞原则是一种设计原则\",{\"1\":{\"81\":1}}],[\"好莱坞原则\",{\"1\":{\"81\":2}}],[\"绝不要在跌势时入市\",{\"1\":{\"120\":1}}],[\"准备开始升势的时候买入\",{\"1\":{\"120\":1}}],[\"准备玩全世界最刺激的游戏并要成为专家时\",{\"1\":{\"111\":1}}],[\"办\",{\"1\":{\"120\":1}}],[\"切记照\",{\"1\":{\"120\":1}}],[\"切换到启动状态\",{\"1\":{\"103\":1}}],[\"切换到停止状态\",{\"1\":{\"103\":2}}],[\"切换到行驶状态\",{\"1\":{\"103\":1}}],[\"搞清楚你最多愿亏多少钱\",{\"1\":{\"120\":1}}],[\"先行广播服务\",{\"1\":{\"134\":1}}],[\"先定好止损点\",{\"1\":{\"120\":1}}],[\"先搞清游戏的规则\",{\"1\":{\"111\":1}}],[\"第\",{\"1\":{\"206\":1}}],[\"第八\",{\"1\":{\"120\":1}}],[\"第七\",{\"1\":{\"120\":1}}],[\"第六\",{\"1\":{\"120\":1,\"124\":1}}],[\"第五\",{\"1\":{\"120\":1,\"124\":1}}],[\"第四\",{\"1\":{\"120\":1,\"124\":1}}],[\"第三点怎么办\",{\"1\":{\"121\":1}}],[\"第三\",{\"1\":{\"120\":1,\"121\":1,\"124\":1,\"125\":1}}],[\"第三种是can收发器也集成到微控制器中\",{\"1\":{\"31\":1}}],[\"第二\",{\"1\":{\"120\":1,\"121\":1,\"124\":2,\"125\":1}}],[\"第一损失往往是代价最小的损失\",{\"1\":{\"128\":1}}],[\"第一次入场后\",{\"1\":{\"124\":1}}],[\"第一\",{\"1\":{\"120\":1,\"121\":1,\"124\":2,\"125\":1}}],[\"阻力线和支撑线的操作\",{\"1\":{\"119\":1}}],[\"假如这是一个正常的升势\",{\"1\":{\"119\":1}}],[\"假设一个字节等于\",{\"1\":{\"194\":1}}],[\"假设我们要设计一个汽车制造的程序\",{\"1\":{\"105\":1}}],[\"假设我们要设计一个汽车应用程序\",{\"1\":{\"90\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1}}],[\"假设我们正在设计一个图形界面库\",{\"1\":{\"81\":1}}],[\"假设你正在开发一个web应用程序\",{\"1\":{\"81\":1}}],[\"假设有一个动物园程序\",{\"1\":{\"81\":1}}],[\"操作意图\",{\"1\":{\"157\":1}}],[\"操作技巧\",{\"1\":{\"119\":1}}],[\"操作系统\",{\"1\":{\"46\":1}}],[\"说明\",{\"1\":{\"136\":1}}],[\"说到底\",{\"1\":{\"119\":1}}],[\"说的全面些\",{\"1\":{\"111\":1}}],[\"买什么股票有同样的分量\",{\"1\":{\"120\":1}}],[\"买股的时机固然重要\",{\"1\":{\"120\":1}}],[\"买股票的依据主要是三点\",{\"1\":{\"119\":1}}],[\"买入的要点归纳\",{\"0\":{\"120\":1}}],[\"买点的最最重要点是选择止损点\",{\"1\":{\"119\":1}}],[\"之后\",{\"1\":{\"151\":1}}],[\"之说的\",{\"1\":{\"118\":1}}],[\"之间的交互\",{\"1\":{\"100\":1}}],[\"之间传输数据的线\",{\"1\":{\"28\":1}}],[\"预想在什么情况下今天的情形会停滞甚或产生逆转\",{\"1\":{\"118\":1}}],[\"往往不是没有耐心\",{\"1\":{\"118\":1}}],[\"苦工\",{\"1\":{\"118\":1}}],[\"何时卖股票\",{\"0\":{\"122\":1}}],[\"何为大多数股民看好大市或大多数股民不看好大市是很难计量的\",{\"1\":{\"118\":1}}],[\"何以一般股民败多胜少\",{\"1\":{\"111\":1}}],[\"钱亏掉不可怕\",{\"1\":{\"118\":1}}],[\"再加码\",{\"1\":{\"124\":1}}],[\"再忍一忍\",{\"1\":{\"118\":1}}],[\"再忍下去的毅力\",{\"1\":{\"118\":1}}],[\"再次改变汽车状态\",{\"1\":{\"102\":1}}],[\"再次模拟请求\",{\"1\":{\"95\":1}}],[\"缺少锲而不舍的精神\",{\"1\":{\"118\":1}}],[\"缺点是可能会增加系统的复杂度和降低系统的性能\",{\"1\":{\"93\":1}}],[\"缺点是增加了代码的复杂度和降低了代码的性能\",{\"1\":{\"89\":1}}],[\"缺点是增加了系统的复杂度和可能会导致类的数量过多\",{\"1\":{\"83\":1}}],[\"缺点是违反单一职责原则\",{\"1\":{\"87\":1}}],[\"缺点是内存消耗\",{\"1\":{\"86\":1}}],[\"缺点是复杂性和性能问题\",{\"1\":{\"85\":1}}],[\"缺点\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"受过良好教育但成日感叹怀才不遇的人\",{\"1\":{\"118\":1}}],[\"受干扰概率低\",{\"1\":{\"29\":1}}],[\"白日梦不是欲望是梦\",{\"1\":{\"118\":1}}],[\"欲望必须由努力做基础\",{\"1\":{\"118\":1}}],[\"会怎样\",{\"0\":{\"208\":1}}],[\"会周期性重发\",{\"1\":{\"154\":1}}],[\"会立即发送\",{\"1\":{\"154\":1}}],[\"会在启动阶段快速多次发送\",{\"1\":{\"153\":1}}],[\"会错的只有人自己\",{\"1\":{\"118\":1}}],[\"会导致类的数量增加\",{\"1\":{\"104\":1}}],[\"华尔街有个说法\",{\"1\":{\"128\":1}}],[\"华尔街有过调查\",{\"1\":{\"116\":1}}],[\"华尔街家训\",{\"0\":{\"124\":1}}],[\"华尔街曾经对一般的股民做过调查\",{\"1\":{\"118\":1}}],[\"华尔街将这条线称为\",{\"1\":{\"118\":1}}],[\"完全决定于你自己的经验\",{\"1\":{\"118\":1}}],[\"完成订阅后其功能由订阅续期机制替代\",{\"1\":{\"154\":1}}],[\"完成了订阅并进入\",{\"1\":{\"154\":1}}],[\"完成了制造过程中的具体步骤\",{\"1\":{\"105\":1}}],[\"完成对具体元素的操作\",{\"1\":{\"106\":1}}],[\"完成算法中特定步骤的具体实现\",{\"1\":{\"105\":1}}],[\"至于你怎么知道有60\",{\"1\":{\"118\":1}}],[\"摸不着的股票使一般人的判断力走了样\",{\"1\":{\"118\":1}}],[\"把调用者的栈帧基址压入栈中\",{\"1\":{\"207\":1}}],[\"把钱存银行不是赌\",{\"1\":{\"127\":1}}],[\"把炒股当成业余消遣\",{\"1\":{\"125\":1}}],[\"把\",{\"1\":{\"118\":1}}],[\"把图2\",{\"1\":{\"117\":1}}],[\"追求卓越\",{\"1\":{\"118\":1}}],[\"败而不倒\",{\"1\":{\"118\":1}}],[\"么投机的原理是什么呢\",{\"1\":{\"118\":1}}],[\"互联网公司属于信息社会的产业\",{\"1\":{\"117\":1}}],[\"综合指数有时会被几只大股票糊弄\",{\"1\":{\"117\":1}}],[\"综合看图\",{\"0\":{\"117\":1}}],[\"逆大潮流而动\",{\"1\":{\"117\":1}}],[\"判断大市走向是极其重要的\",{\"1\":{\"117\":1}}],[\"马克思的政治经济学主要目的便是解决不断重复的资本广义经济周期对社会负面的影响\",{\"1\":{\"117\":1}}],[\"道氏理论特点指出这一点\",{\"1\":{\"117\":1}}],[\"便于调试\",{\"1\":{\"182\":1}}],[\"便于扩展\",{\"1\":{\"86\":1,\"91\":1}}],[\"便是好的买入点\",{\"1\":{\"119\":1}}],[\"便是不正常运动\",{\"1\":{\"117\":1}}],[\"便必须按兵不动\",{\"1\":{\"118\":1}}],[\"便反调不应该跌到阻力线之下\",{\"1\":{\"117\":1}}],[\"平衡性能和编译速度\",{\"1\":{\"182\":1}}],[\"平均线\",{\"1\":{\"116\":1}}],[\"平行继承体系\",{\"1\":{\"81\":1}}],[\"支撑线和阻力线\",{\"1\":{\"116\":1,\"117\":1}}],[\"支持事件组订阅与\",{\"1\":{\"134\":1}}],[\"支持撤销操作\",{\"1\":{\"101\":1}}],[\"支持撤销和重做\",{\"1\":{\"98\":1}}],[\"支持不同的遍历方式\",{\"1\":{\"99\":1}}],[\"支持多种遍历方式\",{\"1\":{\"99\":1}}],[\"支持多任务并行处理\",{\"1\":{\"45\":1}}],[\"支持拓展\",{\"1\":{\"73\":1}}],[\"支持基于敏捷的开发过程\",{\"1\":{\"45\":1}}],[\"支持功能安全和信息安全\",{\"1\":{\"45\":1}}],[\"支持采用c++作为应用软件的编程语言\",{\"1\":{\"45\":1}}],[\"支持结构字段连接\",{\"1\":{\"22\":1}}],[\"支持\",{\"0\":{\"15\":1},\"1\":{\"134\":2,\"207\":1}}],[\"记住\",{\"1\":{\"124\":1}}],[\"记住这些要点及点点照办\",{\"1\":{\"120\":1}}],[\"记住你不可能每次正确\",{\"1\":{\"120\":1}}],[\"记住如果这是升势开始的话\",{\"1\":{\"117\":1}}],[\"记住股民买卖股票的真正原因\",{\"1\":{\"116\":1}}],[\"记录日志以及支持撤销和重做操作的场景\",{\"1\":{\"98\":1}}],[\"记录日志以及撤销操作\",{\"1\":{\"98\":1}}],[\"记录日志和事务操作\",{\"1\":{\"98\":1}}],[\"记录日志\",{\"1\":{\"95\":1}}],[\"跌时跌到惨不忍睹的原因了吧\",{\"1\":{\"116\":1}}],[\"现在\",{\"1\":{\"222\":1}}],[\"现在你能体会到为什么股票升时常常升得离谱\",{\"1\":{\"116\":1}}],[\"现代系统如\",{\"1\":{\"206\":1}}],[\"现代系统继续采用此设计\",{\"1\":{\"205\":1}}],[\"现代计算机中\",{\"1\":{\"199\":1}}],[\"现代汽车越来越多地采用电子装置控制\",{\"1\":{\"27\":1}}],[\"现金值\",{\"1\":{\"117\":1}}],[\"现金值法\",{\"1\":{\"117\":1}}],[\"现今流行的企业评估标尺如本利比\",{\"1\":{\"117\":1}}],[\"要生成代码\",{\"1\":{\"244\":1}}],[\"要完全定义端口接口\",{\"1\":{\"240\":1}}],[\"要订阅的事件组\",{\"1\":{\"147\":1}}],[\"要有自知之明\",{\"1\":{\"124\":1}}],[\"要有应用知识的毅力\",{\"1\":{\"118\":1}}],[\"要在投资领域成功\",{\"1\":{\"124\":1}}],[\"要甘于做孤独者\",{\"1\":{\"118\":1}}],[\"要么想法引起大众的恐慌性抛售\",{\"1\":{\"120\":1}}],[\"要么下一点\",{\"1\":{\"118\":1}}],[\"要么上一下\",{\"1\":{\"118\":1}}],[\"要得到股票的现金值需要2个假设\",{\"1\":{\"117\":1}}],[\"要确定大市的走向\",{\"1\":{\"117\":1}}],[\"要想学习养成对股票运动的感觉\",{\"1\":{\"116\":1}}],[\"要往上推\",{\"1\":{\"116\":1}}],[\"升\",{\"1\":{\"116\":2}}],[\"滚\",{\"1\":{\"116\":1}}],[\"影响可维护性\",{\"1\":{\"210\":1}}],[\"影响投资者决定的最重要因素是对未来的预期\",{\"1\":{\"116\":1}}],[\"影响股票的三个因素\",{\"0\":{\"115\":1}}],[\"波谷也较上一波谷为低\",{\"1\":{\"116\":1}}],[\"典型的跌势图\",{\"1\":{\"116\":1}}],[\"交易量通常增大\",{\"1\":{\"117\":1}}],[\"交易量没有特别之处\",{\"1\":{\"116\":1}}],[\"交易量减少\",{\"1\":{\"116\":1}}],[\"交易量增加\",{\"1\":{\"116\":1}}],[\"请注意\",{\"1\":{\"195\":1}}],[\"请注意交易量的变化\",{\"1\":{\"116\":1}}],[\"请读者自己思考一下其中的原由\",{\"1\":{\"120\":1}}],[\"请读者切切牢记\",{\"1\":{\"119\":1}}],[\"请求订阅事件组\",{\"1\":{\"149\":1}}],[\"请求的发送者和接收者需要解耦\",{\"1\":{\"98\":1}}],[\"请求数据或服务\",{\"1\":{\"5\":1}}],[\"请求\",{\"1\":{\"3\":1}}],[\"品牌的价值\",{\"1\":{\"114\":1}}],[\"品牌等\",{\"1\":{\"94\":1}}],[\"固定资产值等等是用来评估工业社会企业的\",{\"1\":{\"117\":1}}],[\"固定资产\",{\"1\":{\"114\":1}}],[\"盈利的增长\",{\"1\":{\"115\":1}}],[\"盈利\",{\"1\":{\"114\":1}}],[\"营业收入\",{\"1\":{\"114\":1}}],[\"政府的产业政策\",{\"1\":{\"113\":1}}],[\"政治环境\",{\"1\":{\"113\":1}}],[\"80\",{\"1\":{\"118\":1}}],[\"8\",{\"1\":{\"113\":1,\"124\":2,\"187\":1,\"194\":1,\"195\":5,\"199\":1,\"203\":2,\"207\":1,\"209\":1}}],[\"7版本\",{\"1\":{\"222\":1}}],[\"75元买进股票\",{\"1\":{\"123\":1}}],[\"7\",{\"0\":{\"244\":1},\"1\":{\"113\":1,\"124\":2,\"206\":1}}],[\"64\",{\"1\":{\"187\":1,\"199\":1,\"206\":1,\"207\":1}}],[\"6\",{\"0\":{\"243\":1},\"1\":{\"113\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"187\":1,\"206\":1}}],[\"经济史的演绎从不基于真实的剧本\",{\"1\":{\"126\":1}}],[\"经济史是一部基于假象和谎言的连续剧\",{\"1\":{\"126\":1}}],[\"经济周期\",{\"1\":{\"113\":1}}],[\"经济模式\",{\"1\":{\"104\":1}}],[\"5s\",{\"1\":{\"147\":1}}],[\"5\",{\"0\":{\"242\":1},\"1\":{\"113\":1,\"114\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"149\":1,\"153\":1,\"167\":1,\"206\":1}}],[\"50天平均线来衡量中期走势\",{\"1\":{\"116\":1}}],[\"50\",{\"1\":{\"89\":1,\"101\":1,\"102\":1}}],[\"银根松紧\",{\"1\":{\"113\":1}}],[\"税收\",{\"1\":{\"113\":1}}],[\"利率\",{\"1\":{\"113\":1}}],[\"大钱只存在大势之内\",{\"1\":{\"124\":1}}],[\"大钱不存在于股票的日常小波动\",{\"1\":{\"124\":1}}],[\"大户的花招其实明显的很\",{\"1\":{\"120\":1}}],[\"大多数人注重于今天发生的一切并假设今天发生的一切会不断延续\",{\"1\":{\"118\":1}}],[\"大市不好时\",{\"1\":{\"117\":1}}],[\"大的政治动乱和经济震荡当然例外\",{\"1\":{\"114\":1}}],[\"大环境的变化是谈天的好材料\",{\"1\":{\"114\":1}}],[\"大环境\",{\"0\":{\"113\":1}}],[\"大话设计模式\",{\"1\":{\"107\":1}}],[\"报错\",{\"0\":{\"167\":1},\"2\":{\"169\":1}}],[\"报复赌场让他们亏钱\",{\"1\":{\"111\":1}}],[\"报文的发送时机\",{\"0\":{\"153\":1}}],[\"报文在\",{\"1\":{\"149\":1}}],[\"报文在实际通信中支持的行为类型\",{\"1\":{\"149\":1}}],[\"报文类型\",{\"1\":{\"149\":1}}],[\"报文类型概览\",{\"0\":{\"149\":1}}],[\"报文中的行为由\",{\"1\":{\"149\":1}}],[\"报文\",{\"1\":{\"146\":1,\"152\":1,\"153\":1,\"154\":2}}],[\"报文会在不同阶段以不同频率发送\",{\"1\":{\"143\":1}}],[\"报文可以被所有节点同时接收\",{\"1\":{\"29\":1}}],[\"报文标识符在网络中是唯一的\",{\"1\":{\"29\":1}}],[\"句话\",{\"1\":{\"111\":1}}],[\"想有这样的判断力\",{\"1\":{\"129\":1}}],[\"想在股市谋生\",{\"1\":{\"129\":1}}],[\"想法改变了事件\",{\"1\":{\"124\":1}}],[\"想像你的对手是谁\",{\"1\":{\"120\":1}}],[\"想\",{\"1\":{\"111\":1}}],[\"虚拟环境可以使用其二进制目录\",{\"1\":{\"221\":1}}],[\"虚拟代理\",{\"1\":{\"95\":1}}],[\"虚荣心及权力的幻\",{\"1\":{\"111\":1}}],[\"股价很高了\",{\"1\":{\"124\":1}}],[\"股价很低了\",{\"1\":{\"124\":1}}],[\"股价却不升\",{\"1\":{\"123\":1}}],[\"股价慢慢地一步步升高\",{\"1\":{\"120\":1}}],[\"股\",{\"1\":{\"121\":1}}],[\"股势\",{\"1\":{\"118\":1}}],[\"股票将节节升高\",{\"1\":{\"126\":1}}],[\"股票从来就没有太高了不能买或太低了不能卖这回事\",{\"1\":{\"124\":1}}],[\"股票从来不是恒定不动的\",{\"1\":{\"118\":1}}],[\"股票开始上升\",{\"1\":{\"123\":1}}],[\"股票已升了一大截的情况下\",{\"1\":{\"120\":1}}],[\"股票已跌了很低了\",{\"1\":{\"120\":1}}],[\"股票大市的重要性的\",{\"1\":{\"117\":1}}],[\"股票应往下跌\",{\"1\":{\"117\":1}}],[\"股票应该继续上升\",{\"1\":{\"117\":1}}],[\"股票短期的运动方向我注重股价及交易量\",{\"1\":{\"116\":1}}],[\"股票的升势还在继续\",{\"1\":{\"124\":1}}],[\"股票的运动有点像推石球上山\",{\"1\":{\"116\":1}}],[\"股票的走势及走势线\",{\"0\":{\"116\":1}}],[\"股票的迷惑性不在于股票所基于的价值\",{\"1\":{\"111\":1}}],[\"股市从来都不错\",{\"1\":{\"118\":1}}],[\"股市操纵可能改变每天的或短期的波动\",{\"1\":{\"117\":1}}],[\"股市没有即定的运行准则\",{\"1\":{\"111\":1}}],[\"股市这一恒久的赌局却要求你每时每刻都要做理性的决定且为决定的结果负全部的责任\",{\"1\":{\"111\":1}}],[\"贪\",{\"1\":{\"111\":1}}],[\"赶潮跟风\",{\"1\":{\"111\":1}}],[\"急着发财\",{\"1\":{\"111\":1}}],[\"讨厌风险\",{\"1\":{\"111\":1}}],[\"就算进价较你第一次进价为低也没有关系\",{\"1\":{\"124\":1}}],[\"就是这些永远不变的人性\",{\"1\":{\"111\":1}}],[\"就可以创建新的产品对象\",{\"1\":{\"83\":1}}],[\"人性使然\",{\"1\":{\"111\":1}}],[\"那还不算我业余炒股的经验及金融硕士的知识背景\",{\"1\":{\"125\":1}}],[\"那就是\",{\"1\":{\"111\":1}}],[\"那么股市的继续下跌区间也已不大\",{\"1\":{\"118\":1}}],[\"那么使用享元模式可以提高程序的性能\",{\"1\":{\"94\":1}}],[\"那么使用享元模式可以减少内存的占用\",{\"1\":{\"94\":2}}],[\"那么使用享元模式可能会导致性能下降\",{\"1\":{\"94\":1}}],[\"那么可以扩大战果\",{\"1\":{\"124\":1}}],[\"那么可以使用原型模式来减少对象的创建和销毁次数\",{\"1\":{\"86\":1}}],[\"那么可以使用原型模式来避免重复创建对象的开销\",{\"1\":{\"86\":1}}],[\"那么可以使用原型模式来提高创建对象的效率\",{\"1\":{\"86\":1}}],[\"那么可能会导致工厂类和产品类的数量过多\",{\"1\":{\"83\":1}}],[\"那么在克隆原型对象时\",{\"1\":{\"86\":2}}],[\"那么\",{\"1\":{\"81\":1}}],[\"小小做\",{\"1\":{\"129\":1}}],[\"小心交易量猛增\",{\"1\":{\"123\":1}}],[\"小结一下何时及怎样卖股票\",{\"0\":{\"123\":1}}],[\"小环境\",{\"0\":{\"114\":1}}],[\"小偷的本事不在偷\",{\"1\":{\"111\":1}}],[\"小白教程\",{\"1\":{\"58\":1}}],[\"面向所有潜在\",{\"1\":{\"153\":1}}],[\"面向接口进行开发\",{\"1\":{\"81\":2}}],[\"面对人为操纵的赌局\",{\"1\":{\"111\":1}}],[\"玩游戏之前\",{\"1\":{\"111\":1}}],[\"朋友\",{\"1\":{\"111\":1}}],[\"我每次赚了大钱\",{\"1\":{\"127\":1}}],[\"我每多进一手都一定较上一手的价格更高\",{\"1\":{\"124\":1}}],[\"我也用了近六年的时间\",{\"1\":{\"125\":1}}],[\"我只在升势的时候买股票\",{\"1\":{\"124\":1}}],[\"我赚到大钱的诀窍不在于我怎么思考\",{\"1\":{\"124\":1}}],[\"我对所有的炒股规则都抱有怀疑\",{\"1\":{\"124\":1}}],[\"我便以10元作为止损点\",{\"1\":{\"123\":1}}],[\"我自己的极限是二十只股票\",{\"1\":{\"124\":1}}],[\"我自己的经验\",{\"1\":{\"119\":1}}],[\"我自己喜欢把止损点定在入市当天的最低点\",{\"1\":{\"123\":1}}],[\"我自己习惯用200天平均线来衡量股票的长期走势\",{\"1\":{\"116\":1}}],[\"我差不多就等于在开赌场\",{\"1\":{\"119\":1}}],[\"我是坚信\",{\"1\":{\"118\":1}}],[\"我以下用数字来描述一遍\",{\"1\":{\"118\":1}}],[\"我通常不买股价在200天平均线下的股票\",{\"1\":{\"116\":1}}],[\"我慢慢感悟这些聪明人失败的原因大约有两个\",{\"1\":{\"111\":1}}],[\"我要给你这样的忠告\",{\"1\":{\"111\":1}}],[\"我希望你能在这本书中找到解决这些问题的答案\",{\"1\":{\"111\":1}}],[\"我们对该代码进行不同等级的编译并测试运行时间\",{\"1\":{\"187\":1}}],[\"我们创建一个主文件main\",{\"1\":{\"178\":1}}],[\"我们创建一个源文件myclass\",{\"1\":{\"178\":1}}],[\"我们创建一个头文件myclass\",{\"1\":{\"178\":1}}],[\"我们创建了一个realcar对象\",{\"1\":{\"95\":1}}],[\"我们创建了一个汽车经销商对象dealer\",{\"1\":{\"93\":1}}],[\"我们创建了一个传统燃油汽车对象gasolinecar\",{\"1\":{\"89\":1}}],[\"我们创建了四个类来表示不同类型的控件和主题样式组合\",{\"1\":{\"81\":1}}],[\"我们的管理将尽量使损失降至最低\",{\"1\":{\"124\":1}}],[\"我们的投资将基于股票的价值而不是股票是否热门\",{\"1\":{\"124\":1}}],[\"我们生活在从工业社会转型到信息社会的关口\",{\"1\":{\"117\":1}}],[\"我们就有了最常见的买入理想点\",{\"1\":{\"117\":1}}],[\"我们展示了如何通过访问者模式来访问不同类型的汽车并执行特定的操作\",{\"1\":{\"106\":1}}],[\"我们可以使用模板方法模式来实现这一设计\",{\"1\":{\"105\":1}}],[\"我们可以将汽车和引擎的关系作为依赖倒置原则的例子\",{\"1\":{\"81\":1}}],[\"我们再次模拟请求\",{\"1\":{\"95\":1}}],[\"我们模拟了一个请求\",{\"1\":{\"95\":1}}],[\"我们在main函数中创建了一个享元工厂\",{\"1\":{\"94\":1}}],[\"我们实现了享元工厂\",{\"1\":{\"94\":1}}],[\"我们通过调用汽车工厂对象的createcar函数来创建汽车对象\",{\"1\":{\"93\":1}}],[\"我们通过适配器对象调用充电方法charge\",{\"1\":{\"89\":1}}],[\"我们定义了汽车颜色和品牌的枚举类型\",{\"1\":{\"94\":1}}],[\"我们定义了两个装饰函数decoratewithgps和decoratewithsunroof\",{\"1\":{\"92\":1}}],[\"我们定义了一个car接口\",{\"1\":{\"95\":1}}],[\"我们定义了一个car结构体来表示汽车的属性\",{\"1\":{\"87\":1}}],[\"我们定义了一个decorator结构体\",{\"1\":{\"92\":1}}],[\"我们定义了一个适配器结构体adapter\",{\"1\":{\"89\":1}}],[\"我们定义了一个传统燃油汽车接口gasolinecarinterface\",{\"1\":{\"89\":1}}],[\"我们定义了一个电动汽车接口electriccarinterface\",{\"1\":{\"89\":1}}],[\"我们定义了一个singleton结构体来表示单例类\",{\"1\":{\"87\":1}}],[\"我们定义了一个具体生成器concretebuilder\",{\"1\":{\"85\":1}}],[\"我们定义了一个生成器接口builder\",{\"1\":{\"85\":1}}],[\"我们定义了一个抽象工厂函数createcar\",{\"1\":{\"83\":1,\"84\":1}}],[\"我们定义了一个汽车工厂结构体carfactory\",{\"1\":{\"93\":1}}],[\"我们定义了一个汽车结构体car\",{\"1\":{\"83\":1,\"85\":1,\"89\":1}}],[\"我们定义了一个汽车类型枚举cartype\",{\"1\":{\"83\":1,\"89\":1}}],[\"我们首先创建了一个carproxy对象\",{\"1\":{\"95\":1}}],[\"我们首先创建了一个具体生成器和一个生成器实例\",{\"1\":{\"85\":1}}],[\"我们首先检查工厂中是否已经存在具有相同颜色和品牌的汽车享元对象\",{\"1\":{\"94\":1}}],[\"我们首先定义了一个car结构体\",{\"1\":{\"92\":1}}],[\"我们调用了传统燃油汽车结构体的加油方法refuel\",{\"1\":{\"89\":1}}],[\"我们调用getsingleton方法获取单例实例\",{\"1\":{\"87\":1}}],[\"我们将传统燃油汽车结构体的指针赋值给适配器结构体中的gasolinecar指针\",{\"1\":{\"89\":1}}],[\"我们将汽车的创建过程封装在抽象工厂函数中\",{\"1\":{\"83\":1}}],[\"我们还定义了一个汽车经销商结构体cardealer\",{\"1\":{\"93\":1}}],[\"我们还定义了一个传统燃油汽车结构体gasolinecar\",{\"1\":{\"89\":1}}],[\"我们还定义了一个电动汽车结构体electriccar\",{\"1\":{\"89\":1}}],[\"我们还定义了一个主管director\",{\"1\":{\"85\":1}}],[\"我们释放了汽车经销商对象\",{\"1\":{\"93\":1}}],[\"我们释放了所有的内存\",{\"1\":{\"85\":1}}],[\"我们释放单例实例所占用的内存\",{\"1\":{\"87\":1}}],[\"我们使用extern关键字在main\",{\"1\":{\"178\":1}}],[\"我们使用策略模式来实现这一点\",{\"1\":{\"104\":1}}],[\"我们使用状态模式来实现这一点\",{\"1\":{\"103\":1}}],[\"我们使用观察者模式来实现这一点\",{\"1\":{\"102\":1}}],[\"我们使用备忘录模式来实现这一点\",{\"1\":{\"101\":1}}],[\"我们使用中介者模式来实现这一点\",{\"1\":{\"100\":1}}],[\"我们使用迭代器模式来遍历这些汽车对象\",{\"1\":{\"99\":1}}],[\"我们使用命令模式来实现这一点\",{\"1\":{\"98\":1}}],[\"我们使用责任链模式来实现这一点\",{\"1\":{\"97\":1}}],[\"我们使用decorate函数调用了装饰对象的装饰函数\",{\"1\":{\"92\":1}}],[\"我们使用createcar函数创建了一个汽车对象\",{\"1\":{\"92\":1}}],[\"我们使用createcar函数创建了三种不同类型的汽车\",{\"1\":{\"83\":1,\"84\":1}}],[\"我们使用组合模式来实现这一点\",{\"1\":{\"91\":1}}],[\"我们使用桥接模式来实现这一点\",{\"1\":{\"90\":1}}],[\"我们使用静态变量instance来存储单例实例\",{\"1\":{\"87\":1}}],[\"我们使用主管的manufacturecar方法创建了一辆汽车\",{\"1\":{\"85\":1}}],[\"我们使用free函数释放了创建的汽车对象所占用的内存\",{\"1\":{\"83\":1,\"84\":1}}],[\"我们使用switch语句根据汽车类型创建具体的汽车对象\",{\"1\":{\"83\":1,\"84\":1}}],[\"我们分别实现了创建轿车\",{\"1\":{\"83\":1,\"84\":1}}],[\"我们希望能够创建不同类型的控件\",{\"1\":{\"81\":1}}],[\"我们需要确保新的\",{\"1\":{\"81\":1}}],[\"我们只需要创建一个新的引擎实现\",{\"1\":{\"81\":1}}],[\"下\",{\"1\":{\"207\":1}}],[\"下表是官方支持的报文类型组合\",{\"1\":{\"149\":1}}],[\"下线切换\",{\"1\":{\"135\":1}}],[\"下注的数额比你有80\",{\"1\":{\"118\":1}}],[\"下调阶段\",{\"1\":{\"116\":1}}],[\"下次要怎么做才能防止亏钱的再次发生\",{\"1\":{\"111\":1}}],[\"下面是一个详细的例子\",{\"1\":{\"178\":1}}],[\"下面是一个使用装饰模式的示例代码\",{\"1\":{\"92\":1}}],[\"下面是一个简单的junit测试用例的示例\",{\"1\":{\"81\":1}}],[\"下面是一个简单的c语言代码示例\",{\"1\":{\"81\":1}}],[\"读书笔记\",{\"0\":{\"110\":1},\"1\":{\"110\":1},\"2\":{\"131\":1}}],[\"改变的能力\",{\"1\":{\"125\":1}}],[\"改变汽车状态\",{\"1\":{\"101\":1,\"102\":1}}],[\"改善既有代码的设计\",{\"1\":{\"107\":1}}],[\"敏捷软件开发\",{\"1\":{\"107\":1}}],[\"重叠管理复杂\",{\"1\":{\"211\":1}}],[\"重排指令以避免流水线冲突\",{\"1\":{\"186\":1}}],[\"重复广播\",{\"1\":{\"145\":1}}],[\"重复来源或混用\",{\"1\":{\"20\":1}}],[\"重构\",{\"1\":{\"107\":1}}],[\"重构与模式\",{\"1\":{\"107\":1}}],[\"破坏封装\",{\"1\":{\"106\":1}}],[\"卡车\",{\"1\":{\"106\":1}}],[\"前端优化\",{\"0\":{\"184\":1},\"1\":{\"183\":1}}],[\"前提\",{\"0\":{\"176\":1}}],[\"前者你会看到交易量增加\",{\"1\":{\"120\":1}}],[\"前置声明\",{\"1\":{\"106\":1}}],[\"前向声明\",{\"1\":{\"103\":1}}],[\"元数据的一个原子数据单元\",{\"0\":{\"240\":1}}],[\"元素\",{\"1\":{\"106\":1}}],[\"元模型\",{\"1\":{\"48\":1}}],[\"访问者模式通过将数据结构与数据操作分离\",{\"1\":{\"106\":1}}],[\"访问者模式可以帮助我们避免在每个元素类中增加新操作\",{\"1\":{\"106\":1}}],[\"访问者模式是一个比较好的选择\",{\"1\":{\"106\":1}}],[\"访问者模式是一种行为型设计模式\",{\"1\":{\"106\":1}}],[\"访问者模式要求访问者对象访问元素的内部状态\",{\"1\":{\"106\":1}}],[\"访问者模式将数据结构与操作分离\",{\"1\":{\"106\":1}}],[\"访问者模式的结构包括以下几个主要组成部分\",{\"1\":{\"106\":1}}],[\"访问者模式的核心思想是将数据结构与数据操作分离\",{\"1\":{\"106\":1}}],[\"访问者模式\",{\"0\":{\"106\":1}}],[\"访问控制和缓存等\",{\"1\":{\"95\":1}}],[\"限制子类的灵活性\",{\"1\":{\"105\":1}}],[\"复杂度增加\",{\"1\":{\"105\":1}}],[\"复杂性增加\",{\"1\":{\"99\":1,\"102\":1}}],[\"复杂性\",{\"1\":{\"85\":1}}],[\"延迟到具体子类实现\",{\"1\":{\"105\":1}}],[\"延迟初始化\",{\"1\":{\"95\":2}}],[\"普通模式\",{\"1\":{\"104\":3}}],[\"策略数目增加\",{\"1\":{\"104\":1}}],[\"策略接口\",{\"1\":{\"104\":2}}],[\"策略模式可以用于实现不同的驾驶模式\",{\"1\":{\"104\":1}}],[\"策略模式通过定义一系列算法\",{\"1\":{\"104\":1}}],[\"策略模式将算法的实现和使用分离\",{\"1\":{\"104\":1}}],[\"策略模式主要包括以下几个部分\",{\"1\":{\"104\":1}}],[\"策略模式使得算法可以独立于使用它的客户而变化\",{\"1\":{\"104\":1}}],[\"策略模式是一种行为型设计模式\",{\"1\":{\"104\":1}}],[\"策略模式\",{\"0\":{\"104\":1},\"1\":{\"79\":1}}],[\"初始没有策略\",{\"1\":{\"104\":1}}],[\"初始状态为停止\",{\"1\":{\"103\":1}}],[\"初始化全局状态\",{\"1\":{\"103\":1}}],[\"初始化生成器接口\",{\"1\":{\"85\":1}}],[\"全局变量\",{\"1\":{\"177\":1}}],[\"全局状态实例\",{\"1\":{\"103\":1}}],[\"全局访问点\",{\"1\":{\"87\":2}}],[\"行驶状态\",{\"1\":{\"103\":1}}],[\"行驶\",{\"1\":{\"103\":2}}],[\"行为解析\",{\"0\":{\"148\":1}}],[\"行为型模式包括责任链模式\",{\"1\":{\"79\":1}}],[\"行为型模式负责对象间的高效沟通和职责委派\",{\"1\":{\"79\":1}}],[\"行为型模式\",{\"1\":{\"79\":1}}],[\"行为型模式主要用于协调对象之间的交互\",{\"1\":{\"79\":1}}],[\"行为模式\",{\"1\":{\"79\":1}}],[\"上一个\",{\"0\":{\"207\":1},\"1\":{\"206\":1}}],[\"上方\",{\"1\":{\"206\":1}}],[\"上下文必须知道所有的策略\",{\"1\":{\"104\":1}}],[\"上下文需要了解策略\",{\"1\":{\"104\":1}}],[\"上下文\",{\"1\":{\"103\":2,\"104\":2}}],[\"上电调用init可以直接切换到任意一个模式\",{\"1\":{\"36\":1}}],[\"状态\",{\"1\":{\"145\":1,\"146\":1,\"151\":1,\"153\":2,\"154\":2}}],[\"状态机\",{\"0\":{\"145\":1,\"146\":1}}],[\"状态机结构较复杂\",{\"1\":{\"144\":1}}],[\"状态机结构图\",{\"0\":{\"143\":1,\"144\":1}}],[\"状态机模型\",{\"0\":{\"142\":1}}],[\"状态切换频繁\",{\"1\":{\"103\":1}}],[\"状态切换的管理\",{\"1\":{\"103\":1}}],[\"状态切换清晰\",{\"1\":{\"103\":1}}],[\"状态接口\",{\"1\":{\"103\":2}}],[\"状态变化通知\",{\"1\":{\"102\":1}}],[\"状态模式可以用于表示汽车的不同状态\",{\"1\":{\"103\":1}}],[\"状态模式通过将状态相关的行为封装到独立的状态类中\",{\"1\":{\"103\":1}}],[\"状态模式将状态相关的行为封装在独立的状态类中\",{\"1\":{\"103\":1}}],[\"状态模式将状态的相关行为封装到独立的状态类中\",{\"1\":{\"103\":1}}],[\"状态模式主要包括以下几个部分\",{\"1\":{\"103\":1}}],[\"状态模式是一种行为型设计模式\",{\"1\":{\"103\":1}}],[\"状态模式\",{\"0\":{\"103\":1},\"1\":{\"79\":1}}],[\"广播服务\",{\"1\":{\"137\":1}}],[\"广播通信\",{\"1\":{\"102\":1}}],[\"广播发送报文\",{\"1\":{\"29\":1}}],[\"关于我\",{\"0\":{\"248\":1}}],[\"关键字extern用于声明一个变量或函数\",{\"1\":{\"177\":1}}],[\"关闭原则\",{\"1\":{\"102\":1,\"104\":1}}],[\"关系\",{\"1\":{\"81\":2}}],[\"易于扩展\",{\"1\":{\"102\":1,\"103\":1,\"104\":1}}],[\"易于维护\",{\"1\":{\"94\":2}}],[\"移除永远不会执行的代码\",{\"1\":{\"184\":1}}],[\"移除一个观察者\",{\"1\":{\"102\":1}}],[\"移除和通知观察者的方法\",{\"1\":{\"102\":2}}],[\"仪表盘\",{\"1\":{\"102\":1}}],[\"恢复到之前的状态\",{\"1\":{\"101\":1}}],[\"历史记录等\",{\"1\":{\"101\":1}}],[\"性能与稳定性的最佳平衡点\",{\"1\":{\"189\":1}}],[\"性能开销\",{\"1\":{\"101\":1}}],[\"性能问题\",{\"1\":{\"85\":1,\"97\":1,\"100\":1}}],[\"速度和燃油量\",{\"1\":{\"101\":1,\"102\":1}}],[\"燃油量\",{\"1\":{\"101\":1,\"102\":1}}],[\"备忘录一般是不可变的\",{\"1\":{\"101\":1}}],[\"备忘录\",{\"1\":{\"101\":2}}],[\"备忘录模式可以用于保存和恢复汽车的状态\",{\"1\":{\"101\":1}}],[\"备忘录模式可以用于实现撤销操作\",{\"1\":{\"101\":1}}],[\"备忘录模式可以方便地实现撤销操作\",{\"1\":{\"101\":1}}],[\"备忘录模式通过封装对象的状态\",{\"1\":{\"101\":2}}],[\"备忘录模式主要包括以下几个部分\",{\"1\":{\"101\":1}}],[\"备忘录模式将对象的状态保存到一个备忘录对象中\",{\"1\":{\"101\":1}}],[\"备忘录模式是一种行为型设计模式\",{\"1\":{\"101\":1}}],[\"备忘录模式\",{\"0\":{\"101\":1},\"1\":{\"79\":1}}],[\"捕获和恢复对象的内部状态\",{\"1\":{\"101\":1}}],[\"集中相关操作\",{\"1\":{\"106\":1}}],[\"集中控制\",{\"1\":{\"100\":1}}],[\"集成及相关调试策略\",{\"1\":{\"25\":1}}],[\"协调同事类之间的交互\",{\"1\":{\"100\":1}}],[\"协调各同事对象之间的交互\",{\"1\":{\"100\":1}}],[\"协议通过以下两种方式完成服务释放或断开订阅\",{\"1\":{\"150\":1}}],[\"协议细节\",{\"0\":{\"148\":1}}],[\"协议在实际运行中的时序机制与控制逻辑\",{\"1\":{\"144\":1}}],[\"协议格式\",{\"0\":{\"139\":1}}],[\"协议族的重要组成部分\",{\"1\":{\"133\":1}}],[\"协议\",{\"1\":{\"157\":1},\"2\":{\"42\":1,\"65\":1}}],[\"协议本身对节点的数量没有限制\",{\"1\":{\"29\":1}}],[\"协议栈原理\",{\"1\":{\"25\":1}}],[\"希望\",{\"1\":{\"125\":2}}],[\"希望集中控制交互逻辑\",{\"1\":{\"100\":1}}],[\"希望分离遍历算法和集合对象\",{\"1\":{\"99\":1}}],[\"希望客户端可以统一处理单个对象和组合对象\",{\"1\":{\"91\":1}}],[\"后面跟着虚拟环境的名称和python解释器的路径\",{\"1\":{\"222\":1}}],[\"后端优化\",{\"0\":{\"186\":1}}],[\"后\",{\"1\":{\"124\":1}}],[\"后者便是搞一些大家公认的好卖点\",{\"1\":{\"120\":1}}],[\"后序遍历\",{\"1\":{\"99\":1}}],[\"后会将请求传递给服务对象\",{\"1\":{\"95\":1}}],[\"额外的开销\",{\"1\":{\"99\":1}}],[\"没有什么比轻松和快速来钱更能吸引普通民众\",{\"1\":{\"126\":1}}],[\"没有显式定义\",{\"1\":{\"99\":1}}],[\"没有子节点的功能\",{\"1\":{\"91\":1}}],[\"没有子节点\",{\"1\":{\"91\":1}}],[\"向后兼容性\",{\"1\":{\"211\":1}}],[\"向后兼容旧架构\",{\"0\":{\"205\":1}}],[\"向上栈\",{\"1\":{\"209\":1}}],[\"向上增长\",{\"1\":{\"200\":1,\"203\":1,\"211\":1}}],[\"向下分配\",{\"1\":{\"203\":1}}],[\"向下增长的设计使得每次扩展栈只需申请\",{\"1\":{\"204\":1}}],[\"向下增长\",{\"1\":{\"200\":1,\"203\":1,\"211\":1}}],[\"向量化优化与\",{\"1\":{\"190\":1}}],[\"向汽车集合中添加汽车\",{\"1\":{\"99\":1}}],[\"向链上的具体处理者对象提交请求\",{\"1\":{\"97\":1}}],[\"管理一系列的汽车对象\",{\"1\":{\"99\":1}}],[\"管理复杂性\",{\"1\":{\"91\":1}}],[\"聚合接口\",{\"1\":{\"99\":2}}],[\"迭代器方法实现\",{\"1\":{\"99\":1}}],[\"迭代器接口\",{\"1\":{\"99\":3}}],[\"迭代器模式可以用于遍历汽车集合对象\",{\"1\":{\"99\":1}}],[\"迭代器模式通过定义统一的遍历接口\",{\"1\":{\"99\":1}}],[\"迭代器模式主要包括以下几个部分\",{\"1\":{\"99\":1}}],[\"迭代器模式将遍历聚合对象的责任从聚合对象本身转移到了迭代器对象\",{\"1\":{\"99\":1}}],[\"迭代器模式是一种行为型设计模式\",{\"1\":{\"99\":1}}],[\"迭代器模式\",{\"0\":{\"99\":1},\"1\":{\"79\":1,\"98\":1}}],[\"执行慢\",{\"1\":{\"188\":1}}],[\"执行时间\",{\"1\":{\"187\":1}}],[\"执行实际操作的对象\",{\"1\":{\"98\":1}}],[\"执行具体操作的类\",{\"1\":{\"98\":1}}],[\"例子中为main函数\",{\"1\":{\"98\":1}}],[\"例子中为car\",{\"1\":{\"98\":1}}],[\"例子中invoker负责调用命令的执行和撤销操作\",{\"1\":{\"98\":1}}],[\"例子中包括启动引擎命令和停止引擎命令\",{\"1\":{\"98\":1}}],[\"例如增加系统复杂度\",{\"1\":{\"95\":1}}],[\"例如增加了系统的复杂性\",{\"1\":{\"94\":1}}],[\"例如限制对真实对象的访问权限\",{\"1\":{\"95\":1}}],[\"例如创建一个大型对象时\",{\"1\":{\"95\":1}}],[\"例如通过网络连接访问远程服务器上的对象\",{\"1\":{\"95\":1}}],[\"例如通过网络连接访问远程对象\",{\"1\":{\"95\":1}}],[\"例如检查权限\",{\"1\":{\"95\":1}}],[\"例如延迟初始化\",{\"1\":{\"95\":1}}],[\"例如汽车的颜色\",{\"1\":{\"94\":1}}],[\"例如文本编辑器中的字符\",{\"1\":{\"94\":1}}],[\"例如文件系统\",{\"1\":{\"87\":1}}],[\"例如线程安全问题\",{\"1\":{\"94\":1}}],[\"例如线程池\",{\"1\":{\"87\":1}}],[\"例如序列号生成器\",{\"1\":{\"87\":1}}],[\"例如日志记录器\",{\"1\":{\"87\":1}}],[\"例如\",{\"1\":{\"86\":1,\"93\":1,\"222\":3}}],[\"例如克隆关联对象和梳理递归依赖等等\",{\"1\":{\"86\":1}}],[\"撤销停止引擎命令\",{\"1\":{\"98\":1}}],[\"撤销命令\",{\"1\":{\"98\":1}}],[\"停止提供服务\",{\"0\":{\"151\":1},\"1\":{\"149\":1}}],[\"停止等状态\",{\"1\":{\"144\":1}}],[\"停止状态\",{\"1\":{\"103\":1}}],[\"停止\",{\"1\":{\"103\":2}}],[\"停止引擎等\",{\"1\":{\"98\":1}}],[\"停止引擎命令\",{\"1\":{\"98\":1}}],[\"停止发动机\",{\"1\":{\"98\":1}}],[\"调试能力和软件兼容性的深思熟虑结果\",{\"1\":{\"212\":1}}],[\"调试器栈回溯\",{\"1\":{\"211\":1}}],[\"调试器与\",{\"1\":{\"205\":1}}],[\"调试回溯角度全面分析\",{\"1\":{\"198\":1}}],[\"调试困难\",{\"1\":{\"97\":1}}],[\"调用对象的方法\",{\"1\":{\"178\":1}}],[\"调用自动调用\",{\"1\":{\"136\":1}}],[\"调用者\",{\"1\":{\"98\":2}}],[\"调用接收者的相应操作\",{\"1\":{\"98\":1}}],[\"调用汽车装饰函数\",{\"1\":{\"92\":1}}],[\"调用汽车的操作\",{\"1\":{\"91\":1}}],[\"调用\",{\"1\":{\"81\":1}}],[\"制定切实可行的炒股计划\",{\"1\":{\"125\":1}}],[\"制造豪华型汽车\",{\"1\":{\"105\":1}}],[\"制造经济型汽车\",{\"1\":{\"105\":1}}],[\"制造经济型汽车和制造豪华型汽车\",{\"1\":{\"105\":1}}],[\"制造汽车\",{\"1\":{\"85\":2}}],[\"制动系统检查器\",{\"1\":{\"97\":1}}],[\"制动系统\",{\"1\":{\"97\":1}}],[\"车轮检查器\",{\"1\":{\"97\":1}}],[\"车轮\",{\"1\":{\"97\":1}}],[\"责任链模式可以用于不同的汽车零部件检查\",{\"1\":{\"97\":1}}],[\"责任链模式通过将请求沿着处理者链传递\",{\"1\":{\"97\":1}}],[\"责任链模式主要包括以下几个部分\",{\"1\":{\"97\":1}}],[\"责任链模式是一种行为设计模式\",{\"1\":{\"97\":1}}],[\"责任链模式\",{\"0\":{\"97\":1}}],[\"智能引用\",{\"1\":{\"95\":1}}],[\"远程代理\",{\"1\":{\"95\":1}}],[\"缓存结果等\",{\"1\":{\"95\":1}}],[\"输出\",{\"1\":{\"95\":1}}],[\"输出汽车信息\",{\"1\":{\"85\":1}}],[\"此时我才觉得舒服\",{\"1\":{\"124\":1}}],[\"此时代理会将请求转发给真实汽车对象\",{\"1\":{\"95\":1}}],[\"此时代理会检查真实汽车是否可用\",{\"1\":{\"95\":1}}],[\"此时本地git仓库已初始化\",{\"1\":{\"59\":1}}],[\"服务下线\",{\"1\":{\"151\":1}}],[\"服务释放机制\",{\"0\":{\"150\":1}}],[\"服务实例\",{\"1\":{\"147\":1}}],[\"服务实现\",{\"1\":{\"95\":1}}],[\"服务唯一标识\",{\"1\":{\"147\":1}}],[\"服务未初始化或未就绪\",{\"1\":{\"145\":1}}],[\"服务性架构\",{\"1\":{\"136\":1}}],[\"服务发现\",{\"1\":{\"136\":1,\"157\":1}}],[\"服务\",{\"1\":{\"95\":1}}],[\"服务接口\",{\"1\":{\"95\":2}}],[\"服务调用\",{\"1\":{\"6\":1}}],[\"代表智慧\",{\"1\":{\"126\":1}}],[\"代表真实的汽车\",{\"1\":{\"95\":1}}],[\"代理可以实现远程访问\",{\"1\":{\"95\":1}}],[\"代理可以保护真实对象\",{\"1\":{\"95\":1}}],[\"代理可以延迟创建真实对象\",{\"1\":{\"95\":1}}],[\"代理可以控制对真实对象的访问\",{\"1\":{\"95\":1}}],[\"代理会对其服务对象的整个生命周期进行管理\",{\"1\":{\"95\":1}}],[\"代理完成其任务\",{\"1\":{\"95\":1}}],[\"代理\",{\"1\":{\"95\":2}}],[\"代理必须遵循该接口才能伪装成服务对象\",{\"1\":{\"95\":1}}],[\"代理控制着对于原对象的访问\",{\"1\":{\"95\":1}}],[\"代理模式也有一些缺点\",{\"1\":{\"95\":1}}],[\"代理模式是一种非常有用的设计模式\",{\"1\":{\"95\":1}}],[\"代理模式是一种结构型设计模式\",{\"1\":{\"95\":1}}],[\"代理模式可能会导致代码冗余\",{\"1\":{\"95\":1}}],[\"代理模式可能会降低系统的性能\",{\"1\":{\"95\":1}}],[\"代理模式需要引入额外的代理对象\",{\"1\":{\"95\":1}}],[\"代理模式\",{\"0\":{\"95\":1}}],[\"代码分析\",{\"0\":{\"195\":1}}],[\"代码优化的方式多种多样\",{\"1\":{\"191\":1}}],[\"代码的运行效率往往比语言特性更关键\",{\"1\":{\"181\":1}}],[\"代码整洁之道\",{\"1\":{\"107\":1}}],[\"代码复用\",{\"1\":{\"81\":1,\"105\":1}}],[\"代码生成失败\",{\"1\":{\"13\":1}}],[\"图形编辑器中的图形等\",{\"1\":{\"94\":1}}],[\"增强可扩展性\",{\"1\":{\"97\":1}}],[\"增强代码的可维护性\",{\"1\":{\"94\":1}}],[\"增加管理复杂度\",{\"1\":{\"203\":1}}],[\"增加新元素困难\",{\"1\":{\"106\":1}}],[\"增加新操作\",{\"1\":{\"106\":1}}],[\"增加系统的复杂性\",{\"1\":{\"104\":1}}],[\"增加系统复杂性\",{\"1\":{\"98\":1}}],[\"增加系统复杂度\",{\"1\":{\"95\":1}}],[\"增加复杂性\",{\"1\":{\"90\":1}}],[\"增加了类的数量\",{\"1\":{\"99\":1}}],[\"增加了系统的灵活性\",{\"1\":{\"97\":1}}],[\"增加了系统的复杂性\",{\"1\":{\"90\":1,\"92\":2,\"94\":2,\"98\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"83\":2,\"95\":1}}],[\"增加了代码的复杂度\",{\"1\":{\"89\":1}}],[\"增加已有代码的灵活性和可复用性\",{\"1\":{\"79\":1}}],[\"减少分支判断频率\",{\"1\":{\"186\":1}}],[\"减少了内存的占用\",{\"1\":{\"94\":1}}],[\"减少内存占用\",{\"1\":{\"94\":1}}],[\"减少代码的重复编写\",{\"1\":{\"76\":1}}],[\"否则你无法从股市长久赚到钱\",{\"1\":{\"129\":1}}],[\"否则你就不应留在手里\",{\"1\":{\"118\":1}}],[\"否则气球吹不起来\",{\"1\":{\"126\":1}}],[\"否则别冒险\",{\"1\":{\"124\":1}}],[\"否则即刻止损离场\",{\"1\":{\"124\":1}}],[\"否则这里讲的一切都是空的\",{\"1\":{\"119\":1}}],[\"否则只是白日梦\",{\"1\":{\"118\":1}}],[\"否则的话\",{\"1\":{\"117\":1}}],[\"否则便是不正常运动\",{\"1\":{\"117\":1}}],[\"否则创建一个新的汽车享元对象并添加到工厂中\",{\"1\":{\"94\":1}}],[\"否则可能会导致引用的对象被多个克隆对象共享\",{\"1\":{\"86\":1}}],[\"享元工厂结构体\",{\"1\":{\"94\":1}}],[\"享元工厂\",{\"1\":{\"94\":1}}],[\"享元\",{\"1\":{\"94\":1}}],[\"享元模式也有一些缺点\",{\"1\":{\"94\":1}}],[\"享元模式是一种通过共享对象来减少内存占用和提高性能的设计模式\",{\"1\":{\"94\":1}}],[\"享元模式是一种结构型设计模式\",{\"1\":{\"94\":1}}],[\"享元模式\",{\"0\":{\"94\":1}}],[\"享元模式和代理模式\",{\"1\":{\"79\":1}}],[\"让软件组件\",{\"1\":{\"133\":1}}],[\"让你能够提供对象的替代品或其占位符\",{\"1\":{\"95\":1}}],[\"让你能在有限的内存容量中载入更多对象\",{\"1\":{\"94\":1}}],[\"让我们以junit为例来解释这个原则\",{\"1\":{\"81\":1}}],[\"让我们看一个简化的示例\",{\"1\":{\"81\":1}}],[\"让我们通过一个简单的代码示例来说明这个概念\",{\"1\":{\"81\":1}}],[\"释放等动作的根本依据\",{\"1\":{\"149\":1}}],[\"释放\",{\"1\":{\"149\":1}}],[\"释放全局状态\",{\"1\":{\"103\":1}}],[\"释放汽车经销商对象\",{\"1\":{\"93\":1}}],[\"释放内存\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"92\":1,\"94\":1}}],[\"销售汽车\",{\"1\":{\"93\":2}}],[\"子系统类通常包含一些与子系统相关的业务逻辑\",{\"1\":{\"93\":1}}],[\"子系统类是外观模式的组成部分\",{\"1\":{\"93\":1}}],[\"子系统类\",{\"1\":{\"93\":1}}],[\"子类可以通过覆盖抽象方法来改变算法的某些步骤\",{\"1\":{\"105\":1}}],[\"子类对象可以被当作其超类对象使用\",{\"1\":{\"81\":1}}],[\"子类应该能够完全替代父类\",{\"1\":{\"81\":1}}],[\"子类继承父类的目的是对父类的拓展\",{\"1\":{\"73\":1}}],[\"子类必须实现该接口\",{\"1\":{\"73\":1}}],[\"简单\",{\"1\":{\"211\":1}}],[\"简单到普通民众能\",{\"1\":{\"126\":1}}],[\"简而言之\",{\"1\":{\"171\":1}}],[\"简化了消息的传递\",{\"1\":{\"102\":1}}],[\"简化了状态管理\",{\"1\":{\"101\":2}}],[\"简化了客户端的代码\",{\"1\":{\"93\":1}}],[\"简化状态管理\",{\"1\":{\"101\":1}}],[\"简化对象交互\",{\"1\":{\"100\":1}}],[\"简化代码\",{\"1\":{\"92\":1}}],[\"简洁的设计思路\",{\"1\":{\"76\":1}}],[\"符合单一职责原则\",{\"1\":{\"103\":1}}],[\"符合开放\",{\"1\":{\"102\":1,\"104\":1}}],[\"符合开闭原则\",{\"1\":{\"92\":2,\"106\":1}}],[\"符号表示\",{\"0\":{\"72\":1}}],[\"遵循开闭原则\",{\"1\":{\"92\":1}}],[\"遵循连接规则\",{\"0\":{\"24\":1}}],[\"动\",{\"1\":{\"121\":1}}],[\"动态上线\",{\"1\":{\"135\":1}}],[\"动态获取服务的地址和端口\",{\"1\":{\"134\":1}}],[\"动态切换\",{\"1\":{\"104\":1}}],[\"动态地选择不同的子系统实现类\",{\"1\":{\"93\":2}}],[\"动态地给对象添加新的功能\",{\"1\":{\"92\":3}}],[\"动态扩展\",{\"1\":{\"92\":1}}],[\"动机\",{\"1\":{\"77\":1}}],[\"为runnable配置触发器\",{\"0\":{\"243\":1}}],[\"为autosar\",{\"1\":{\"235\":1}}],[\"为兼容早期汇编\",{\"1\":{\"205\":1}}],[\"为什么程序栈向下增长\",{\"0\":{\"201\":1}}],[\"为什么程序栈地址是向下增长的\",{\"0\":{\"198\":1}}],[\"为\",{\"1\":{\"149\":1}}],[\"为自己立些规矩\",{\"1\":{\"129\":1}}],[\"为汽车添加了gps和天窗功能\",{\"1\":{\"92\":1}}],[\"为了使传统燃油汽车能够使用电动汽车的充电接口\",{\"1\":{\"89\":1}}],[\"为了使用生成器模式创建汽车\",{\"1\":{\"85\":1}}],[\"为了避免这种情况\",{\"1\":{\"81\":1}}],[\"宝马\",{\"1\":{\"92\":1}}],[\"演示了如何使用装饰模式来为一个汽车添加不同的功能\",{\"1\":{\"92\":1}}],[\"起到给component添加职责的功能\",{\"1\":{\"92\":1}}],[\"装饰抽象类\",{\"1\":{\"92\":1}}],[\"装饰\",{\"1\":{\"92\":1}}],[\"装饰模式遵循开闭原则\",{\"1\":{\"92\":1}}],[\"装饰模式是一种非常有用的设计模式\",{\"1\":{\"92\":1}}],[\"装饰模式需要创建多个装饰类\",{\"1\":{\"92\":2}}],[\"装饰模式将功能分解为多个独立的装饰类\",{\"1\":{\"92\":1}}],[\"装饰模式可以将复杂的功能分解为多个简单的装饰类\",{\"1\":{\"92\":3}}],[\"装饰模式可以在不修改原有代码的情况下\",{\"1\":{\"92\":2}}],[\"装饰模式可以在不改变原有对象结构的情况下\",{\"1\":{\"92\":2}}],[\"装饰模式的主要角色包括\",{\"1\":{\"92\":1}}],[\"装饰模式\",{\"0\":{\"92\":1},\"1\":{\"79\":1,\"92\":1}}],[\"也就是\",{\"1\":{\"206\":1}}],[\"也就是说\",{\"1\":{\"81\":5}}],[\"也让c语言在高性能计算\",{\"1\":{\"191\":1}}],[\"也能自动联系服务\",{\"1\":{\"138\":1}}],[\"也别将\",{\"1\":{\"124\":1}}],[\"也不再发送事件\",{\"1\":{\"151\":1}}],[\"也不是不知道危险\",{\"1\":{\"118\":1}}],[\"也不要悔\",{\"1\":{\"111\":1}}],[\"也可以给这个对象添加一些职责\",{\"1\":{\"92\":1}}],[\"展示了如何使用extern来模拟类和对象的概念\",{\"1\":{\"178\":1}}],[\"展示了如何通过模板方法模式实现经济型汽车和豪华型汽车的制造过程\",{\"1\":{\"105\":1}}],[\"展示了策略模式如何在实际项目中使用\",{\"1\":{\"104\":1}}],[\"展示了状态模式如何在实际项目中使用\",{\"1\":{\"103\":1}}],[\"展示了观察者模式如何在实际项目中使用\",{\"1\":{\"102\":1}}],[\"展示了备忘录模式如何在实际项目中使用\",{\"1\":{\"101\":1}}],[\"展示了中介者模式如何在实际项目中使用\",{\"1\":{\"100\":1}}],[\"展示了迭代器模式如何在实际项目中使用\",{\"1\":{\"99\":1}}],[\"展示了责任链模式如何在实际项目中使用\",{\"1\":{\"97\":1}}],[\"展示了组合模式如何在实际项目中使用\",{\"1\":{\"91\":1}}],[\"展示模式的各个部分和它们之间的关系\",{\"1\":{\"77\":1}}],[\"清晰\",{\"1\":{\"211\":1}}],[\"清晰的层次结构\",{\"1\":{\"91\":1}}],[\"清理内存\",{\"1\":{\"90\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"104\":1}}],[\"最佳实践总结\",{\"0\":{\"189\":1}}],[\"最初指出气球会破的人随着气球的不断胀大而被嘲笑\",{\"1\":{\"126\":1}}],[\"最好只买九只股票\",{\"1\":{\"124\":1}}],[\"最好在升势或突破阻力线\",{\"1\":{\"120\":1}}],[\"最高点卖股\",{\"1\":{\"124\":1}}],[\"最低价是10元\",{\"1\":{\"123\":1}}],[\"最足的类别股中\",{\"1\":{\"121\":1}}],[\"最足的类别股后\",{\"1\":{\"121\":1}}],[\"最足的股类中选择一两只\",{\"1\":{\"121\":1}}],[\"最足\",{\"1\":{\"121\":1}}],[\"最有用的概念是阻力线和支撑线\",{\"1\":{\"119\":1}}],[\"最痛苦的不是亏钱的数目\",{\"1\":{\"118\":1}}],[\"最少阻力线\",{\"1\":{\"118\":1}}],[\"最流行的\",{\"1\":{\"117\":1}}],[\"最重要的是每天要追踪股票指数的运动\",{\"1\":{\"117\":1}}],[\"最终调用组合节点的操作方法来展示组合模式的工作方式\",{\"1\":{\"91\":1}}],[\"最后提醒你\",{\"1\":{\"111\":1}}],[\"最后\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"87\":1,\"89\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1}}],[\"还要避免覆盖参数区\",{\"1\":{\"203\":1}}],[\"还包含一个指向聚合对象的指针\",{\"1\":{\"99\":1}}],[\"还包含一个名称属性\",{\"1\":{\"91\":1}}],[\"还通过具体的代码示例和uml图\",{\"1\":{\"68\":1}}],[\"测试代码\",{\"1\":{\"106\":1}}],[\"测试策略模式\",{\"1\":{\"104\":1}}],[\"测试状态模式\",{\"1\":{\"103\":1}}],[\"测试观察者模式\",{\"1\":{\"102\":1}}],[\"测试备忘录模式\",{\"1\":{\"101\":1}}],[\"测试中介者模式\",{\"1\":{\"100\":1}}],[\"测试迭代器模式\",{\"1\":{\"99\":1}}],[\"测试命令模式\",{\"1\":{\"98\":1}}],[\"测试责任链\",{\"1\":{\"97\":1}}],[\"测试函数\",{\"1\":{\"92\":1}}],[\"测试组合模式\",{\"1\":{\"91\":2}}],[\"测试类告诉junit框架它有哪些测试方法\",{\"1\":{\"81\":1}}],[\"发现global级别配置了代理地址\",{\"1\":{\"163\":1}}],[\"发现\",{\"1\":{\"149\":1}}],[\"发现压力的根源\",{\"1\":{\"124\":1}}],[\"发财的希望\",{\"1\":{\"126\":1}}],[\"发布系统\",{\"1\":{\"102\":1}}],[\"发生变化时\",{\"1\":{\"102\":1}}],[\"发起人\",{\"1\":{\"101\":2}}],[\"发动机\",{\"1\":{\"91\":1}}],[\"发送不同功能的pdu以及控制can收发器进行工作的transceiver\",{\"1\":{\"32\":1}}],[\"既可以是叶子也可以是其他容器\",{\"1\":{\"91\":1}}],[\"容器\",{\"1\":{\"91\":2}}],[\"叶子节点没有子节点\",{\"1\":{\"91\":1}}],[\"叶子节点不能移除子节点\",{\"1\":{\"91\":1}}],[\"叶子节点不能添加子节点\",{\"1\":{\"91\":1}}],[\"叶子\",{\"1\":{\"91\":2}}],[\"部分\",{\"1\":{\"91\":1,\"206\":1}}],[\"部署到gitpages\",{\"0\":{\"59\":1}}],[\"轿车\",{\"1\":{\"90\":1}}],[\"扩展对象的功能\",{\"1\":{\"92\":4}}],[\"扩展抽象部分的接口\",{\"1\":{\"90\":1}}],[\"扩展抽象部分\",{\"1\":{\"90\":4}}],[\"扩展性强\",{\"1\":{\"98\":1}}],[\"扩展性\",{\"1\":{\"81\":1,\"105\":1}}],[\"降低耦合\",{\"1\":{\"100\":1}}],[\"降低耦合度\",{\"1\":{\"97\":1}}],[\"降低了对象之间的耦合度\",{\"1\":{\"100\":2}}],[\"降低了发送者和接收者的耦合度\",{\"1\":{\"97\":1}}],[\"降低了系统的性能\",{\"1\":{\"92\":1}}],[\"降低了代码的性能\",{\"1\":{\"89\":1}}],[\"降低类的数量\",{\"1\":{\"90\":1}}],[\"降低维护成本\",{\"1\":{\"81\":1}}],[\"传统燃油汽车结构体\",{\"1\":{\"89\":1}}],[\"传输时间短\",{\"1\":{\"29\":1}}],[\"传输速率最高可达1mbps\",{\"1\":{\"29\":1}}],[\"传输速率为40kbps时\",{\"1\":{\"28\":1}}],[\"传输速率可达1mbps\",{\"1\":{\"28\":1}}],[\"电动汽车结构体\",{\"1\":{\"89\":1}}],[\"电子控制单元\",{\"1\":{\"28\":1}}],[\"适当加注\",{\"1\":{\"124\":1}}],[\"适时进货\",{\"1\":{\"118\":1}}],[\"适用于复杂逻辑但对本例提升有限\",{\"1\":{\"188\":1}}],[\"适用于嵌入式系统\",{\"1\":{\"182\":1}}],[\"适用于需要频繁保存和恢复对象状态的场景\",{\"1\":{\"101\":1}}],[\"适用于需要在没有客户端使用某个重量级对象时立即销毁该对象的场景\",{\"1\":{\"95\":1}}],[\"适用于需要保护真实对象的场景\",{\"1\":{\"95\":1}}],[\"适用于需要延迟初始化的场景\",{\"1\":{\"95\":1}}],[\"适用于需要访问远程对象的场景\",{\"1\":{\"95\":1}}],[\"适用场景\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"适配器\",{\"1\":{\"89\":1}}],[\"适配器模式适用于需要将现有的接口转换为客户端期望的接口的场景\",{\"1\":{\"89\":1}}],[\"适配器模式的优点是提高了代码的复用性\",{\"1\":{\"89\":1}}],[\"适配器模式需要将现有的接口转换为客户端期望的接口\",{\"1\":{\"89\":1}}],[\"适配器模式需要定义一个适配器类\",{\"1\":{\"89\":1}}],[\"适配器模式可以在不修改现有代码的情况下\",{\"1\":{\"89\":2}}],[\"适配器模式可以将现有的接口转换为客户端期望的接口\",{\"1\":{\"89\":1}}],[\"适配器模式是一种结构型设计模式\",{\"1\":{\"89\":2}}],[\"适配器模式\",{\"0\":{\"89\":1}}],[\"唯一标识符生成器等\",{\"1\":{\"87\":1}}],[\"资源共享的对象\",{\"1\":{\"87\":2}}],[\"难以保证不越界覆盖参数区\",{\"1\":{\"209\":1}}],[\"难以在测试中进行模拟和控制\",{\"1\":{\"87\":1}}],[\"难以测试\",{\"1\":{\"87\":2}}],[\"违反了单一职责原则\",{\"1\":{\"87\":1}}],[\"违反单一职责原则\",{\"1\":{\"87\":1}}],[\"节省资源和提高性能\",{\"1\":{\"87\":1}}],[\"节省资源\",{\"1\":{\"87\":1}}],[\"保存上一个函数的基址\",{\"1\":{\"207\":1}}],[\"保存\",{\"1\":{\"206\":1}}],[\"保存的旧帧地址\",{\"1\":{\"203\":1}}],[\"保存多个备忘录会占用较多内存\",{\"1\":{\"101\":1}}],[\"保留源代码语义\",{\"1\":{\"182\":1}}],[\"保活机制\",{\"1\":{\"134\":1}}],[\"保本第一\",{\"1\":{\"123\":1}}],[\"保本\",{\"1\":{\"118\":1}}],[\"保护代理\",{\"1\":{\"95\":1}}],[\"保护真实对象\",{\"1\":{\"95\":2}}],[\"保证唯一性\",{\"1\":{\"87\":1}}],[\"保持网络资源清洁\",{\"1\":{\"152\":1}}],[\"保持了对象的封装性\",{\"1\":{\"101\":1}}],[\"保持\",{\"0\":{\"24\":1}}],[\"则必须首先定义数据类型\",{\"1\":{\"240\":1}}],[\"则需要不断维护最大正偏移\",{\"1\":{\"203\":1}}],[\"则退出推送\",{\"1\":{\"154\":1}}],[\"则你将常常在高点入市\",{\"1\":{\"118\":1}}],[\"则直接返回该实例\",{\"1\":{\"87\":1}}],[\"则创建一个新的汽车实例并将其赋值给instance\",{\"1\":{\"87\":1}}],[\"生活随想\",{\"0\":{\"255\":1}}],[\"生效优先级\",{\"0\":{\"162\":1}}],[\"生成模板\",{\"0\":{\"244\":1}}],[\"生成requirements\",{\"1\":{\"216\":1}}],[\"生成\",{\"1\":{\"156\":1}}],[\"生成器接口\",{\"1\":{\"85\":1}}],[\"生成器\",{\"1\":{\"85\":1}}],[\"生成器模式适用于需要创建的对象具有复杂的结构\",{\"1\":{\"85\":1}}],[\"生成器模式的优点是封装性\",{\"1\":{\"85\":1}}],[\"生成器模式在创建产品时需要进行多次方法调用\",{\"1\":{\"85\":1}}],[\"生成器模式需要定义多个类来实现产品的创建过程\",{\"1\":{\"85\":1}}],[\"生成器模式可以很容易地添加新的产品类型和创建过程\",{\"1\":{\"85\":1}}],[\"生成器模式可以根据不同的需求创建不同的生成器类\",{\"1\":{\"85\":1}}],[\"生成器模式将产品的创建过程封装在生成器类中\",{\"1\":{\"85\":1}}],[\"生成器模式是一种创建型设计模式\",{\"1\":{\"85\":2}}],[\"生成器模式\",{\"0\":{\"85\":1},\"1\":{\"79\":1}}],[\"生产年份和车辆类型\",{\"1\":{\"87\":1}}],[\"修改克隆汽车的信息\",{\"1\":{\"86\":1}}],[\"克隆新汽车\",{\"1\":{\"86\":1}}],[\"克隆函数\",{\"1\":{\"86\":1}}],[\"该表定义了\",{\"1\":{\"149\":1}}],[\"该图展示了\",{\"1\":{\"143\":1}}],[\"该出手时就出手\",{\"1\":{\"124\":1}}],[\"该方法有时还需处理克隆过程中的极端情况\",{\"1\":{\"86\":1}}],[\"该模式允许你使用相同的创建代码生成不同类型和形式的对象\",{\"1\":{\"85\":2}}],[\"年份和类型的方法\",{\"1\":{\"85\":1}}],[\"年份和类型等信息\",{\"1\":{\"85\":1}}],[\"年中组织全体工作组会议\",{\"1\":{\"53\":1}}],[\"设置代理\",{\"0\":{\"160\":1}}],[\"设置为\",{\"1\":{\"151\":1}}],[\"设置策略\",{\"1\":{\"104\":1}}],[\"设置中介者的同事类\",{\"1\":{\"100\":1}}],[\"设置并执行停止引擎命令\",{\"1\":{\"98\":1}}],[\"设置责任链\",{\"1\":{\"97\":2}}],[\"设置下一个检查者\",{\"1\":{\"97\":1}}],[\"设置汽车类型\",{\"1\":{\"85\":1}}],[\"设置汽车年份\",{\"1\":{\"85\":1}}],[\"设置汽车模型\",{\"1\":{\"85\":1}}],[\"设计软件组件架构\",{\"1\":{\"235\":1}}],[\"设计\",{\"0\":{\"237\":1},\"1\":{\"81\":1}}],[\"设计应该能够适应未来的变化和扩展\",{\"1\":{\"81\":1}}],[\"设计原则\",{\"1\":{\"81\":1}}],[\"设计模式解析\",{\"1\":{\"107\":1}}],[\"设计模式可以分为创建型模式\",{\"1\":{\"79\":1}}],[\"设计模式可以根据具体的需求进行调整和扩展\",{\"1\":{\"76\":1}}],[\"设计模式提供了一种清晰\",{\"1\":{\"76\":1}}],[\"设计模式提供了一种通用的解决方案\",{\"1\":{\"70\":1,\"76\":1}}],[\"设计模式是针对软件设计中常见问题的解决方案\",{\"1\":{\"76\":1}}],[\"设计模式是软件开发中的经验总结\",{\"1\":{\"70\":2}}],[\"设计模式是软件设计中常见问题的典型解决方案\",{\"1\":{\"69\":1,\"76\":1}}],[\"设计模式通常具有以下特点\",{\"1\":{\"76\":1}}],[\"设计模式通常具有良好的结构和组织\",{\"1\":{\"70\":1}}],[\"设计模式的分类\",{\"0\":{\"79\":1}}],[\"设计模式的目的是提高软件的可复用性\",{\"1\":{\"76\":1}}],[\"设计模式的概念\",{\"0\":{\"76\":1}}],[\"设计模式并不是一段特定的代码\",{\"1\":{\"76\":1}}],[\"设计模式逐渐成为软件开发领域的重要组成部分\",{\"1\":{\"69\":1}}],[\"设计模式\",{\"0\":{\"253\":1},\"1\":{\"69\":1,\"107\":2},\"2\":{\"109\":1}}],[\"设计推荐实践\",{\"0\":{\"21\":1}}],[\"声明全局变量\",{\"1\":{\"177\":1}}],[\"声明函数的存在\",{\"1\":{\"177\":1}}],[\"声明是告诉编译器有一个这样的变量或函数存在\",{\"1\":{\"176\":1}}],[\"声明生成器\",{\"1\":{\"85\":1}}],[\"声明了服务接口\",{\"1\":{\"95\":1}}],[\"声明了克隆方法的接口\",{\"1\":{\"86\":1}}],[\"声明了创建产品对象的抽象接口\",{\"1\":{\"85\":1}}],[\"声明了一组创建抽象产品的方法\",{\"1\":{\"84\":1}}],[\"语言的一个运算符\",{\"1\":{\"193\":1}}],[\"语言程序为例\",{\"1\":{\"187\":1}}],[\"语言汽车举例\",{\"1\":{\"94\":1,\"95\":1}}],[\"语言举汽车例子\",{\"1\":{\"85\":1,\"87\":1,\"89\":1}}],[\"语言示例\",{\"1\":{\"83\":1}}],[\"用移动止损点来卖股票\",{\"1\":{\"123\":1}}],[\"用你自己发现的临界点\",{\"1\":{\"121\":1}}],[\"用不着很多力气\",{\"1\":{\"116\":1}}],[\"用来炒股的实用性不大\",{\"1\":{\"114\":1}}],[\"用于防止无限栈增长\",{\"1\":{\"204\":1}}],[\"用于返回一个对象或数据类型的大小\",{\"1\":{\"193\":1}}],[\"用于平衡性能\",{\"1\":{\"182\":1}}],[\"用于支持新加入网络的\",{\"1\":{\"153\":1}}],[\"用于确保所有潜在\",{\"1\":{\"153\":1}}],[\"用于表示\",{\"1\":{\"149\":1}}],[\"用于实现事件处理和广播机制\",{\"1\":{\"102\":1}}],[\"用于同事类之间的通信\",{\"1\":{\"100\":1}}],[\"用于遍历\",{\"1\":{\"99\":1}}],[\"用于创建和管理汽车享元对象\",{\"1\":{\"94\":1}}],[\"用于管理其子节点\",{\"1\":{\"91\":1}}],[\"用于存储唯一的汽车实例\",{\"1\":{\"87\":1}}],[\"用于模拟继承\",{\"1\":{\"85\":1}}],[\"用于真实的数据交换\",{\"1\":{\"8\":1}}],[\"用\",{\"1\":{\"85\":1,\"87\":1,\"89\":1,\"94\":1,\"95\":1}}],[\"产品\",{\"1\":{\"85\":1}}],[\"产品族的扩展较为困难\",{\"1\":{\"84\":1}}],[\"针对体积优化\",{\"1\":{\"182\":1}}],[\"针对\",{\"1\":{\"84\":1}}],[\"针对的是\",{\"1\":{\"84\":1}}],[\"需维护正偏移边界\",{\"1\":{\"211\":1}}],[\"需验证代码尺寸与副作用\",{\"1\":{\"189\":1}}],[\"需\",{\"1\":{\"185\":1}}],[\"需要逐级读取\",{\"1\":{\"210\":1}}],[\"需要注意的是\",{\"1\":{\"178\":1,\"194\":1}}],[\"需要注意处理好线程安全问题\",{\"1\":{\"87\":1}}],[\"需要修改所有具体访问者类\",{\"1\":{\"106\":1}}],[\"需要修改具体工厂类的代码\",{\"1\":{\"84\":1}}],[\"需要明确地定义对象在不同状态下的行为\",{\"1\":{\"103\":1}}],[\"需要明确状态转换的场景\",{\"1\":{\"103\":1}}],[\"需要手动管理状态的切换逻辑\",{\"1\":{\"103\":1}}],[\"需要额外处理\",{\"1\":{\"102\":1}}],[\"需要额外的代码来管理享元对象\",{\"1\":{\"94\":1}}],[\"需要避免暴露对象的内部状态\",{\"1\":{\"101\":1}}],[\"需要保存和恢复对象的状态\",{\"1\":{\"101\":1}}],[\"需要保证唯一性的对象\",{\"1\":{\"87\":1}}],[\"需要解耦多个对象之间的交互\",{\"1\":{\"100\":1}}],[\"需要通过一个中介对象来管理这些关系\",{\"1\":{\"100\":1}}],[\"需要支持撤销操作\",{\"1\":{\"101\":1}}],[\"需要支持撤销和重做操作\",{\"1\":{\"98\":1}}],[\"需要支持多种遍历方式\",{\"1\":{\"99\":1}}],[\"需要遍历不同类型的集合对象\",{\"1\":{\"99\":1}}],[\"需要对请求排队和记录日志\",{\"1\":{\"98\":1}}],[\"需要动态选择算法\",{\"1\":{\"104\":1}}],[\"需要动态指定处理请求的对象\",{\"1\":{\"97\":1}}],[\"需要动态地给对象添加新的功能\",{\"1\":{\"92\":1}}],[\"需要根据具体情况进行权衡\",{\"1\":{\"95\":1}}],[\"需要根据具体情况进行权衡和选择\",{\"1\":{\"94\":1}}],[\"需要提高系统的性能\",{\"1\":{\"94\":1}}],[\"需要提高代码的可扩展性\",{\"1\":{\"89\":1}}],[\"需要提高代码的复用性和灵活性\",{\"1\":{\"89\":1}}],[\"需要将复杂的功能分解为多个简单的装饰类\",{\"1\":{\"92\":1}}],[\"需要将现有的接口转换为客户端期望的接口\",{\"1\":{\"89\":1}}],[\"需要在多个类中实现相同的代码\",{\"1\":{\"105\":1}}],[\"需要在一个对象状态发生变化时通知其他对象\",{\"1\":{\"102\":1}}],[\"需要在不修改原有代码的情况下\",{\"1\":{\"92\":1}}],[\"需要在抽象和具体实现之间增加更多的灵活性\",{\"1\":{\"90\":1}}],[\"需要表示对象的部分\",{\"1\":{\"91\":1}}],[\"需要被适配的接口\",{\"1\":{\"89\":1}}],[\"需要频繁创建和销毁的对象和需要保证唯一性的对象\",{\"1\":{\"87\":1}}],[\"需要频繁创建和销毁的对象\",{\"1\":{\"87\":1}}],[\"需要频繁创建对象和对象状态变化较小的场景\",{\"1\":{\"86\":1}}],[\"需要频繁创建对象\",{\"1\":{\"86\":1}}],[\"需要全局访问的对象\",{\"1\":{\"87\":1}}],[\"需要进行特殊处理\",{\"1\":{\"86\":1,\"87\":1}}],[\"需要进行深拷贝\",{\"1\":{\"86\":1}}],[\"需要创建新的具体工厂类\",{\"1\":{\"84\":1}}],[\"需通过\",{\"1\":{\"19\":1}}],[\"无需预置\",{\"1\":{\"138\":1}}],[\"无需修改现有代码\",{\"1\":{\"84\":2}}],[\"无论得到什么\",{\"1\":{\"125\":1}}],[\"无论是理发师\",{\"1\":{\"124\":1}}],[\"无势图\",{\"1\":{\"116\":1}}],[\"无序更新\",{\"1\":{\"102\":1}}],[\"无法裁剪\",{\"1\":{\"73\":1}}],[\"且希望对这些对象进行不同的操作时\",{\"1\":{\"106\":1}}],[\"且它们之间有一些共同的步骤\",{\"1\":{\"105\":1}}],[\"且它们的创建过程比较复杂时\",{\"1\":{\"83\":1}}],[\"且这些配置选项之间存在差异时\",{\"1\":{\"84\":1,\"85\":1}}],[\"且这些实现方式之间存在差异时\",{\"1\":{\"84\":1,\"85\":1}}],[\"且需要分步骤创建时\",{\"1\":{\"84\":1,\"85\":1}}],[\"且唤醒中断引脚连接sbc的唤醒引脚\",{\"1\":{\"36\":1}}],[\"封装与上下文的一个特定状态相关的行为\",{\"1\":{\"103\":1}}],[\"封装性\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"101\":1}}],[\"封装变化的内容\",{\"1\":{\"81\":2}}],[\"客户端设置并执行命令\",{\"1\":{\"98\":1}}],[\"客户端代码\",{\"1\":{\"97\":1}}],[\"客户端代码的修改较为困难\",{\"1\":{\"84\":1}}],[\"客户端的代码不需要进行修改\",{\"1\":{\"93\":3}}],[\"客户端只需要与外观类进行交互\",{\"1\":{\"93\":1}}],[\"客户端可以一致地对待单个对象和组合对象\",{\"1\":{\"91\":1}}],[\"客户端可以根据需要选择不同的工厂类来创建不同的产品对象\",{\"1\":{\"83\":1}}],[\"客户端一致性\",{\"1\":{\"91\":1}}],[\"客户端期望的接口\",{\"1\":{\"89\":1}}],[\"客户端\",{\"1\":{\"86\":1,\"87\":1,\"89\":1,\"94\":1,\"95\":2,\"97\":2,\"98\":2}}],[\"客户端不应该被迫依赖于它们不使用的方法\",{\"1\":{\"81\":1}}],[\"方便恢复到之前的状态\",{\"1\":{\"101\":1}}],[\"方便了代码的使用和管理\",{\"1\":{\"87\":1}}],[\"方便创建复杂对象和便于扩展\",{\"1\":{\"86\":1}}],[\"方便创建复杂对象\",{\"1\":{\"86\":1}}],[\"方便后续添加新的汽车类型或修改汽车的创建方式\",{\"1\":{\"83\":1}}],[\"方法初始化对象\",{\"1\":{\"178\":1}}],[\"方法以便访问者访问它的元素\",{\"1\":{\"106\":1}}],[\"方法签名或行为与\",{\"1\":{\"81\":1}}],[\"方法相同\",{\"1\":{\"81\":1}}],[\"方法具有相同的签名和类似的行为\",{\"1\":{\"81\":1}}],[\"方法与超类中的\",{\"1\":{\"81\":1}}],[\"方法\",{\"1\":{\"81\":3,\"91\":2,\"103\":1,\"104\":1,\"105\":1,\"106\":5}}],[\"your\",{\"1\":{\"215\":1}}],[\"yourusername\",{\"1\":{\"59\":1}}],[\"you\",{\"1\":{\"215\":1}}],[\"y\",{\"1\":{\"203\":2,\"209\":1}}],[\"year\",{\"1\":{\"83\":1,\"84\":1,\"85\":4,\"86\":4,\"87\":2,\"89\":2,\"93\":1,\"99\":2,\"106\":9}}],[\"工作空间\",{\"0\":{\"236\":1}}],[\"工作原理\",{\"0\":{\"221\":1}}],[\"工作流程简图\",{\"0\":{\"137\":1}}],[\"工厂模式与抽象工厂模式的区别在于\",{\"1\":{\"84\":1}}],[\"工厂方法模式适用于需要创建的对象种类较多\",{\"1\":{\"83\":1}}],[\"工厂方法模式的优点是灵活性\",{\"1\":{\"83\":1}}],[\"工厂方法模式需要定义抽象工厂类\",{\"1\":{\"83\":1}}],[\"工厂方法模式将产品对象的创建过程封装在工厂类中\",{\"1\":{\"83\":1}}],[\"工厂方法模式将对象的创建与使用分离\",{\"1\":{\"83\":3}}],[\"工厂方法模式允许添加新的工厂类和产品类\",{\"1\":{\"83\":1}}],[\"工厂方法模式是一种创建型设计模式\",{\"1\":{\"83\":2}}],[\"工厂方法模式\",{\"0\":{\"83\":1},\"1\":{\"84\":1}}],[\"工具\",{\"0\":{\"251\":1}}],[\"工具如\",{\"1\":{\"146\":1}}],[\"工具配置建议\",{\"0\":{\"19\":1}}],[\"工具链支持\",{\"1\":{\"15\":1}}],[\"just\",{\"1\":{\"215\":1}}],[\"junit框架会负责调用testaddition\",{\"1\":{\"81\":1}}],[\"junit\",{\"1\":{\"81\":2}}],[\"junit是一个用于编写和运行java单元测试的框架\",{\"1\":{\"81\":1}}],[\"j++\",{\"1\":{\"102\":1}}],[\"j\",{\"1\":{\"91\":4,\"102\":4}}],[\"java\",{\"1\":{\"81\":1,\"107\":1}}],[\"workspace\",{\"0\":{\"236\":1}}],[\"working\",{\"1\":{\"215\":1}}],[\"wait\",{\"1\":{\"143\":1,\"145\":1,\"146\":1}}],[\"which\",{\"1\":{\"215\":1}}],[\"white\",{\"1\":{\"94\":2}}],[\"wheels\",{\"1\":{\"105\":2}}],[\"wheelinspector\",{\"1\":{\"97\":16}}],[\"wheel\",{\"1\":{\"91\":5,\"97\":4}}],[\"windows\",{\"1\":{\"221\":1}}],[\"will\",{\"1\":{\"215\":1}}],[\"wireshark\",{\"1\":{\"146\":1,\"155\":1}}],[\"within\",{\"1\":{\"240\":2}}],[\"with\",{\"1\":{\"90\":4,\"105\":2,\"215\":1}}],[\"widget\",{\"1\":{\"81\":5}}],[\"web\",{\"1\":{\"81\":1}}],[\"然后获取这个元素的地址\",{\"1\":{\"195\":1}}],[\"然后取数组的第一个元素的地址\",{\"1\":{\"194\":1}}],[\"然后将这个新字符串赋给s\",{\"1\":{\"171\":1}}],[\"然后创建了一个主管\",{\"1\":{\"85\":1}}],[\"然后\",{\"1\":{\"83\":2,\"84\":1,\"85\":1,\"87\":1,\"89\":2,\"92\":2,\"94\":1,\"95\":1,\"178\":1,\"194\":1}}],[\"然后junit框架负责执行这些测试用例\",{\"1\":{\"81\":1}}],[\"然而\",{\"1\":{\"81\":1,\"171\":1}}],[\"来维持服务绑定\",{\"1\":{\"154\":1}}],[\"来得到答案\",{\"1\":{\"118\":1}}],[\"来处理这些请求和响应\",{\"1\":{\"81\":1}}],[\"来构建整个应用程序的基础架构\",{\"1\":{\"81\":1}}],[\"来减轻类层次结构的压力\",{\"1\":{\"81\":1}}],[\"更新requirements\",{\"1\":{\"216\":1}}],[\"更是通往底层世界的大门\",{\"1\":{\"212\":1}}],[\"更低地址的一页\",{\"1\":{\"204\":1}}],[\"更高效\",{\"1\":{\"171\":1}}],[\"更高的可维护性\",{\"1\":{\"81\":1}}],[\"更小的风险\",{\"1\":{\"81\":1}}],[\"换句话说\",{\"1\":{\"81\":1}}],[\"框架需要控制子类扩展\",{\"1\":{\"105\":1}}],[\"框架提供了一个更为全面和高级的解决方案\",{\"1\":{\"81\":1}}],[\"框架会调用应用程序代码\",{\"1\":{\"81\":1}}],[\"框架控制着应用程序的执行流程\",{\"1\":{\"81\":1}}],[\"具体的做法就是分层下注\",{\"1\":{\"118\":1}}],[\"具体的装饰对象\",{\"1\":{\"92\":1}}],[\"具体分析见下节\",{\"1\":{\"111\":1}}],[\"具体元素实现\",{\"1\":{\"106\":1}}],[\"具体元素\",{\"1\":{\"106\":1}}],[\"具体访问者\",{\"1\":{\"106\":2}}],[\"具体类\",{\"1\":{\"105\":3}}],[\"具体子类\",{\"1\":{\"105\":1}}],[\"具体策略\",{\"1\":{\"104\":5}}],[\"具体状态\",{\"1\":{\"103\":2}}],[\"具体观察者\",{\"1\":{\"102\":4}}],[\"具体主题\",{\"1\":{\"102\":3}}],[\"具体中介者\",{\"1\":{\"100\":2}}],[\"具体聚合\",{\"1\":{\"99\":2}}],[\"具体迭代器\",{\"1\":{\"99\":2}}],[\"具体命令\",{\"1\":{\"98\":2}}],[\"具体处理者\",{\"1\":{\"97\":2}}],[\"具体享元\",{\"1\":{\"94\":1}}],[\"具体装饰\",{\"1\":{\"92\":1}}],[\"具体组件\",{\"1\":{\"92\":1}}],[\"具体实现了组件接口\",{\"1\":{\"91\":1}}],[\"具体实现部分\",{\"1\":{\"90\":4}}],[\"具体原型\",{\"1\":{\"86\":1}}],[\"具体生成器\",{\"1\":{\"85\":2}}],[\"具体工厂\",{\"1\":{\"84\":1}}],[\"具体工厂类\",{\"1\":{\"83\":2}}],[\"具体产品\",{\"1\":{\"84\":1}}],[\"具体产品类\",{\"1\":{\"83\":1}}],[\"具体来说\",{\"1\":{\"81\":1,\"177\":1}}],[\"具有很强的灵活性\",{\"1\":{\"92\":3}}],[\"具有较高的灵活性\",{\"1\":{\"76\":1}}],[\"具有广泛的适用性\",{\"1\":{\"76\":1}}],[\"深拷贝问题和安全问题\",{\"1\":{\"86\":1}}],[\"深拷贝问题\",{\"1\":{\"86\":1}}],[\"深色主题\",{\"1\":{\"81\":1}}],[\"深入\",{\"0\":{\"181\":1}}],[\"深入研究设计模式对于提高软件设计的质量和效率具有重要意义\",{\"1\":{\"69\":1}}],[\"深入探讨了23种经典的设计模式\",{\"1\":{\"68\":1}}],[\"深入设计模式\",{\"0\":{\"66\":1},\"1\":{\"107\":1}}],[\"深入解析\",{\"1\":{\"2\":1}}],[\"文字示意\",{\"0\":{\"141\":1}}],[\"文本框\",{\"1\":{\"81\":1}}],[\"文件模板等\",{\"1\":{\"48\":1}}],[\"控件类型和主题样式\",{\"1\":{\"81\":1}}],[\"控制复杂\",{\"1\":{\"211\":1}}],[\"控制通信生命周期\",{\"1\":{\"135\":1}}],[\"控制子类扩展\",{\"1\":{\"105\":1}}],[\"控制流程\",{\"1\":{\"105\":1}}],[\"控制请求访问\",{\"1\":{\"95\":1}}],[\"控制器硬件可以理解为身体\",{\"1\":{\"46\":1}}],[\"控制系统而设计的\",{\"1\":{\"27\":1}}],[\"或局部变量分配时向低地址方向移动\",{\"1\":{\"199\":1}}],[\"或未正确触发事件发送逻辑\",{\"1\":{\"155\":1}}],[\"或通过某些方式\",{\"1\":{\"126\":1}}],[\"或开市走\",{\"1\":{\"117\":1}}],[\"或者powershell\",{\"1\":{\"222\":1}}],[\"或者通知的频率较高\",{\"1\":{\"102\":1}}],[\"或者需要大量的计算资源\",{\"1\":{\"86\":1}}],[\"或者servlets\",{\"1\":{\"81\":1}}],[\"或\",{\"1\":{\"81\":1,\"120\":1,\"129\":2,\"149\":1,\"202\":1}}],[\"或在\",{\"1\":{\"12\":1}}],[\"你已经成功创建了指定版本的虚拟环境\",{\"1\":{\"222\":1}}],[\"你会成功的\",{\"1\":{\"129\":1}}],[\"你会怎么办\",{\"1\":{\"118\":1}}],[\"你将看到命令提示符或者powershell的提示符前面有\",{\"1\":{\"222\":1}}],[\"你将看到输出结果为data\",{\"1\":{\"178\":1}}],[\"你将以最少的代价得到最多的乐趣\",{\"1\":{\"128\":1}}],[\"你将成为失败者\",{\"1\":{\"118\":1}}],[\"你可能较其它行的从业者富有\",{\"1\":{\"128\":1}}],[\"你可以指定要使用的python解释器的完径\",{\"1\":{\"222\":1}}],[\"你可以在python官方网站上下载和安装所需的python版本\",{\"1\":{\"222\":1}}],[\"你可以使用python的内置工具venv来创建指定版本的虚拟环境\",{\"1\":{\"222\":1}}],[\"你可以选择使用一个完整的web框架\",{\"1\":{\"81\":1}}],[\"你可以根据具体的需求选择性地替换或者更新中间层次的组件\",{\"1\":{\"81\":1}}],[\"你可以更容易地理解和管理这些组件\",{\"1\":{\"81\":1}}],[\"你可以更加灵活地选择性地应用一些特定的模式或者组件\",{\"1\":{\"81\":1}}],[\"你可以编写测试用例\",{\"1\":{\"81\":1}}],[\"你做什么都可以\",{\"1\":{\"127\":1}}],[\"你每天都在寻找对你有利的信息\",{\"1\":{\"125\":1}}],[\"你总会编出理由来证明你应该得到更多\",{\"1\":{\"125\":1}}],[\"你对\",{\"1\":{\"125\":1}}],[\"你能战胜市场\",{\"1\":{\"124\":1}}],[\"你也非不着太聪明\",{\"1\":{\"124\":1}}],[\"你也可以选择使用中间层次的组件\",{\"1\":{\"81\":1}}],[\"你要准备\",{\"1\":{\"125\":1}}],[\"你要相信自己\",{\"1\":{\"125\":1}}],[\"你要有点贪念\",{\"1\":{\"124\":1}}],[\"你要很大的力\",{\"1\":{\"116\":1}}],[\"你永远不知股票会升多高\",{\"1\":{\"122\":1}}],[\"你就有了生存的可能\",{\"1\":{\"129\":1}}],[\"你就走上了学股的正确道路\",{\"1\":{\"121\":1}}],[\"你就知道该怎样做了\",{\"1\":{\"118\":1}}],[\"你最好什么都别买\",{\"1\":{\"121\":1}}],[\"你大约已赢多过输\",{\"1\":{\"120\":1}}],[\"你炒股大概常亏钱\",{\"1\":{\"120\":1}}],[\"你在股市就有了50\",{\"1\":{\"129\":1}}],[\"你在这行成功的机会就不大\",{\"1\":{\"118\":1}}],[\"你在炒股时每次犯错\",{\"1\":{\"118\":1}}],[\"你从小学习的那些讨人喜欢的性格\",{\"1\":{\"118\":1}}],[\"你主要通过研究\",{\"1\":{\"118\":1}}],[\"你如果随大流\",{\"1\":{\"118\":1}}],[\"你如果有60\",{\"1\":{\"118\":1}}],[\"你手上持有股票的上升潜力必须大过下跌的可能\",{\"1\":{\"118\":1}}],[\"你的交易方式必须和你的个性相符合\",{\"1\":{\"124\":1}}],[\"你的体会就会深一层\",{\"1\":{\"118\":1}}],[\"你的获胜概率就被大打折扣了\",{\"1\":{\"117\":1}}],[\"你的测试用例类会继承junit提供的测试类\",{\"1\":{\"81\":1}}],[\"你很快就会发现股票运动是有迹可循的\",{\"1\":{\"116\":1}}],[\"你必须有\",{\"1\":{\"124\":1}}],[\"你必须有自信\",{\"1\":{\"124\":1}}],[\"你必须有耐心\",{\"1\":{\"124\":1}}],[\"你必须独立思考\",{\"1\":{\"124\":1}}],[\"你必须牢牢记住这一点\",{\"1\":{\"116\":1}}],[\"你必须遵循框架所定义的规则和约定\",{\"1\":{\"81\":1}}],[\"你常常面对两个选择\",{\"1\":{\"111\":1}}],[\"你们选择太多\",{\"1\":{\"111\":1}}],[\"你开始看这本书\",{\"1\":{\"111\":1}}],[\"你不把\",{\"1\":{\"118\":1}}],[\"你不明白自己为何亏了钱\",{\"1\":{\"111\":1}}],[\"你不知道它还会跌多少\",{\"1\":{\"120\":1}}],[\"你不知下次要怎么办才能重复赚钱的经历\",{\"1\":{\"111\":1}}],[\"你不知自己为何赚了钱\",{\"1\":{\"111\":1}}],[\"你提到的这种情况通常被称为\",{\"1\":{\"81\":1}}],[\"你需要确保新行为与其基类中的版本兼容\",{\"1\":{\"81\":1}}],[\"类似地\",{\"1\":{\"177\":1}}],[\"类似公司的情况\",{\"1\":{\"114\":1}}],[\"类行为\",{\"1\":{\"149\":1}}],[\"类的数量增加\",{\"1\":{\"103\":1}}],[\"类数量增加\",{\"1\":{\"98\":1}}],[\"类提供了一些实用的业务逻辑\",{\"1\":{\"95\":1}}],[\"类层次结构将会急剧膨胀\",{\"1\":{\"81\":1}}],[\"类中的不同\",{\"1\":{\"81\":1}}],[\"类中的\",{\"1\":{\"81\":1}}],[\"类重写了\",{\"1\":{\"81\":1}}],[\"类型检查只能在运行时进行\",{\"1\":{\"91\":1}}],[\"类型安全性较低\",{\"1\":{\"91\":1}}],[\"类型必须一致\",{\"1\":{\"20\":1}}],[\"类型\",{\"1\":{\"5\":1,\"22\":1,\"146\":1,\"194\":1,\"195\":2}}],[\"函数为例\",{\"1\":{\"203\":1}}],[\"函数声明\",{\"1\":{\"177\":1}}],[\"函数充当\",{\"1\":{\"101\":1}}],[\"函数在处理\",{\"1\":{\"81\":2}}],[\"函数在处理子类对象时不会出现问题\",{\"1\":{\"81\":1}}],[\"函数并传递\",{\"1\":{\"81\":1}}],[\"函数接受一个\",{\"1\":{\"81\":1}}],[\"函数\",{\"1\":{\"81\":1}}],[\"里我会较为详细地谈谈学股经历的几个过程\",{\"1\":{\"125\":1}}],[\"里面有一个\",{\"1\":{\"81\":1}}],[\"里氏替换原则\",{\"1\":{\"81\":1}}],[\"举个例子\",{\"1\":{\"81\":2}}],[\"参数和变量分区\",{\"1\":{\"211\":1}}],[\"参数和变量容易冲突\",{\"1\":{\"209\":1}}],[\"参数7\",{\"1\":{\"206\":1}}],[\"参数编号\",{\"1\":{\"206\":1}}],[\"参数主要通过寄存器传递\",{\"1\":{\"206\":1}}],[\"参数在栈中哪里\",{\"0\":{\"206\":1}}],[\"参数列表和返回类型\",{\"1\":{\"81\":1}}],[\"参考链接\",{\"0\":{\"40\":1,\"54\":1,\"217\":1,\"223\":1},\"1\":{\"58\":1,\"172\":1,\"178\":1}}],[\"当python解释器在虚拟环境中运行时\",{\"1\":{\"221\":1}}],[\"当前栈帧上方\",{\"1\":{\"206\":1}}],[\"当extern用于变量声明时\",{\"1\":{\"177\":1}}],[\"当年也不是没有头脑清醒的人\",{\"1\":{\"126\":1}}],[\"当成小赌怡情\",{\"1\":{\"128\":1}}],[\"当成卖的理由\",{\"1\":{\"124\":1}}],[\"当成买的理由\",{\"1\":{\"124\":1}}],[\"当成习惯\",{\"1\":{\"118\":1}}],[\"当然\",{\"1\":{\"118\":1}}],[\"当对象结构中的元素类经常变化\",{\"1\":{\"106\":1}}],[\"当一个对象结构包含多个类型的对象\",{\"1\":{\"106\":1}}],[\"当一个子类的对象可以替换其父类的对象时\",{\"1\":{\"81\":1}}],[\"当主题的状态发生变化时调用\",{\"1\":{\"102\":1}}],[\"当主题的状态发生变化时通知观察者\",{\"1\":{\"102\":1}}],[\"当汽车的状态\",{\"1\":{\"102\":1}}],[\"当客户端需要使用不同的汽车品牌时\",{\"1\":{\"93\":1}}],[\"当子系统中的具体实现类发生变化时\",{\"1\":{\"93\":3}}],[\"当现有的接口与客户端期望的接口不兼容时\",{\"1\":{\"89\":1}}],[\"当需要对现有的对象结构添加新的操作而不改变其结构时\",{\"1\":{\"106\":1}}],[\"当需要提高系统的灵活性时\",{\"1\":{\"93\":1}}],[\"当需要提高系统的可维护性时\",{\"1\":{\"93\":1}}],[\"当需要提高代码的可扩展性时\",{\"1\":{\"89\":1}}],[\"当需要提高代码的复用性和灵活性时\",{\"1\":{\"89\":1}}],[\"当需要为一个复杂的子系统提供一个简单的接口时\",{\"1\":{\"93\":1}}],[\"当需要创建的对象具有不同的配置选项\",{\"1\":{\"84\":1,\"85\":1}}],[\"当需要创建的对象具有不同的实现方式\",{\"1\":{\"84\":1,\"85\":1}}],[\"当需要创建的对象具有复杂的结构\",{\"1\":{\"84\":1,\"85\":1}}],[\"当需要创建的对象种类较多\",{\"1\":{\"83\":1}}],[\"当需要修改产品族的实现时\",{\"1\":{\"84\":1}}],[\"当需要添加新的产品族时\",{\"1\":{\"84\":3}}],[\"当需要将对象的创建过程与使用过程分离时\",{\"1\":{\"83\":1}}],[\"当需要在不同的条件下创建不同的对象时\",{\"1\":{\"83\":1}}],[\"当需要执行某些操作时\",{\"1\":{\"81\":1}}],[\"当你执行s\",{\"1\":{\"171\":2}}],[\"当你判定股票大市属于\",{\"1\":{\"121\":1}}],[\"当你运行这个测试类时\",{\"1\":{\"81\":1}}],[\"当你重写一个方法时\",{\"1\":{\"81\":1}}],[\"相对性能提升\",{\"1\":{\"187\":1}}],[\"相对应地\",{\"1\":{\"46\":1}}],[\"相互竞争服务实例\",{\"1\":{\"135\":1}}],[\"相互通信\",{\"1\":{\"100\":1}}],[\"相比之下\",{\"1\":{\"81\":1}}],[\"相同\",{\"1\":{\"81\":1}}],[\"相信你不会希望这些代码崩溃的\",{\"1\":{\"81\":1}}],[\"因循守旧和耿于报复\",{\"1\":{\"111\":1}}],[\"因为它需要考虑各种编译器和目标平台的特定细节\",{\"1\":{\"194\":1}}],[\"因为它允许多个文件共享相同的全局变量\",{\"1\":{\"177\":1}}],[\"因为它修改现有对象\",{\"1\":{\"171\":1}}],[\"因为它有可能避免创建新的字符串对象\",{\"1\":{\"171\":1}}],[\"因为它是大众投资心理的反映\",{\"1\":{\"120\":1}}],[\"因为一定有利息\",{\"1\":{\"127\":1}}],[\"因为每次赚了大钱\",{\"1\":{\"127\":1}}],[\"因为每个功能维度可能都需要一组不同的特性或行为\",{\"1\":{\"81\":1}}],[\"因为人们常常做不到自己知道该做的事情\",{\"1\":{\"118\":1}}],[\"因为掌握股票正常运动的特点对炒股成功是极其重要的\",{\"1\":{\"118\":1}}],[\"因为他们没有办法长期承担这样的心理压力\",{\"1\":{\"111\":1}}],[\"因为赚钱时\",{\"1\":{\"111\":1}}],[\"因为请求要经过多个处理者\",{\"1\":{\"97\":1}}],[\"因为代理对象需要实现与真实对象相同的接口\",{\"1\":{\"95\":1}}],[\"因为代理对象需要进行额外的处理\",{\"1\":{\"95\":1}}],[\"因为外观类需要将客户端的请求转发给子系统中的具体实现类\",{\"1\":{\"93\":1}}],[\"因为外观类需要了解子系统的具体实现细节\",{\"1\":{\"93\":1}}],[\"因为中间层次的组件通常比整个框架更为简单和可控\",{\"1\":{\"81\":1}}],[\"因为测试方法的调用是由junit框架触发的\",{\"1\":{\"81\":1}}],[\"因为子类的所有对象都可能被传递给以超类\",{\"1\":{\"81\":1}}],[\"因此在当前文件中不需要为其分配存储空间\",{\"1\":{\"177\":1}}],[\"因此你需要判定大势的走向\",{\"1\":{\"124\":1}}],[\"因此可能会影响代码的性能\",{\"1\":{\"85\":1}}],[\"因此代码结构比较复杂\",{\"1\":{\"85\":1}}],[\"因此抽象工厂类的设计难度较大\",{\"1\":{\"84\":1}}],[\"因此\",{\"1\":{\"69\":1,\"81\":3,\"94\":1,\"95\":1,\"193\":1}}],[\"07\",{\"1\":{\"187\":1}}],[\"06\",{\"1\":{\"187\":2}}],[\"0x03\",{\"1\":{\"149\":3}}],[\"0x02\",{\"1\":{\"149\":3}}],[\"0x01\",{\"1\":{\"149\":3}}],[\"0x00000000\",{\"1\":{\"199\":1}}],[\"0x0001\",{\"1\":{\"147\":1}}],[\"0x00\",{\"1\":{\"149\":4}}],[\"0x8001\",{\"1\":{\"147\":1}}],[\"0x1234\",{\"1\":{\"147\":1}}],[\"0xffffffff\",{\"1\":{\"199\":1}}],[\"0xffff\",{\"1\":{\"139\":1}}],[\"0\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":5,\"92\":1,\"93\":1,\"94\":3,\"95\":1,\"97\":4,\"98\":1,\"99\":4,\"100\":3,\"101\":1,\"102\":6,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"147\":1,\"149\":12,\"151\":1,\"152\":1,\"155\":1,\"160\":4,\"178\":1,\"187\":6,\"194\":3,\"195\":10}}],[\"0和复杂驱动等各个基础软件技术栈\",{\"1\":{\"46\":1}}],[\"汽车特性展示访问者\",{\"1\":{\"106\":1}}],[\"汽车制造过程\",{\"1\":{\"105\":1}}],[\"汽车有不同的驾驶模式\",{\"1\":{\"104\":1}}],[\"汽车有不同的状态\",{\"1\":{\"103\":1}}],[\"汽车有一个\",{\"1\":{\"81\":1}}],[\"汽车的状态\",{\"1\":{\"101\":1}}],[\"汽车集合结构体\",{\"1\":{\"99\":1}}],[\"汽车检查器\",{\"1\":{\"97\":1}}],[\"汽车已安装天窗\",{\"1\":{\"92\":1}}],[\"汽车已安装\",{\"1\":{\"92\":1}}],[\"汽车可以由不同的零部件组合而成\",{\"1\":{\"91\":1}}],[\"汽车零部件\",{\"1\":{\"91\":3}}],[\"汽车\",{\"1\":{\"90\":1,\"91\":3,\"98\":2,\"102\":1,\"106\":1}}],[\"汽车结构体\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"99\":1}}],[\"汽车是交通工具\",{\"1\":{\"81\":1}}],[\"汽车是一个高层模块\",{\"1\":{\"81\":1}}],[\"汽车不应该直接依赖于具体的引擎实现\",{\"1\":{\"81\":1}}],[\"引言\",{\"0\":{\"111\":1}}],[\"引入了许多新类和对象\",{\"1\":{\"98\":1}}],[\"引入了更多的类和接口\",{\"1\":{\"90\":1}}],[\"引入中间\",{\"1\":{\"14\":1}}],[\"引擎检查器\",{\"1\":{\"97\":1}}],[\"引擎\",{\"1\":{\"81\":1,\"100\":1}}],[\"引擎是一个低层模块\",{\"1\":{\"81\":1}}],[\"软件组件是类型\",{\"1\":{\"239\":1}}],[\"软件控制器\",{\"1\":{\"135\":1}}],[\"软件的行为不会发生变化\",{\"1\":{\"81\":1}}],[\"软件实体应该对扩展开放\",{\"1\":{\"81\":1}}],[\"优化之路永无止境\",{\"1\":{\"191\":1}}],[\"优化大致分为三个阶段\",{\"1\":{\"183\":1}}],[\"优化等级\",{\"1\":{\"182\":1,\"187\":1}}],[\"优化等级概览\",{\"0\":{\"182\":1}}],[\"优化原理深入解析\",{\"0\":{\"183\":1}}],[\"优化原理\",{\"0\":{\"181\":1}}],[\"优先级\",{\"1\":{\"162\":1}}],[\"优先级通过报文的标识符\",{\"1\":{\"29\":1}}],[\"优点\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"优秀的设计应该具备以下特征\",{\"1\":{\"81\":1}}],[\"优秀设计的特征\",{\"0\":{\"81\":1}}],[\"命令对象可以支持请求的排队\",{\"1\":{\"98\":1}}],[\"命令对象可以实现撤销和重做操作\",{\"1\":{\"98\":1}}],[\"命令的组合\",{\"1\":{\"98\":1}}],[\"命令接口\",{\"1\":{\"98\":2}}],[\"命令模式可以用于控制汽车的各种操作\",{\"1\":{\"98\":1}}],[\"命令模式可以很方便地实现操作的撤销和重做功能\",{\"1\":{\"98\":1}}],[\"命令模式通过将请求封装成对象\",{\"1\":{\"98\":1}}],[\"命令模式将请求封装成对象\",{\"1\":{\"98\":1}}],[\"命令模式主要包括以下几个部分\",{\"1\":{\"98\":1}}],[\"命令模式是一种行为型设计模式\",{\"1\":{\"98\":1}}],[\"命令模式\",{\"0\":{\"98\":1},\"1\":{\"79\":1,\"97\":1}}],[\"命令执行\",{\"1\":{\"6\":1}}],[\"外观类通常包含一些与子系统相关的业务逻辑\",{\"1\":{\"93\":1}}],[\"外观类是外观模式的核心\",{\"1\":{\"93\":1}}],[\"外观类\",{\"1\":{\"93\":1}}],[\"外观模式适用于当需要为一个复杂的子系统提供一个简单的接口\",{\"1\":{\"93\":1}}],[\"外观模式的优点是简化了客户端的代码\",{\"1\":{\"93\":1}}],[\"外观模式可以将子系统中的具体实现类隐藏起来\",{\"1\":{\"93\":1}}],[\"外观模式可以为一个复杂的子系统提供一个简单的接口\",{\"1\":{\"93\":1}}],[\"外观模式可以根据客户端的需求\",{\"1\":{\"93\":2}}],[\"外观模式将子系统中的具体实现类隐藏起来\",{\"1\":{\"93\":2}}],[\"外观模式为子系统中的一组接口提供了一个统一的高层接口\",{\"1\":{\"93\":2}}],[\"外观模式是一种结构型设计模式\",{\"1\":{\"93\":2}}],[\"外观模式\",{\"0\":{\"93\":1},\"1\":{\"79\":1}}],[\"外部连接\",{\"1\":{\"21\":1}}],[\"桥接模式通过分离抽象部分和实现部分\",{\"1\":{\"90\":1}}],[\"桥接模式提高了系统的可扩展性\",{\"1\":{\"90\":1}}],[\"桥接模式主要包括以下几个部分\",{\"1\":{\"90\":1}}],[\"桥接模式是一种结构型设计模式\",{\"1\":{\"90\":1}}],[\"桥接模式\",{\"0\":{\"90\":1},\"1\":{\"79\":1}}],[\"并启用一些违反标准的优化\",{\"1\":{\"182\":1}}],[\"并总结一套实用的优化实践指南\",{\"1\":{\"181\":1}}],[\"并由\",{\"1\":{\"156\":1}}],[\"并不会因为某个\",{\"1\":{\"153\":1}}],[\"并根据需要选择合适的策略\",{\"1\":{\"104\":1}}],[\"并根据状态的变化执行相应的行为\",{\"1\":{\"103\":1}}],[\"并通知相关的监控系统\",{\"1\":{\"102\":1}}],[\"并通过上下文调用代码生成器菜单\",{\"1\":{\"244\":1}}],[\"并通过myobject\",{\"1\":{\"178\":1}}],[\"并通过getcar方法获取了多个汽车享元对象\",{\"1\":{\"94\":1}}],[\"并通过调用sellcar函数来销售汽车\",{\"1\":{\"93\":1}}],[\"并维护主题的状态\",{\"1\":{\"102\":1}}],[\"并维护对实现部分的引用\",{\"1\":{\"90\":1}}],[\"并防止其他对象访问备忘录\",{\"1\":{\"101\":1}}],[\"并使用python\",{\"1\":{\"222\":1}}],[\"并使用备忘录对象恢复其内部状态\",{\"1\":{\"101\":1}}],[\"并使用createdecorator函数为汽车对象创建了两个装饰对象\",{\"1\":{\"92\":1}}],[\"并简化了对象之间的交互\",{\"1\":{\"100\":1}}],[\"并希望支持多种遍历方式的场景\",{\"1\":{\"99\":1}}],[\"并负责遍历聚合对象中的元素\",{\"1\":{\"99\":1}}],[\"并支持请求的撤销和重做操作\",{\"1\":{\"98\":1}}],[\"并提交请求进行测试\",{\"1\":{\"97\":1}}],[\"并提供设置策略的方法\",{\"1\":{\"104\":1}}],[\"并提供注册\",{\"1\":{\"102\":1}}],[\"并提供接口的默认实现\",{\"1\":{\"91\":1}}],[\"并提供playmusic和navigate方法\",{\"1\":{\"90\":1}}],[\"并提供了一个全局访问点来访问该实例\",{\"1\":{\"87\":1}}],[\"并提供了设置产品参数的方法\",{\"1\":{\"85\":1}}],[\"并提供一个方法来返回具体迭代器的实例\",{\"1\":{\"99\":1}}],[\"并提供一个公共静态方法来获取该实例\",{\"1\":{\"87\":1}}],[\"并提供一个全局访问点来访问该实例\",{\"1\":{\"87\":1}}],[\"并包含创建备忘录和从备忘录恢复状态的方法\",{\"1\":{\"101\":1}}],[\"并包含对下一个处理者的引用nextinspector\",{\"1\":{\"97\":1}}],[\"并包含对下一个处理者的引用\",{\"1\":{\"97\":1}}],[\"并包含一个子节点数组\",{\"1\":{\"91\":1}}],[\"并沿着这条链传递请求\",{\"1\":{\"97\":1}}],[\"并允许在将请求提交给对象前后进行一些处理\",{\"1\":{\"95\":1}}],[\"并在状态改变时通知所有观察者\",{\"1\":{\"102\":1}}],[\"并在处理不了请求时将其传递给下一个处理者\",{\"1\":{\"97\":1}}],[\"并在不修改原类的情况下添加额外的行为\",{\"1\":{\"92\":1}}],[\"并在构建汽车时创建了一个汽车结构体的实例\",{\"1\":{\"85\":1}}],[\"并创建了一个适配器对象adapter\",{\"1\":{\"89\":1}}],[\"并将每一个算法封装起来\",{\"1\":{\"104\":2}}],[\"并将其转换为\",{\"1\":{\"195\":1}}],[\"并将其与代理关联\",{\"1\":{\"95\":1}}],[\"并将其销售出去\",{\"1\":{\"93\":1}}],[\"并将其传递给car构造函数\",{\"1\":{\"81\":1}}],[\"并将叶子节点添加到组合节点中\",{\"1\":{\"91\":1}}],[\"并将传统燃油汽车对象作为参数传递给适配器的构造函数\",{\"1\":{\"89\":1}}],[\"并打印了它们的信息\",{\"1\":{\"94\":1}}],[\"并打印汽车的信息\",{\"1\":{\"87\":1}}],[\"并打印出汽车的信息\",{\"1\":{\"83\":1,\"84\":1}}],[\"并输出了汽车的信息\",{\"1\":{\"85\":1}}],[\"并设置汽车的模型和年份信息\",{\"1\":{\"83\":1,\"84\":1}}],[\"并返回创建的汽车指针\",{\"1\":{\"83\":1,\"84\":1}}],[\"并检查其结果是否符合预期\",{\"1\":{\"81\":1}}],[\"并且您可以运行已安装的脚本而不必使用它们的完整路径\",{\"1\":{\"221\":1}}],[\"并且可以在该环境中安装和运行特定版本的python程序\",{\"1\":{\"222\":1}}],[\"并且可以动态地更换策略\",{\"1\":{\"104\":1}}],[\"并且可以切换状态\",{\"1\":{\"103\":1}}],[\"并且可以用于实现撤销操作\",{\"1\":{\"101\":1}}],[\"并且可以独立地改变它们之间的交互\",{\"1\":{\"100\":1}}],[\"并且可以灵活地改变处理者的顺序\",{\"1\":{\"97\":1}}],[\"并且希望使用统一的遍历接口\",{\"1\":{\"99\":1}}],[\"并且支持请求的排队\",{\"1\":{\"98\":1}}],[\"并且在运行时需要动态地选择装饰类\",{\"1\":{\"92\":1}}],[\"并且这两个维度都需要独立扩展\",{\"1\":{\"90\":1}}],[\"并且需要在抽象工厂类中添加相应的抽象方法\",{\"1\":{\"84\":1}}],[\"并且需要花费更多的时间来学习和理解整个框架的工作原理\",{\"1\":{\"81\":1}}],[\"并且降低引入新技术所带来的风险\",{\"1\":{\"81\":1}}],[\"并且junit框架在需要执行这些方法时会主动调用它们\",{\"1\":{\"81\":1}}],[\"并且你会覆盖一些方法或者使用注解来标记测试方法\",{\"1\":{\"81\":1}}],[\"并且不会导致类层次结构的爆炸性增长\",{\"1\":{\"81\":1}}],[\"并向你报告测试结果\",{\"1\":{\"81\":1}}],[\"并为它们应用不同的主题样式\",{\"1\":{\"81\":1}}],[\"并同时保持结构的灵活和高效\",{\"1\":{\"79\":1}}],[\"并用c语言简单举例\",{\"1\":{\"66\":1}}],[\"抽象\",{\"0\":{\"147\":1}}],[\"抽象元素\",{\"1\":{\"106\":3}}],[\"抽象访问者\",{\"1\":{\"106\":2}}],[\"抽象类中的模板方法定义了算法的框架和步骤顺序\",{\"1\":{\"105\":1}}],[\"抽象类\",{\"1\":{\"105\":3}}],[\"抽象处理者\",{\"1\":{\"97\":3}}],[\"抽象部分\",{\"1\":{\"90\":3}}],[\"抽象部署在同一ecu或者不同ecu上的应用之间的通信\",{\"1\":{\"46\":1}}],[\"抽象产品\",{\"1\":{\"84\":1}}],[\"抽象产品类和具体产品类\",{\"1\":{\"83\":1}}],[\"抽象产品类\",{\"1\":{\"83\":1}}],[\"抽象工厂\",{\"1\":{\"84\":1}}],[\"抽象工厂函数\",{\"1\":{\"83\":1,\"84\":1}}],[\"抽象工厂类需要定义多个抽象方法来创建不同的产品\",{\"1\":{\"84\":1}}],[\"抽象工厂类的设计难度较大\",{\"1\":{\"84\":1}}],[\"抽象工厂类\",{\"1\":{\"83\":1}}],[\"抽象工厂模式可以根据不同的需求创建不同的产品族\",{\"1\":{\"84\":2}}],[\"抽象工厂模式支持产品族的扩展\",{\"1\":{\"84\":2}}],[\"抽象工厂模式将产品的创建过程封装在抽象工厂类中\",{\"1\":{\"84\":2}}],[\"抽象工厂模式是一种创建型设计模式\",{\"1\":{\"84\":2}}],[\"抽象工厂模式\",{\"0\":{\"84\":1},\"1\":{\"79\":1,\"84\":1}}],[\"能收到服务信息\",{\"1\":{\"153\":1}}],[\"能够在运行时动态发现服务并实现通信绑定\",{\"1\":{\"133\":1}}],[\"能够提升已有代码的灵活性和可复用性\",{\"1\":{\"79\":1}}],[\"能提供快速的增长\",{\"1\":{\"126\":1}}],[\"能通过同一接口与服务或代理进行交互\",{\"1\":{\"95\":1}}],[\"能极大提高系统的可维护性和工具链兼容性\",{\"0\":{\"24\":1}}],[\"404\",{\"1\":{\"247\":1}}],[\"40米\",{\"1\":{\"28\":1}}],[\"41\",{\"1\":{\"187\":1}}],[\"4\",{\"0\":{\"79\":1,\"205\":1,\"241\":1},\"1\":{\"81\":1,\"91\":2,\"113\":1,\"114\":1,\"116\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"143\":1,\"195\":1,\"203\":2,\"206\":1}}],[\"但c语言本身并不直接支持面向对象编程\",{\"1\":{\"178\":1}}],[\"但实际的定义在其他文件中\",{\"1\":{\"177\":1}}],[\"但并不会分配实际的存储空间\",{\"1\":{\"177\":1}}],[\"但extern仅用于声明\",{\"1\":{\"176\":1}}],[\"但发送频率随状态机阶段变化\",{\"1\":{\"153\":1}}],[\"但成为富豪在天不在人\",{\"1\":{\"128\":1}}],[\"但我希望你能有一个不求人的一技之长\",{\"1\":{\"127\":1}}],[\"但我常听到炒股的人居然会为亏钱而自豪\",{\"1\":{\"118\":1}}],[\"但必须复杂到很难用事实证明其对错\",{\"1\":{\"126\":1}}],[\"但市场用不断升高证明他们论断的错误\",{\"1\":{\"126\":1}}],[\"但他们太早了一步\",{\"1\":{\"126\":1}}],[\"但进场\",{\"1\":{\"124\":1}}],[\"但就我的亲身经历\",{\"1\":{\"124\":1}}],[\"但有一点可以确定\",{\"1\":{\"120\":1}}],[\"但有些步骤因子类而异\",{\"1\":{\"105\":1}}],[\"但优秀的投资者会看得更远一步\",{\"1\":{\"118\":1}}],[\"但问题是他们没有足够的知识和经验判定何时是春天\",{\"1\":{\"118\":1}}],[\"但炒股需要不同的思维方式\",{\"1\":{\"118\":1}}],[\"但炒友们必须牢牢记住\",{\"1\":{\"118\":1}}],[\"但它铺平了累积巨额财富的道路\",{\"1\":{\"126\":1}}],[\"但它用来评估信息社会的企业可能并不十分合适\",{\"1\":{\"117\":1}}],[\"但它的签名和预期行为与超类\",{\"1\":{\"81\":1}}],[\"但一定要在心理上不断提醒自己\",{\"1\":{\"117\":1}}],[\"但指数不升\",{\"1\":{\"117\":1}}],[\"但石球往下\",{\"1\":{\"116\":1}}],[\"但跌波的每个波峰较上一波峰为低\",{\"1\":{\"116\":1}}],[\"但也可能会导致系统的复杂性增加\",{\"1\":{\"106\":1}}],[\"但操作算法相对稳定时\",{\"1\":{\"106\":1}}],[\"但不会分配实际的存储空间\",{\"1\":{\"177\":1}}],[\"但不能太多\",{\"1\":{\"124\":1}}],[\"但不能操作或检查备忘录的内容\",{\"1\":{\"101\":1}}],[\"但不明显\",{\"1\":{\"120\":1}}],[\"但不可能改变大势\",{\"1\":{\"117\":1}}],[\"但不提供具体实现\",{\"1\":{\"90\":1}}],[\"但是具体由哪个对象处理请求在运行时动态决定\",{\"1\":{\"97\":1}}],[\"但是\",{\"1\":{\"93\":2,\"94\":1,\"95\":1}}],[\"但对于component来说\",{\"1\":{\"92\":1}}],[\"但让子类决定实例化哪个类\",{\"1\":{\"83\":2}}],[\"但需要自己确定实现步骤\",{\"1\":{\"78\":1}}],[\"但仅发送自身负责的\",{\"1\":{\"18\":1}}],[\"解析回复\",{\"1\":{\"157\":1}}],[\"解决了什么\",{\"0\":{\"134\":1}}],[\"解决方案\",{\"2\":{\"56\":1}}],[\"解除压力\",{\"1\":{\"124\":1}}],[\"解耦\",{\"1\":{\"102\":1}}],[\"解耦请求发送者和接收者\",{\"1\":{\"98\":1}}],[\"解释问题并说明模式会如何提供解决方案\",{\"1\":{\"77\":1}}],[\"意图\",{\"1\":{\"77\":1}}],[\"灵活性和可扩展性\",{\"1\":{\"85\":1,\"89\":1}}],[\"灵活性\",{\"1\":{\"76\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"模板方法定义了算法的骨架\",{\"1\":{\"105\":1}}],[\"模板方法将公共的步骤实现在抽象类中\",{\"1\":{\"105\":1}}],[\"模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤\",{\"1\":{\"105\":1}}],[\"模板方法模式通过定义一个算法的骨架\",{\"1\":{\"105\":1}}],[\"模板方法模式通常由以下几个部分组成\",{\"1\":{\"105\":1}}],[\"模板方法模式是一种行为型设计模式\",{\"1\":{\"105\":1}}],[\"模板方法模式\",{\"0\":{\"105\":1}}],[\"模板方法模式和访问者模式\",{\"1\":{\"79\":1}}],[\"模拟不同的汽车零部件\",{\"1\":{\"97\":1}}],[\"模拟请求\",{\"1\":{\"95\":1}}],[\"模式与实践\",{\"1\":{\"107\":1}}],[\"模式的本质\",{\"1\":{\"81\":1}}],[\"模式比框架更小且更抽象\",{\"1\":{\"81\":1}}],[\"模式像蓝图\",{\"1\":{\"78\":1}}],[\"模式和算法的区别\",{\"0\":{\"78\":1}}],[\"模式构成\",{\"0\":{\"77\":1}}],[\"模式切换\",{\"0\":{\"36\":1}}],[\"模块以及它们之间的关系和交互\",{\"1\":{\"74\":1}}],[\"组成\",{\"0\":{\"139\":1,\"156\":1}}],[\"组合is有\",{\"1\":{\"81\":1}}],[\"组合是代替继承的一种方法\",{\"1\":{\"81\":1}}],[\"组合优于继承\",{\"1\":{\"81\":2}}],[\"组合模式通过定义统一的接口\",{\"1\":{\"91\":1}}],[\"组合模式能清晰地表示对象的层次结构\",{\"1\":{\"91\":1}}],[\"组合模式主要包括以下几个部分\",{\"1\":{\"91\":1}}],[\"组合模式使得客户端可以统一对待单个对象和组合对象\",{\"1\":{\"91\":1}}],[\"组合模式是一种结构型设计模式\",{\"1\":{\"91\":1}}],[\"组合模式\",{\"0\":{\"91\":1},\"1\":{\"79\":1}}],[\"组件\",{\"1\":{\"74\":1,\"91\":2,\"92\":1,\"157\":1}}],[\"组网灵活\",{\"1\":{\"29\":1}}],[\"蓝图更多关注的是整体结构和规划\",{\"1\":{\"74\":1}}],[\"蓝图通常指的是系统或应用的高层设计\",{\"1\":{\"74\":1}}],[\"蓝图\",{\"0\":{\"74\":1}}],[\"使\",{\"1\":{\"138\":1}}],[\"使一般投资者入场买股票的原因最主要的就是因为股票在升\",{\"1\":{\"116\":1}}],[\"使股民蒙受超出预期损失的第二个原因则是人性中的吃不得小亏的心理\",{\"1\":{\"111\":1}}],[\"使它们可以相互替换\",{\"1\":{\"104\":1}}],[\"使它们可以独立变化\",{\"1\":{\"90\":1}}],[\"使状态切换更加清晰\",{\"1\":{\"103\":1}}],[\"使各同事类不需要显式地相互引用\",{\"1\":{\"100\":2}}],[\"使各个对象不需要显式地相互引用\",{\"1\":{\"100\":1}}],[\"使请求的发送者与接收者解耦\",{\"1\":{\"98\":1}}],[\"使得代码更加易于维护和理解\",{\"1\":{\"106\":1}}],[\"使得代码更加清晰易读\",{\"1\":{\"94\":2}}],[\"使得可以在不改变元素类的情况下增加新操作\",{\"1\":{\"106\":1}}],[\"使得操作可以独立变化而不影响数据结构\",{\"1\":{\"106\":1}}],[\"使得它们可以相互替换\",{\"1\":{\"104\":1}}],[\"使得它们可以独立变化\",{\"1\":{\"90\":1}}],[\"使得算法可以独立于使用它的客户而变化\",{\"1\":{\"104\":1}}],[\"使得算法可以独立于集合对象变化\",{\"1\":{\"99\":1}}],[\"使得状态切换更加清晰和可管理\",{\"1\":{\"103\":1}}],[\"使得状态切换更加明确和可管理\",{\"1\":{\"103\":1}}],[\"使得主题和观察者之间的交互更加灵活和松散耦合\",{\"1\":{\"102\":1}}],[\"使得当一个对象的状态发生变化时\",{\"1\":{\"102\":1}}],[\"使得修改和扩展交互行为更加方便\",{\"1\":{\"100\":1}}],[\"使得系统更易于理解和维护\",{\"1\":{\"100\":1}}],[\"使得系统更容易理解和维护\",{\"1\":{\"100\":1}}],[\"使得系统更加灵活\",{\"1\":{\"83\":1}}],[\"使得系统更加灵活和可扩展\",{\"1\":{\"83\":2}}],[\"使得两者可以独立变化\",{\"1\":{\"99\":1}}],[\"使得不同的集合对象可以使用相同的遍历方法\",{\"1\":{\"99\":2}}],[\"使得多个处理者都有机会处理请求\",{\"1\":{\"97\":1}}],[\"使得多个处理者有机会处理该请求\",{\"1\":{\"97\":1}}],[\"使得子系统更容易使用\",{\"1\":{\"93\":3}}],[\"使得单个对象和组合对象可以一致地进行处理\",{\"1\":{\"91\":1}}],[\"使得客户端只需要与外观类进行交互\",{\"1\":{\"93\":3}}],[\"使得客户端的代码更加简洁\",{\"1\":{\"93\":3}}],[\"使得客户端代码无需关心产品的具体创建过程\",{\"1\":{\"84\":2,\"85\":1}}],[\"使得客户端代码无需关心具体汽车类型的创建细节\",{\"1\":{\"83\":1}}],[\"使得客户端无法直接创建产品对象\",{\"1\":{\"83\":1}}],[\"使得高层模块依赖于抽象\",{\"1\":{\"81\":1}}],[\"使得软件的维护更加容易\",{\"1\":{\"70\":1}}],[\"使代码易于理解和维护\",{\"1\":{\"76\":1}}],[\"使软件设计更加灵活\",{\"1\":{\"76\":1}}],[\"使用它们\",{\"1\":{\"239\":1}}],[\"使用以下命令激活虚拟环境\",{\"1\":{\"222\":1}}],[\"使用python命令和m\",{\"1\":{\"222\":1}}],[\"使用案例\",{\"0\":{\"216\":1}}],[\"使用上一步得到的空指针进行数组操作\",{\"1\":{\"195\":1}}],[\"使用extern关键字可以实现一定程度的面向对象编程\",{\"1\":{\"178\":1}}],[\"使用extern模拟面向对象编程\",{\"0\":{\"178\":1}}],[\"使用+=可能更高效\",{\"1\":{\"171\":1}}],[\"使用组播和点播\",{\"1\":{\"136\":1}}],[\"使用策略模式可以避免在上下文中使用大量的条件语句来选择算法\",{\"1\":{\"104\":1}}],[\"使用迭代器遍历汽车集合\",{\"1\":{\"99\":1}}],[\"使用享元对象\",{\"1\":{\"94\":1}}],[\"使用扩展抽象部分对象\",{\"1\":{\"90\":1}}],[\"使用不同的实现部分\",{\"1\":{\"90\":1}}],[\"使用适配器的对象\",{\"1\":{\"89\":1}}],[\"使用中间层次的设计模式\",{\"1\":{\"81\":1}}],[\"使用指南\",{\"2\":{\"60\":1,\"61\":1,\"108\":1,\"130\":1,\"164\":1,\"165\":1}}],[\"使用vuepress搭建博客\",{\"0\":{\"57\":1}}],[\"使用结构接口\",{\"1\":{\"17\":1}}],[\"使用\",{\"0\":{\"215\":1},\"1\":{\"12\":1,\"15\":1,\"21\":6,\"139\":1,\"189\":3}}],[\"使用限制\",{\"1\":{\"2\":1}}],[\"原因与说明\",{\"1\":{\"189\":1}}],[\"原理即美学\",{\"0\":{\"212\":1}}],[\"原理分析与实战最佳实践\",{\"0\":{\"181\":1}}],[\"原理\",{\"0\":{\"171\":1,\"193\":1}}],[\"原理与工程实践\",{\"0\":{\"132\":1}}],[\"原型和接口\",{\"0\":{\"239\":1}}],[\"原型\",{\"1\":{\"86\":1}}],[\"原型模式适用于创建复杂对象\",{\"1\":{\"86\":1}}],[\"原型模式的优点是提高性能\",{\"1\":{\"86\":1}}],[\"原型模式可能会导致安全问题\",{\"1\":{\"86\":1}}],[\"原型模式可以通过添加新的原型类来扩展系统的功能\",{\"1\":{\"86\":1}}],[\"原型模式可以通过复制已有对象来创建新对象\",{\"1\":{\"86\":1}}],[\"原型模式可以避免重复创建对象的开销\",{\"1\":{\"86\":1}}],[\"原型模式需要为每个原型对象分配内存\",{\"1\":{\"86\":1}}],[\"原型模式是一种创建型设计模式\",{\"1\":{\"86\":2}}],[\"原型模式\",{\"0\":{\"86\":1}}],[\"原型模式和单例模式\",{\"1\":{\"79\":1}}],[\"原则\",{\"1\":{\"81\":1,\"107\":1}}],[\"原有的设计模式也在不断演进和完善\",{\"1\":{\"69\":1}}],[\"原文如下\",{\"1\":{\"47\":1}}],[\"新产品\",{\"1\":{\"115\":1}}],[\"新的处理者可以很方便地加入到责任链中\",{\"1\":{\"97\":1}}],[\"新的设计模式不断涌现\",{\"1\":{\"69\":1}}],[\"新能源汽车行业从业者\",{\"1\":{\"1\":1}}],[\"自然扩展防溢出\",{\"1\":{\"211\":1}}],[\"自动启用高级指令集\",{\"1\":{\"189\":1}}],[\"自动向量化\",{\"1\":{\"185\":1}}],[\"自我督促\",{\"1\":{\"125\":1}}],[\"自律\",{\"1\":{\"124\":1}}],[\"自以为是\",{\"1\":{\"111\":1}}],[\"自1994年\",{\"1\":{\"69\":1}}],[\"自身不实现逻辑\",{\"1\":{\"9\":1}}],[\"可运行实体\",{\"1\":{\"237\":1}}],[\"可检测\",{\"1\":{\"202\":1}}],[\"可见将整数\",{\"1\":{\"195\":1}}],[\"可替换为\",{\"1\":{\"161\":1}}],[\"可炒股就是赌钱\",{\"1\":{\"127\":1}}],[\"可信的想法\",{\"1\":{\"126\":1}}],[\"可怕的是不知有无本事再赚回来\",{\"1\":{\"118\":1}}],[\"可能冲突\",{\"1\":{\"211\":1}}],[\"可能写成\",{\"1\":{\"209\":1}}],[\"可能比s\",{\"1\":{\"171\":1}}],[\"可能是买股的好时机\",{\"1\":{\"117\":1}}],[\"可能导致系统的复杂性增加\",{\"1\":{\"106\":1}}],[\"可能导致内存泄漏和不支持多线程\",{\"1\":{\"87\":1}}],[\"可能导致内存泄漏\",{\"1\":{\"87\":1}}],[\"可能会影响性能\",{\"1\":{\"101\":1}}],[\"可能会对系统性能产生一定的影响\",{\"1\":{\"100\":1}}],[\"可能会变得难以维护\",{\"1\":{\"100\":1}}],[\"可能会使系统变得复杂\",{\"1\":{\"99\":1}}],[\"可能会增加一定的复杂性\",{\"1\":{\"103\":1}}],[\"可能会增加系统的复杂性和维护成本\",{\"1\":{\"102\":1}}],[\"可能会增加系统的复杂度\",{\"1\":{\"93\":1}}],[\"可能会增加额外的开销\",{\"1\":{\"99\":1}}],[\"可能会降低性能\",{\"1\":{\"95\":2}}],[\"可能会降低系统的性能\",{\"1\":{\"93\":1}}],[\"可能会导致通知延迟\",{\"1\":{\"102\":1}}],[\"可能会导致性能问题\",{\"1\":{\"97\":1}}],[\"可能会导致调试和跟踪较为困难\",{\"1\":{\"97\":1}}],[\"可能会导致代码冗余等\",{\"1\":{\"95\":1}}],[\"可能会导致代码冗余\",{\"1\":{\"95\":1}}],[\"可能会导致一些问题\",{\"1\":{\"94\":1}}],[\"可能会导致外部状态的问题以及不适合用于频繁变化的对象等\",{\"1\":{\"94\":1}}],[\"可能会导致外部状态的问题\",{\"1\":{\"94\":1}}],[\"可能会导致管理复杂性增加\",{\"1\":{\"91\":1}}],[\"可能会导致内存泄漏\",{\"1\":{\"87\":1}}],[\"可能会导致内存消耗过大\",{\"1\":{\"86\":1}}],[\"可能会导致类的数量增加\",{\"1\":{\"103\":1,\"105\":1}}],[\"可能会导致类的数量过多\",{\"1\":{\"83\":1}}],[\"可能会导致类数量大幅增加\",{\"1\":{\"98\":1}}],[\"可能会导致类层次结构的爆炸性增长\",{\"1\":{\"81\":1}}],[\"可扩展性和封装性\",{\"1\":{\"83\":1}}],[\"可扩展性和可维护性\",{\"1\":{\"70\":1}}],[\"可扩展性\",{\"1\":{\"83\":1,\"84\":1,\"85\":1}}],[\"可读性\",{\"1\":{\"76\":1}}],[\"可复用性\",{\"1\":{\"76\":1}}],[\"可复用面向对象软件的基础\",{\"1\":{\"69\":1,\"107\":1}}],[\"可维护性和可读性\",{\"1\":{\"76\":1}}],[\"可维护嵌入式软件架构的前提\",{\"1\":{\"2\":1}}],[\"可以生成swc模板和合约头文件\",{\"1\":{\"244\":1}}],[\"可以设计包括端口\",{\"1\":{\"235\":1}}],[\"可以发送一个带\",{\"1\":{\"152\":1}}],[\"可以通过发送\",{\"1\":{\"151\":1}}],[\"可以通过添加新的代码来扩展软件的功能\",{\"1\":{\"81\":1}}],[\"可以考虑使用访问者模式\",{\"1\":{\"106\":1}}],[\"可以在对象浏览器中选择swc\",{\"1\":{\"244\":1}}],[\"可以在运行时动态切换策略\",{\"1\":{\"104\":1}}],[\"可以在不改变各元素类的情况下增加新操作\",{\"1\":{\"106\":1}}],[\"可以在不修改原有代码的情况下\",{\"1\":{\"92\":1}}],[\"可以在不同的项目中重复使用\",{\"1\":{\"70\":3,\"76\":2}}],[\"可以方便地在现有系统中添加新的操作\",{\"1\":{\"106\":1}}],[\"可以方便地增加新的策略而无需修改上下文类\",{\"1\":{\"104\":1}}],[\"可以方便地增加或删除观察者\",{\"1\":{\"102\":1}}],[\"可以方便地添加新的状态或修改现有状态\",{\"1\":{\"103\":1}}],[\"可以方便地保存和恢复对象的状态\",{\"1\":{\"101\":1}}],[\"可以保持对象的封装性\",{\"1\":{\"101\":1}}],[\"可以保存和恢复\",{\"1\":{\"101\":1}}],[\"可以根据需要实现不同的迭代器\",{\"1\":{\"99\":1}}],[\"可以很容易地增加新的命令\",{\"1\":{\"98\":1}}],[\"可以很容易地增加新的叶子节点或组合节点\",{\"1\":{\"91\":1}}],[\"可以将多个命令组合成一个复合命令\",{\"1\":{\"98\":1}}],[\"可以将对象的状态分离出来\",{\"1\":{\"94\":1}}],[\"可以动态地添加或删除责任链中的处理者\",{\"1\":{\"97\":1}}],[\"可以先创建一个虚拟代理\",{\"1\":{\"95\":1}}],[\"可以给这些对象动态地添加职责\",{\"1\":{\"92\":1}}],[\"可以组合成一个整体汽车\",{\"1\":{\"91\":1}}],[\"可以有多个具体子类\",{\"1\":{\"106\":1}}],[\"可以有效地减少类的数量\",{\"1\":{\"90\":1}}],[\"可以有不同的操作系统\",{\"1\":{\"90\":1}}],[\"可以独立地扩展抽象部分和实现部分\",{\"1\":{\"90\":1}}],[\"可以复制实现了原型接口的任何对象\",{\"1\":{\"86\":1}}],[\"可以使用以下命令\",{\"1\":{\"222\":2}}],[\"可以使用适配器模式将现有的接口转换为客户端期望的接口\",{\"1\":{\"89\":3}}],[\"可以使用单例模式来避免频繁的创建和销毁操作\",{\"1\":{\"87\":1}}],[\"可以使用单例模式来保证只有一个实例存在\",{\"1\":{\"87\":3}}],[\"可以使用生成器模式\",{\"1\":{\"84\":3,\"85\":3}}],[\"可以使用工厂方法模式\",{\"1\":{\"83\":3}}],[\"可以看到最终的结果和模式的功能\",{\"1\":{\"78\":1}}],[\"可以提高团队成员之间的沟通和协作效率\",{\"1\":{\"70\":1}}],[\"可以提高软件的可读性\",{\"1\":{\"70\":1}}],[\"可以减少代码的重复编写\",{\"1\":{\"70\":2,\"81\":1}}],[\"可用于解决代码中反复出现的设计问题\",{\"1\":{\"69\":1,\"76\":1}}],[\"帮助读者更好地理解和应用这些模式\",{\"1\":{\"68\":1}}],[\"撰写\",{\"1\":{\"68\":1}}],[\"什韦茨\",{\"1\":{\"68\":1}}],[\"什么是正确的心态\",{\"1\":{\"125\":1}}],[\"什么是大市的走向\",{\"1\":{\"121\":1}}],[\"什么是\",{\"0\":{\"3\":1,\"133\":1,\"199\":1}}],[\"阅读笔记\",{\"0\":{\"66\":1}}],[\"余下的工作就是\",{\"1\":{\"121\":1}}],[\"余数计算\",{\"2\":{\"65\":1}}],[\"余法运算公式\",{\"0\":{\"63\":1}}],[\"算法经常变化并且需要增加新的算法\",{\"1\":{\"104\":1}}],[\"算法多变且易于扩展\",{\"1\":{\"104\":1}}],[\"算法的封装\",{\"1\":{\"104\":1}}],[\"算法的变化不会影响使用算法的客户\",{\"1\":{\"104\":2}}],[\"算法像菜谱\",{\"1\":{\"78\":1}}],[\"算法\",{\"0\":{\"252\":1},\"2\":{\"64\":1}}],[\"算力需求增加\",{\"1\":{\"50\":1}}],[\"===>\",{\"1\":{\"141\":1}}],[\"==\",{\"1\":{\"87\":1,\"91\":1,\"94\":2,\"97\":3,\"100\":2,\"102\":1,\"155\":1}}],[\"=\",{\"1\":{\"63\":3,\"81\":9,\"83\":12,\"84\":12,\"85\":18,\"86\":14,\"87\":6,\"89\":10,\"90\":22,\"91\":30,\"92\":9,\"93\":10,\"94\":15,\"95\":4,\"97\":16,\"98\":21,\"99\":28,\"100\":16,\"101\":11,\"102\":25,\"103\":22,\"104\":13,\"105\":14,\"106\":20,\"139\":1,\"149\":6,\"152\":1,\"155\":1,\"170\":1,\"171\":4,\"178\":2,\"187\":2,\"194\":1,\"199\":1,\"203\":2,\"209\":2,\"221\":1}}],[\"+字符串拼接\",{\"2\":{\"174\":1}}],[\"+=\",{\"1\":{\"170\":1,\"171\":3,\"187\":1}}],[\"++j\",{\"1\":{\"91\":1}}],[\"++i\",{\"1\":{\"91\":2}}],[\"+表示公有\",{\"1\":{\"72\":1}}],[\"+\",{\"0\":{\"72\":1},\"1\":{\"63\":3,\"81\":1,\"91\":1,\"102\":1,\"136\":1,\"137\":2,\"139\":6,\"140\":1,\"146\":1,\"156\":1,\"170\":1,\"171\":4,\"185\":1,\"195\":1,\"200\":10}}],[\"<venv>必须被包含虚拟环境的目录的路径所替换\",{\"1\":{\"221\":1}}],[\"<no\",{\"1\":{\"215\":1}}],[\"<non\",{\"1\":{\"215\":1}}],[\"<gt>\",{\"1\":{\"215\":2}}],[\"<compat>\",{\"1\":{\"215\":2}}],[\"<charset>\",{\"1\":{\"215\":1}}],[\"<scheme>\",{\"1\":{\"215\":1}}],[\"<string\",{\"1\":{\"86\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1}}],[\"<stdlib\",{\"1\":{\"85\":1,\"86\":1,\"87\":1,\"90\":1,\"91\":1,\"93\":1,\"94\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1}}],[\"<stdio\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"178\":1}}],[\"<file>\",{\"1\":{\"215\":3}}],[\"<dirs>\",{\"1\":{\"215\":1}}],[\"<url>\",{\"1\":{\"215\":2}}],[\"<path>\",{\"1\":{\"215\":2}}],[\"<\",{\"1\":{\"91\":4,\"94\":1,\"99\":2,\"102\":4,\"187\":1}}],[\"<remote\",{\"1\":{\"59\":1}}],[\"<local\",{\"1\":{\"59\":1}}],[\"提升约\",{\"1\":{\"187\":1}}],[\"提示\",{\"1\":{\"161\":1,\"162\":1,\"176\":1}}],[\"提高并行度\",{\"1\":{\"186\":1}}],[\"提高灵活性\",{\"1\":{\"97\":1}}],[\"提高系统的可维护性和灵活性的场景\",{\"1\":{\"93\":1}}],[\"提高系统可扩展性\",{\"1\":{\"90\":1}}],[\"提高代码的可维护性\",{\"1\":{\"92\":1}}],[\"提高代码的复用率\",{\"1\":{\"70\":2}}],[\"提高了系统的灵活性\",{\"1\":{\"93\":1}}],[\"提高了系统的可维护性和灵活性\",{\"1\":{\"93\":1}}],[\"提高了系统的可维护性\",{\"1\":{\"93\":1}}],[\"提高了系统的可扩展性和灵活性\",{\"1\":{\"90\":1}}],[\"提高了代码的逻辑清晰性和可维护性\",{\"1\":{\"105\":1}}],[\"提高了代码的可维护性\",{\"1\":{\"92\":2}}],[\"提高了代码的可扩展性\",{\"1\":{\"89\":1}}],[\"提高了代码的灵活性\",{\"1\":{\"89\":1}}],[\"提高了代码的复用性\",{\"1\":{\"89\":1}}],[\"提高了程序的性能\",{\"1\":{\"87\":1,\"94\":1}}],[\"提高程序的性能\",{\"1\":{\"87\":1,\"94\":2}}],[\"提高性能\",{\"1\":{\"86\":1,\"87\":1,\"94\":1}}],[\"提高开发效率\",{\"1\":{\"81\":1}}],[\"提高软件的开发效率\",{\"1\":{\"70\":1}}],[\"提高软件的可维护性\",{\"1\":{\"70\":1}}],[\"提高软件的可复用性\",{\"1\":{\"70\":1}}],[\"提交本地分支到远程分支\",{\"1\":{\"59\":1}}],[\"提供多个优化等级\",{\"1\":{\"182\":1}}],[\"提供服务\",{\"1\":{\"149\":1,\"157\":1}}],[\"提供中\",{\"1\":{\"134\":1}}],[\"提供给人们无穷的想像\",{\"1\":{\"126\":1}}],[\"提供了一种灵活的方式来处理多种类型的元素及其操作\",{\"1\":{\"106\":1}}],[\"提供了一种保存和恢复对象状态的方法\",{\"1\":{\"101\":1}}],[\"提供了更大的灵活性\",{\"1\":{\"104\":1}}],[\"提供如何将对象和类组成较大的结构\",{\"1\":{\"79\":1}}],[\"提供创建对象的机制\",{\"1\":{\"79\":1}}],[\"提供达成目标的明确步骤\",{\"1\":{\"78\":1}}],[\"提供数据或服务\",{\"1\":{\"5\":1}}],[\"提供\",{\"1\":{\"3\":1,\"19\":1,\"106\":1}}],[\"3128\",{\"1\":{\"215\":1}}],[\"30500\",{\"1\":{\"147\":1}}],[\"30490\",{\"1\":{\"139\":1,\"155\":1}}],[\"3\",{\"0\":{\"74\":1,\"78\":1,\"186\":1,\"204\":1,\"237\":1,\"240\":1},\"1\":{\"59\":1,\"99\":2,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"149\":1,\"206\":1,\"222\":1,\"223\":1}}],[\"添加远程仓库的引用\",{\"1\":{\"59\":1}}],[\"g\",{\"1\":{\"215\":3,\"240\":1}}],[\"gdb\",{\"1\":{\"207\":1,\"210\":1}}],[\"guard\",{\"1\":{\"204\":1,\"211\":1}}],[\"gprof\",{\"1\":{\"189\":1}}],[\"gps\",{\"1\":{\"92\":1}}],[\"given\",{\"1\":{\"215\":1}}],[\"gimple\",{\"0\":{\"185\":1}}],[\"git目录中\",{\"1\":{\"162\":1}}],[\"github代理配置指南\",{\"0\":{\"158\":1}}],[\"github\",{\"0\":{\"257\":1},\"1\":{\"59\":1},\"2\":{\"165\":1}}],[\"git\",{\"1\":{\"59\":5,\"160\":2,\"161\":2,\"163\":2}}],[\"gnu\",{\"1\":{\"181\":1}}],[\"gcc\",{\"0\":{\"181\":1,\"182\":1,\"183\":1},\"1\":{\"181\":1,\"182\":1,\"183\":1,\"190\":1,\"191\":1}}],[\"globalvariable\",{\"1\":{\"177\":1}}],[\"global级是用户级别的配置\",{\"1\":{\"162\":1}}],[\"global\",{\"1\":{\"158\":1,\"160\":2,\"161\":3,\"162\":1,\"163\":2}}],[\"green\",{\"1\":{\"94\":2}}],[\"gasoline\",{\"1\":{\"89\":1}}],[\"gasolinecarinterface\",{\"1\":{\"89\":1}}],[\"gasolinecar\",{\"1\":{\"89\":11}}],[\"gateway\",{\"1\":{\"81\":1}}],[\"gof\",{\"1\":{\"69\":1}}],[\"generated\",{\"1\":{\"215\":1}}],[\"generate\",{\"1\":{\"189\":1}}],[\"general\",{\"1\":{\"37\":1}}],[\"geeksforgeeks\",{\"1\":{\"178\":1}}],[\"get\",{\"1\":{\"163\":2}}],[\"getcar\",{\"1\":{\"94\":6}}],[\"getchild\",{\"1\":{\"91\":5}}],[\"getsingleton\",{\"1\":{\"87\":2}}],[\"gearshifted\",{\"1\":{\"100\":2}}],[\"gearcontrol\",{\"1\":{\"18\":1}}],[\"gear\",{\"1\":{\"17\":1,\"18\":1,\"100\":3}}],[\"项目\",{\"1\":{\"211\":1}}],[\"项目构建\",{\"0\":{\"58\":1}}],[\"项目环境\",{\"1\":{\"57\":1}}],[\"本身无\",{\"1\":{\"149\":1}}],[\"本例中由\",{\"1\":{\"101\":1}}],[\"本例中隐含在\",{\"1\":{\"99\":1}}],[\"本书背景及重要性\",{\"0\":{\"68\":1}}],[\"本地运行指令可参考下面这个链接\",{\"1\":{\"57\":1}}],[\"本文从体系结构\",{\"1\":{\"198\":1}}],[\"本文从基本分类讲起\",{\"1\":{\"2\":1}}],[\"本文将深入剖析\",{\"1\":{\"181\":1}}],[\"本文探讨c++中\",{\"1\":{\"170\":1}}],[\"本文主要讲解developer\",{\"1\":{\"226\":1}}],[\"本文主要讲解autosar解决方案相关内容\",{\"1\":{\"43\":1}}],[\"本文主要讲解autosar\",{\"1\":{\"25\":1,\"234\":1}}],[\"本文主要介绍c语言中sizeof的原理分析\",{\"1\":{\"192\":1}}],[\"本文主要介绍c语言中extern的作用分析\",{\"1\":{\"175\":1}}],[\"本文主要介绍github\",{\"1\":{\"158\":1}}],[\"本文主要汇总c\",{\"1\":{\"166\":1}}],[\"本文主要总结设计模式这本书\",{\"1\":{\"66\":1}}],[\"这将把该目录添加到您的path中\",{\"1\":{\"221\":1}}],[\"这里并没有实际的数组\",{\"1\":{\"195\":1}}],[\"这里使用的是theme\",{\"1\":{\"57\":1}}],[\"这等效于\",{\"1\":{\"195\":1}}],[\"这只是一个简化的例子\",{\"1\":{\"194\":1}}],[\"这只是一种基于c语言的技巧或模式来实现一些面向对象的思想\",{\"1\":{\"178\":1}}],[\"这只股票的运动不对\",{\"1\":{\"118\":1}}],[\"这使得程序可以跨多个文件共享变量和函数\",{\"1\":{\"177\":1}}],[\"这使得它们更易于维护和扩展\",{\"1\":{\"81\":1}}],[\"这在大型项目中很有用\",{\"1\":{\"177\":1}}],[\"这两个机制可用于系统下电\",{\"1\":{\"152\":1}}],[\"这两种汽车制造过程中的某些步骤是相同的\",{\"1\":{\"105\":1}}],[\"这气球会继续胀\",{\"1\":{\"126\":1}}],[\"这是一种原地操作\",{\"1\":{\"171\":1}}],[\"这是因为c++中字符串的+运算符被重载以连接字符串\",{\"1\":{\"171\":1}}],[\"这是因为在面向对象编程中\",{\"1\":{\"81\":1}}],[\"这是不可能的\",{\"1\":{\"124\":1}}],[\"这其实便是炒股艰难的地方\",{\"1\":{\"118\":1}}],[\"这个设计的好处包括\",{\"1\":{\"207\":1}}],[\"这个宏的工作原理是\",{\"1\":{\"194\":1}}],[\"这个想法必须具备即简单又复杂的特性\",{\"1\":{\"126\":1}}],[\"这个理论的简单解释便是\",{\"1\":{\"124\":1}}],[\"这个止损点不应超出投资额的20\",{\"1\":{\"119\":1}}],[\"这个世界充满聪明而失意的人\",{\"1\":{\"118\":1}}],[\"这个概念牢牢地记在心里\",{\"1\":{\"118\":1}}],[\"这个时候trcv处于常电模式\",{\"1\":{\"36\":1}}],[\"这一方面是人性中亏不起的心态\",{\"1\":{\"111\":1}}],[\"这一恒久变动的股市还有一致命的特点\",{\"1\":{\"111\":1}}],[\"这一点很重要\",{\"1\":{\"81\":1}}],[\"这就形成了所谓的升势\",{\"1\":{\"126\":1}}],[\"这就给你危险信号了\",{\"1\":{\"117\":1}}],[\"这就是为什么股票一开始升势\",{\"1\":{\"116\":1}}],[\"这就是依赖倒置原则的应用\",{\"1\":{\"81\":1}}],[\"这就淘汰了一大部分股民\",{\"1\":{\"111\":1}}],[\"这种技巧通常用于计算结构体或数组的大小\",{\"1\":{\"195\":1}}],[\"这种赚大钱的可能以及挣了大钱后对你的生活方式\",{\"1\":{\"111\":1}}],[\"这种模式有时也被称为发布\",{\"1\":{\"102\":1}}],[\"这种情况通常出现在具有多个功能维度的系统中\",{\"1\":{\"81\":1}}],[\"这也可能会导致系统的性能降低\",{\"1\":{\"93\":1}}],[\"这也可能会导致系统的复杂度增加\",{\"1\":{\"93\":1}}],[\"这展示了桥接模式如何在实际项目中使用\",{\"1\":{\"90\":1}}],[\"这可能会破坏元素对象的封装性\",{\"1\":{\"106\":1}}],[\"这可能会导致客户端代码的修改较为困难\",{\"1\":{\"84\":1}}],[\"这可能会导致抽象工厂类的代码变得复杂\",{\"1\":{\"84\":1}}],[\"这可能会限制你的灵活性\",{\"1\":{\"81\":1}}],[\"这符合好莱坞原则的精神\",{\"1\":{\"81\":1}}],[\"这些状态图清晰呈现了\",{\"1\":{\"144\":1}}],[\"这些状态可以在多个对象之间共享\",{\"1\":{\"94\":1}}],[\"这些\",{\"1\":{\"126\":1}}],[\"这些人永远都达不到专业的层次\",{\"1\":{\"125\":1}}],[\"这些正确的心态至少包括以下几方面\",{\"1\":{\"125\":1}}],[\"这些知识能加深你对股市的认识\",{\"1\":{\"117\":1}}],[\"这些方法将调用carsystem的相应方法\",{\"1\":{\"90\":1}}],[\"这些方法的参数和返回值类型需要根据具体的产品族进行设计\",{\"1\":{\"84\":1}}],[\"这些模式允许我们将行为和特性组合起来\",{\"1\":{\"81\":1}}],[\"这些代码可能无法区分子类和超类的对象\",{\"1\":{\"81\":1}}],[\"这样做可以避免重复定义变量\",{\"1\":{\"177\":1}}],[\"这样做的思想基础不是为了解套\",{\"1\":{\"124\":1}}],[\"这样你就可以据此制定一系列游戏规则\",{\"1\":{\"128\":1}}],[\"这样可以提高代码的灵活性和可扩展性\",{\"1\":{\"83\":1}}],[\"这样可以减少开发和维护的成本\",{\"1\":{\"81\":1}}],[\"这样可以降低引入新技术或者更改现有逻辑所带来的风险\",{\"1\":{\"81\":1}}],[\"这样可以更灵活地管理代码\",{\"1\":{\"81\":1}}],[\"这样\",{\"1\":{\"81\":1,\"93\":3}}],[\"这本书由亚历山大\",{\"1\":{\"68\":1}}],[\"每一个更高的波浪都带动更多的贪婪心理\",{\"1\":{\"126\":1}}],[\"每一个类实现一个与上下文的一个状态相关的行为\",{\"1\":{\"103\":1}}],[\"每次添加变量都要重新分配正偏移\",{\"1\":{\"209\":1}}],[\"每次买卖都要有50\",{\"1\":{\"129\":1}}],[\"每次入场时我的获胜概率都超过50\",{\"1\":{\"119\":1}}],[\"每次上冲的强度通常较上一次更为猛烈\",{\"1\":{\"118\":1}}],[\"每年12月份组织标准发布会\",{\"1\":{\"53\":1}}],[\"每年11月份集中发布fo\",{\"1\":{\"53\":1}}],[\"每年上半年举办开放大会aoc\",{\"1\":{\"53\":1}}],[\"每个函数在进入时都会执行\",{\"1\":{\"207\":1}}],[\"每个状态通过定时器或接收报文事件进行转换\",{\"1\":{\"143\":1}}],[\"每个状态类只负责与其状态相关的行为\",{\"1\":{\"103\":1}}],[\"每个方法对应一个具体元素类\",{\"1\":{\"106\":1}}],[\"每个具体状态都需要定义一个类\",{\"1\":{\"103\":1}}],[\"每个具体命令都需要一个对应的类\",{\"1\":{\"98\":1}}],[\"每个装饰类只负责一个特定的功能\",{\"1\":{\"92\":4}}],[\"每个\",{\"1\":{\"21\":1}}],[\"每个字段可分别绑定不同的\",{\"1\":{\"17\":1}}],[\"基线\",{\"1\":{\"187\":1}}],[\"基于真实运行数据进行反馈优化\",{\"1\":{\"189\":1}}],[\"基于\",{\"1\":{\"136\":1}}],[\"基于接口的实现\",{\"1\":{\"73\":1}}],[\"基于区域集中式ee架构的整车部署\",{\"0\":{\"51\":1}}],[\"基础分析\",{\"1\":{\"119\":1}}],[\"基础概念\",{\"0\":{\"71\":1}}],[\"基础设施\",{\"1\":{\"48\":1}}],[\"实战建议\",{\"1\":{\"189\":1}}],[\"实战故障排查\",{\"0\":{\"155\":1}}],[\"实际的\",{\"1\":{\"194\":1}}],[\"实际的实现可能更为复杂\",{\"1\":{\"194\":1}}],[\"实际上是创建了一个新的字符串\",{\"1\":{\"171\":1}}],[\"实际上就是面向接口开发\",{\"1\":{\"81\":1}}],[\"实际\",{\"0\":{\"147\":1}}],[\"实时组织\",{\"1\":{\"135\":1}}],[\"实时性与安全性需求减少\",{\"1\":{\"50\":1}}],[\"实现通常是由编译器内部提供的\",{\"1\":{\"194\":1}}],[\"实现方式\",{\"0\":{\"194\":1}}],[\"实现更细粒度的调优\",{\"1\":{\"189\":1}}],[\"实现抽象类中的抽象方法\",{\"1\":{\"105\":1}}],[\"实现策略接口的具体算法\",{\"1\":{\"104\":1}}],[\"实现状态接口的具体状态类\",{\"1\":{\"103\":1}}],[\"实现观察者接口\",{\"1\":{\"102\":1}}],[\"实现主题接口\",{\"1\":{\"102\":1}}],[\"实现备忘录模式可能会比较复杂\",{\"1\":{\"101\":1}}],[\"实现复杂性\",{\"1\":{\"101\":1}}],[\"实现中介者接口\",{\"1\":{\"100\":1}}],[\"实现聚合接口\",{\"1\":{\"99\":1}}],[\"实现迭代器接口\",{\"1\":{\"99\":1}}],[\"实现命令接口\",{\"1\":{\"98\":1}}],[\"实现处理请求的具体处理者\",{\"1\":{\"97\":1}}],[\"实现远程访问等\",{\"1\":{\"95\":1}}],[\"实现远程访问\",{\"1\":{\"95\":1}}],[\"实现实现接口的具体类\",{\"1\":{\"90\":1}}],[\"实现部分接口\",{\"1\":{\"90\":1}}],[\"实现部分\",{\"1\":{\"90\":2}}],[\"实现适配器的充电方法\",{\"1\":{\"89\":1}}],[\"实现传统燃油汽车接口的加油方法\",{\"1\":{\"89\":1}}],[\"实现电动汽车接口的充电方法\",{\"1\":{\"89\":1}}],[\"实现了类的初始化和打印数据的方法\",{\"1\":{\"178\":1}}],[\"实现了观察者接口\",{\"1\":{\"102\":1}}],[\"实现了主题接口\",{\"1\":{\"102\":1}}],[\"实现了中介者接口\",{\"1\":{\"100\":1}}],[\"实现了迭代器接口的方法\",{\"1\":{\"99\":1}}],[\"实现了请求发送者与接收者的解耦\",{\"1\":{\"98\":1}}],[\"实现了命令接口\",{\"1\":{\"98\":1}}],[\"实现了处理请求的方法inspect\",{\"1\":{\"97\":1}}],[\"实现了享元接口\",{\"1\":{\"94\":1}}],[\"实现了组件接口\",{\"1\":{\"91\":1}}],[\"实现了\",{\"1\":{\"91\":2,\"99\":1,\"106\":1}}],[\"实现了对传统燃油汽车的充电操作\",{\"1\":{\"89\":1}}],[\"实现了将传统燃油汽车的加油接口转换为电动汽车的充电接口的功能\",{\"1\":{\"89\":1}}],[\"实现了克隆方法的类\",{\"1\":{\"86\":1}}],[\"实现了生成器接口\",{\"1\":{\"85\":1}}],[\"实现了抽象访问者中声明的各种\",{\"1\":{\"106\":1}}],[\"实现了抽象类中的抽象方法\",{\"1\":{\"105\":1}}],[\"实现了抽象工厂的构建方法\",{\"1\":{\"84\":1}}],[\"实现了抽象工厂类中的工厂方法\",{\"1\":{\"83\":1}}],[\"实现了抽象产品的接口\",{\"1\":{\"84\":1}}],[\"实现了抽象产品类中的产品方法\",{\"1\":{\"83\":1}}],[\"实现拒绝修改\",{\"1\":{\"73\":1}}],[\"实现整车层面的虚拟功能总线\",{\"1\":{\"46\":1}}],[\"实现软硬解耦\",{\"1\":{\"46\":1}}],[\"实现\",{\"1\":{\"33\":1,\"77\":1,\"190\":1}}],[\"从效率的角度来看\",{\"1\":{\"171\":1}}],[\"从什么都不懂到有信心不断地从股市赚到钱\",{\"1\":{\"125\":1}}],[\"从小开始\",{\"1\":{\"124\":1}}],[\"从心理上它们最容易解释\",{\"1\":{\"119\":1}}],[\"从备忘录恢复状态\",{\"1\":{\"101\":2}}],[\"从外类来扩展component类的功能\",{\"1\":{\"92\":1}}],[\"从而可获取type的字节大小\",{\"1\":{\"195\":1}}],[\"从而实现低耦合\",{\"1\":{\"102\":1}}],[\"从而实现松散耦合\",{\"1\":{\"100\":1}}],[\"从而实现不同的产品创建过程\",{\"1\":{\"85\":1}}],[\"从而支持宏命令\",{\"1\":{\"98\":1}}],[\"从而使新的数据被压入更低的地址\",{\"1\":{\"199\":1}}],[\"从而使得不同的子类可以在不改变算法结构的情况下重新定义算法的某些步骤\",{\"1\":{\"105\":1}}],[\"从而使你可以用不同的请求对客户进行参数化\",{\"1\":{\"98\":1}}],[\"从而使代码难以维护和理解\",{\"1\":{\"81\":1}}],[\"从而避免请求的发送者和接收者之间的耦合关系\",{\"1\":{\"97\":1}}],[\"从而避免了重复创建对象的开销\",{\"1\":{\"86\":1}}],[\"从而减少了客户端的代码量\",{\"1\":{\"93\":1}}],[\"从而简化了代码的结构\",{\"1\":{\"92\":3}}],[\"从而降低了系统的性能\",{\"1\":{\"92\":1}}],[\"从而降低了代码的性能\",{\"1\":{\"89\":1}}],[\"从而降低软件维护的成本和风险\",{\"1\":{\"70\":1}}],[\"从而降低软件开发的成本和风险\",{\"1\":{\"70\":1}}],[\"从而增加了系统的开销\",{\"1\":{\"93\":1}}],[\"从而增加了系统的维护成本\",{\"1\":{\"83\":1}}],[\"从而增加了代码的复杂度\",{\"1\":{\"89\":1}}],[\"从而引发问题\",{\"1\":{\"86\":1}}],[\"从而提高安全性\",{\"1\":{\"95\":1}}],[\"从而提高性能\",{\"1\":{\"95\":1}}],[\"从而提高了代码的可维护性\",{\"1\":{\"92\":1}}],[\"从而提高了代码的可扩展性\",{\"1\":{\"89\":1}}],[\"从而提高了代码的灵活性\",{\"1\":{\"89\":1}}],[\"从而提高了代码的复用性\",{\"1\":{\"89\":1}}],[\"从而提高了系统的可维护性\",{\"1\":{\"93\":3}}],[\"从而提高了系统的灵活性\",{\"1\":{\"84\":2,\"93\":2}}],[\"从而提高了系统的封装性和安全性\",{\"1\":{\"83\":1}}],[\"从而提高团队的整体素质和竞争力\",{\"1\":{\"70\":1}}],[\"从而提高软件开发的效率\",{\"1\":{\"70\":1}}],[\"从cp到ap\",{\"1\":{\"50\":1}}],[\"从多个\",{\"1\":{\"18\":1}}],[\"values\",{\"1\":{\"237\":1}}],[\"valgrind\",{\"1\":{\"189\":1}}],[\"v\",{\"1\":{\"106\":1,\"206\":1}}],[\"vinci\",{\"0\":{\"262\":1}}],[\"view\",{\"1\":{\"239\":1}}],[\"visiting\",{\"1\":{\"106\":3}}],[\"visittruck\",{\"1\":{\"106\":4}}],[\"visitsuv\",{\"1\":{\"106\":4}}],[\"visitcar\",{\"1\":{\"106\":4}}],[\"visit\",{\"1\":{\"106\":2}}],[\"visitor\",{\"0\":{\"106\":1},\"1\":{\"106\":20}}],[\"virtual\",{\"1\":{\"50\":1}}],[\"void\",{\"1\":{\"81\":7,\"85\":6,\"86\":1,\"89\":5,\"90\":10,\"91\":9,\"92\":4,\"93\":1,\"94\":1,\"95\":6,\"97\":5,\"98\":12,\"99\":6,\"100\":6,\"101\":2,\"102\":12,\"103\":23,\"104\":5,\"105\":17,\"106\":12,\"177\":1,\"178\":5,\"203\":1}}],[\"vuepress\",{\"2\":{\"61\":1}}],[\"venv参数\",{\"1\":{\"222\":1}}],[\"venv\",{\"1\":{\"220\":1,\"222\":2,\"223\":1},\"2\":{\"225\":1}}],[\"versioning\",{\"1\":{\"215\":1}}],[\"vehiclestatus\",{\"1\":{\"17\":1,\"18\":1}}],[\"vectorize\",{\"1\":{\"185\":1}}],[\"vector<int>\",{\"1\":{\"167\":1}}],[\"vector\",{\"1\":{\"15\":1,\"19\":1}}],[\"m\",{\"1\":{\"222\":2}}],[\"mov\",{\"1\":{\"207\":1}}],[\"movl\",{\"1\":{\"203\":2,\"209\":2}}],[\"movq\",{\"1\":{\"195\":1}}],[\"modules\",{\"1\":{\"215\":2}}],[\"modes\",{\"1\":{\"240\":1}}],[\"mode\",{\"1\":{\"104\":12,\"215\":1,\"240\":1}}],[\"model\",{\"1\":{\"83\":4,\"84\":4,\"85\":4,\"86\":4,\"87\":2,\"89\":4,\"93\":1,\"98\":2,\"99\":3,\"106\":9}}],[\"mod\",{\"1\":{\"63\":1}}],[\"metallic\",{\"1\":{\"105\":1}}],[\"method\",{\"0\":{\"105\":1}}],[\"memento\",{\"0\":{\"101\":1},\"1\":{\"101\":20}}],[\"memory\",{\"1\":{\"50\":1}}],[\"mediator\",{\"0\":{\"100\":1},\"1\":{\"100\":33}}],[\"multi\",{\"1\":{\"140\":2}}],[\"multiple\",{\"1\":{\"50\":1}}],[\"music\",{\"1\":{\"90\":2}}],[\"myenv\",{\"1\":{\"222\":4}}],[\"myobject\",{\"1\":{\"178\":7}}],[\"myclass\",{\"1\":{\"178\":16}}],[\"mytestclass是一个简单的测试类\",{\"1\":{\"81\":1}}],[\"mytestclass\",{\"1\":{\"81\":1}}],[\"myrepo\",{\"1\":{\"59\":1}}],[\"manual\",{\"0\":{\"263\":1}}],[\"manufacturing\",{\"1\":{\"105\":4}}],[\"manufacturecar\",{\"1\":{\"85\":2}}],[\"mapping\",{\"1\":{\"237\":1}}],[\"march=native\",{\"1\":{\"186\":1,\"189\":1}}],[\"math\",{\"1\":{\"182\":1}}],[\"max\",{\"1\":{\"102\":3}}],[\"malloc\",{\"1\":{\"83\":3,\"84\":3,\"85\":3,\"86\":2,\"87\":1,\"90\":5,\"91\":3,\"92\":2,\"93\":3,\"94\":2,\"97\":3,\"98\":2,\"99\":6,\"100\":3,\"101\":2,\"102\":3,\"103\":4,\"104\":4,\"202\":1}}],[\"main函数\",{\"1\":{\"97\":1}}],[\"main\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"143\":1,\"155\":1,\"178\":2,\"194\":1}}],[\"master\",{\"1\":{\"59\":1}}],[\"mmu\",{\"1\":{\"50\":1}}],[\"mpu\",{\"1\":{\"50\":1}}],[\"mcal配置\",{\"0\":{\"37\":1}}],[\"mcal相关配置\",{\"0\":{\"34\":1}}],[\"mcu的can信号与can总线建立起数据交互\",{\"1\":{\"35\":1}}],[\"mcu的can外设控制模块\",{\"1\":{\"33\":1}}],[\"e\",{\"1\":{\"215\":3,\"240\":1}}],[\"ecu\",{\"1\":{\"135\":1,\"136\":1,\"235\":1}}],[\"economy\",{\"1\":{\"105\":6}}],[\"economycar\",{\"1\":{\"105\":9}}],[\"economic\",{\"1\":{\"104\":1}}],[\"economicmode\",{\"1\":{\"104\":10}}],[\"effective\",{\"1\":{\"107\":1}}],[\"exe\",{\"1\":{\"222\":1}}],[\"exec\",{\"1\":{\"221\":2}}],[\"executecommand\",{\"1\":{\"98\":3}}],[\"executestopengine\",{\"1\":{\"98\":2}}],[\"executestartengine\",{\"1\":{\"98\":2}}],[\"execute\",{\"1\":{\"98\":3}}],[\"execution\",{\"1\":{\"50\":1}}],[\"existing\",{\"1\":{\"215\":1}}],[\"extra\",{\"1\":{\"215\":1}}],[\"extern关键字用于声明变量或函数的存在\",{\"1\":{\"177\":1}}],[\"extern也可以用于函数声明\",{\"1\":{\"177\":1}}],[\"extern的作用有以下几点\",{\"1\":{\"177\":1}}],[\"extern作用\",{\"0\":{\"177\":1}}],[\"extern\",{\"1\":{\"103\":4,\"177\":4,\"178\":2},\"2\":{\"180\":1}}],[\"export\",{\"1\":{\"215\":2}}],[\"expected\",{\"0\":{\"167\":1}}],[\"eventgroup\",{\"1\":{\"147\":1}}],[\"event\",{\"1\":{\"100\":4,\"140\":1}}],[\"elements\",{\"1\":{\"237\":1}}],[\"element\",{\"1\":{\"106\":1}}],[\"electric\",{\"1\":{\"89\":1}}],[\"electriccarinterface\",{\"1\":{\"89\":5}}],[\"electriccar\",{\"1\":{\"89\":5}}],[\"else\",{\"1\":{\"95\":1,\"97\":6,\"100\":1}}],[\"enables\",{\"1\":{\"215\":1}}],[\"encoding\",{\"1\":{\"215\":2}}],[\"environments\",{\"1\":{\"215\":1}}],[\"endif\",{\"1\":{\"178\":1}}],[\"endpoint\",{\"1\":{\"147\":1}}],[\"entrytype\",{\"1\":{\"149\":6}}],[\"entry\",{\"1\":{\"139\":1,\"146\":1,\"149\":1,\"151\":1,\"157\":1}}],[\"entries\",{\"1\":{\"139\":1}}],[\"enhanced\",{\"0\":{\"230\":1},\"1\":{\"104\":1}}],[\"enum\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":1,\"94\":2}}],[\"engineinspector\",{\"1\":{\"97\":23}}],[\"engine是一个抽象接口\",{\"1\":{\"81\":1}}],[\"enginestop\",{\"1\":{\"81\":2}}],[\"enginestarted\",{\"1\":{\"100\":2}}],[\"enginestart\",{\"1\":{\"81\":2}}],[\"engine\",{\"1\":{\"81\":17,\"91\":5,\"97\":4,\"98\":2,\"100\":26,\"105\":2}}],[\"edit\",{\"1\":{\"81\":1}}],[\"eating\",{\"1\":{\"81\":2}}],[\"eat\",{\"1\":{\"81\":9}}],[\"each\",{\"1\":{\"50\":1,\"215\":1}}],[\"eb\",{\"1\":{\"19\":1}}],[\"over\",{\"1\":{\"240\":1}}],[\"overwrite\",{\"1\":{\"215\":1}}],[\"os\",{\"1\":{\"182\":1,\"189\":1}}],[\"osek\",{\"1\":{\"50\":1}}],[\"o3\",{\"1\":{\"182\":2,\"187\":2,\"188\":1,\"189\":1}}],[\"o2\",{\"1\":{\"182\":1,\"187\":2,\"188\":1,\"189\":1}}],[\"o1\",{\"1\":{\"182\":1}}],[\"o0\",{\"1\":{\"182\":1,\"187\":1,\"188\":1}}],[\"object\",{\"1\":{\"106\":1,\"238\":1,\"239\":1}}],[\"observercount\",{\"1\":{\"102\":2}}],[\"observers\",{\"1\":{\"102\":4}}],[\"observer\",{\"0\":{\"102\":1},\"1\":{\"102\":27}}],[\"open\",{\"1\":{\"215\":1}}],[\"operations\",{\"1\":{\"240\":2}}],[\"operation\",{\"1\":{\"91\":7}}],[\"optimize\",{\"1\":{\"190\":1}}],[\"optimized\",{\"1\":{\"50\":1}}],[\"option\",{\"1\":{\"139\":1,\"146\":1,\"155\":1,\"157\":1}}],[\"options\",{\"1\":{\"139\":1,\"215\":2}}],[\"or\",{\"1\":{\"215\":1,\"240\":1}}],[\"org\",{\"1\":{\"81\":2,\"223\":1}}],[\"originator\",{\"1\":{\"101\":2}}],[\"original\",{\"1\":{\"86\":6}}],[\"origin\",{\"1\":{\"59\":2}}],[\"oriented\",{\"1\":{\"50\":1,\"238\":4}}],[\"own\",{\"1\":{\"50\":1}}],[\"ofast\",{\"1\":{\"182\":1,\"187\":1,\"188\":1}}],[\"offer\",{\"0\":{\"150\":1},\"1\":{\"139\":1,\"146\":1,\"151\":1,\"153\":2,\"154\":2,\"157\":1}}],[\"offerservice\",{\"0\":{\"153\":1},\"1\":{\"134\":1,\"136\":1,\"137\":2,\"140\":2,\"141\":2,\"143\":1,\"144\":1,\"145\":1,\"149\":2,\"153\":2}}],[\"of\",{\"0\":{\"97\":1},\"1\":{\"50\":2,\"98\":2,\"105\":6,\"124\":1,\"215\":3}}],[\"one\",{\"1\":{\"240\":1}}],[\"only\",{\"1\":{\"215\":1}}],[\"on\",{\"1\":{\"50\":2,\"221\":2}}],[\"output\",{\"1\":{\"215\":2}}],[\"out\",{\"0\":{\"15\":1},\"1\":{\"21\":1,\"22\":1}}],[\"与堆布局互补\",{\"1\":{\"211\":1}}],[\"与堆对称增长\",{\"0\":{\"202\":1}}],[\"与\",{\"0\":{\"50\":1,\"141\":1,\"142\":1,\"156\":1},\"1\":{\"187\":2,\"190\":1}}],[\"硬件1\",{\"1\":{\"46\":1}}],[\"存储在相对于\",{\"1\":{\"195\":2}}],[\"存储汽车的状态\",{\"1\":{\"101\":1}}],[\"存储发起人的内部状态\",{\"1\":{\"101\":1}}],[\"存储\",{\"1\":{\"46\":1}}],[\"故障诊断及诊断服务\",{\"1\":{\"46\":1}}],[\"对应汇编文件中的movq\",{\"1\":{\"195\":1}}],[\"对应汇编文件中的\",{\"1\":{\"195\":1}}],[\"对性能关键路径\",{\"1\":{\"189\":1}}],[\"对任何给你\",{\"1\":{\"124\":1}}],[\"对投资的对象可以有弹性\",{\"1\":{\"124\":1}}],[\"对业余炒手而言\",{\"1\":{\"118\":1}}],[\"对外提供一个简单的接口\",{\"1\":{\"93\":2}}],[\"对外暴露的通信接口点\",{\"1\":{\"3\":1}}],[\"对象结构\",{\"1\":{\"106\":1}}],[\"对象在运行时需要频繁切换状态\",{\"1\":{\"103\":1}}],[\"对象的行为随状态变化而变化\",{\"1\":{\"103\":1}}],[\"对象的行为依赖于其状态\",{\"1\":{\"103\":1}}],[\"对象的状态可以共享\",{\"1\":{\"94\":1}}],[\"对象之间存在复杂的引用关系\",{\"1\":{\"100\":1}}],[\"对象池等\",{\"1\":{\"87\":1}}],[\"对象状态变化较小\",{\"1\":{\"86\":1}}],[\"对象时可能会出现意料之外的行为或错误\",{\"1\":{\"81\":1}}],[\"对象时不会出现问题\",{\"1\":{\"81\":1}}],[\"对象feed\",{\"1\":{\"81\":1}}],[\"对象dog\",{\"1\":{\"81\":1}}],[\"对象并喂养它def\",{\"1\":{\"81\":1}}],[\"对象为参数的任何代码\",{\"1\":{\"81\":1}}],[\"对修改关闭\",{\"1\":{\"81\":1}}],[\"对runnable和task进行调度\",{\"1\":{\"46\":1}}],[\"对硬件进行抽象\",{\"1\":{\"46\":1}}],[\"尽可能重用已有标准\",{\"1\":{\"45\":1}}],[\"而sys\",{\"1\":{\"221\":1}}],[\"而只是声明它的存在\",{\"1\":{\"177\":1}}],[\"而最重要的是熬\",{\"1\":{\"129\":1}}],[\"而你的想法常常是错的\",{\"1\":{\"124\":1}}],[\"而且我只下小注\",{\"1\":{\"119\":1}}],[\"而且难以解决问题\",{\"1\":{\"27\":1}}],[\"而在于我能安坐不动\",{\"1\":{\"124\":1}}],[\"而在于它给炒股者提供的幻想\",{\"1\":{\"111\":1}}],[\"而在于危急的时候怎么逃\",{\"1\":{\"111\":1}}],[\"而某些步骤则因车型不同而有所差异\",{\"1\":{\"105\":1}}],[\"而又无需使代码依赖它们所属的类\",{\"1\":{\"86\":1}}],[\"而无需创建实际的实例\",{\"1\":{\"195\":1}}],[\"而无需改变上下文的代码\",{\"1\":{\"103\":1}}],[\"而无需关心对象的具体实现细节\",{\"1\":{\"86\":1}}],[\"而无需关心产品对象的具体实现细节\",{\"1\":{\"83\":1}}],[\"而无需指定其具体类\",{\"1\":{\"84\":2}}],[\"而无需修改要操作的元素类\",{\"1\":{\"106\":1}}],[\"而无需修改已有代码\",{\"1\":{\"86\":1}}],[\"而无需修改现有代码\",{\"1\":{\"83\":1}}],[\"而无需修改car类的代码\",{\"1\":{\"81\":1}}],[\"而应用程序代码不能主动调用框架\",{\"1\":{\"81\":1}}],[\"而应用程序代码则通过特定的方式与框架进行交互\",{\"1\":{\"81\":1}}],[\"而应用软件可以理解为大脑或灵魂\",{\"1\":{\"46\":1}}],[\"而组合则代表\",{\"1\":{\"81\":1}}],[\"而超类中的方法可能会被其他代码调用\",{\"1\":{\"81\":1}}],[\"而是对架构一致性\",{\"1\":{\"212\":1}}],[\"而是通过定期重新\",{\"1\":{\"154\":1}}],[\"而是你\",{\"1\":{\"124\":1}}],[\"而是因为股票在升\",{\"1\":{\"116\":1}}],[\"而是应该依赖于引擎的抽象接口\",{\"1\":{\"81\":1}}],[\"而是解决特定问题的一般性概念\",{\"1\":{\"76\":1}}],[\"而不知道其他同事类\",{\"1\":{\"100\":1}}],[\"而不暴露该对象的内部表示\",{\"1\":{\"99\":1}}],[\"而不需要修改客户端的代码\",{\"1\":{\"93\":1}}],[\"而不需要了解子系统的具体实现细节\",{\"1\":{\"93\":3}}],[\"而不需要与子系统中的具体实现类进行交互\",{\"1\":{\"93\":1}}],[\"而不需要引入整个框架的复杂性和约束\",{\"1\":{\"81\":1}}],[\"而不需要依赖整个框架\",{\"1\":{\"81\":1}}],[\"而不会对整个应用程序产生太大的影响\",{\"1\":{\"81\":1}}],[\"而不会影响软件的正确性\",{\"1\":{\"81\":1}}],[\"而不是使用基于模型的代码生成器\",{\"1\":{\"244\":1}}],[\"而不是由标准\",{\"1\":{\"193\":1}}],[\"而不是由测试类自身触发的\",{\"1\":{\"81\":1}}],[\"而不是创建新的对象\",{\"1\":{\"171\":1}}],[\"而不是通过继承来扩展类\",{\"1\":{\"81\":1}}],[\"而不是面向实现\",{\"1\":{\"81\":2}}],[\"而不是具体的concreteengine实现\",{\"1\":{\"81\":1}}],[\"而不是具体的实现\",{\"1\":{\"81\":1}}],[\"而不是具体的实现细节\",{\"1\":{\"74\":1}}],[\"而非完全动态\",{\"1\":{\"45\":1}}],[\"而提供的解决方案\",{\"1\":{\"45\":1,\"46\":1}}],[\"根据当前\",{\"1\":{\"189\":1}}],[\"根据\",{\"1\":{\"149\":1}}],[\"根据依赖倒置原则\",{\"1\":{\"81\":1}}],[\"根据外部电路配置trcv的通道\",{\"1\":{\"37\":1}}],[\"根据需要可进行相关性报文过滤\",{\"1\":{\"29\":1}}],[\"才能有唤醒功能\",{\"1\":{\"36\":1}}],[\"以\",{\"1\":{\"203\":1}}],[\"以处理各种类型和体系结构\",{\"1\":{\"194\":1}}],[\"以表示大小\",{\"1\":{\"194\":1}}],[\"以字节为单位\",{\"1\":{\"193\":1}}],[\"以一段简单的\",{\"1\":{\"187\":1}}],[\"以较长周期\",{\"1\":{\"153\":1}}],[\"以上的胜率\",{\"1\":{\"129\":2}}],[\"以保证你能够仔细地观察它们\",{\"1\":{\"124\":1}}],[\"以保证二者之间的兼容性\",{\"1\":{\"48\":1}}],[\"以我的经验\",{\"1\":{\"123\":1}}],[\"以下以window环境为例创建指定版本虚拟环境的步骤\",{\"1\":{\"222\":1}}],[\"以下的几点或许能帮助你自律\",{\"1\":{\"124\":1}}],[\"以下我简单地解释经济周期怎样在股价上反映出来\",{\"1\":{\"117\":1}}],[\"以下是典型的\",{\"1\":{\"200\":1}}],[\"以下是\",{\"1\":{\"194\":1}}],[\"以下是使用访问者模式实现的一个简单汽车应用示例\",{\"1\":{\"106\":1}}],[\"以下是一个使用工厂方法模式创建汽车的\",{\"1\":{\"83\":1}}],[\"以确保它们不改变算法的结构\",{\"1\":{\"105\":1}}],[\"以防止外部创建实例\",{\"1\":{\"87\":1}}],[\"以避免敏感信息泄露\",{\"1\":{\"86\":1}}],[\"以及汽车结构体\",{\"1\":{\"94\":1}}],[\"以及管理子节点的方法\",{\"1\":{\"91\":1}}],[\"以及构建汽车的方法\",{\"1\":{\"85\":1}}],[\"以及保持方法的预期行为相似\",{\"1\":{\"81\":1}}],[\"以及根据外部的can的收\",{\"1\":{\"32\":1}}],[\"以便运行python将调用环境的python解释器\",{\"1\":{\"221\":1}}],[\"以便告诉编译器该函数在其他文件中已经定义\",{\"1\":{\"177\":1}}],[\"以便告诉编译器它们的存在\",{\"1\":{\"177\":1}}],[\"以便更好地理解和应用这种设计模式\",{\"1\":{\"106\":1}}],[\"以便以后恢复到之前的状态\",{\"1\":{\"101\":1}}],[\"以便为客户端提供一个统一的高层接口\",{\"1\":{\"93\":1}}],[\"以便在不同的应用场景中进行复用\",{\"1\":{\"81\":1}}],[\"以便在需要时能够轻松地添加新的功能或修改现有的功能\",{\"1\":{\"81\":1}}],[\"以便\",{\"1\":{\"81\":1}}],[\"以便客户端只需要依赖它们实际使用的接口\",{\"1\":{\"81\":1}}],[\"以便实现ecu布局中的抽象化\",{\"1\":{\"35\":1}}],[\"以涵盖汽车软件开发领域的各种应用场景\",{\"1\":{\"44\":1}}],[\"它告诉编译器该变量在其他文件中已经定义\",{\"1\":{\"177\":1}}],[\"它将不再发送\",{\"1\":{\"154\":1}}],[\"它将请求封装成对象\",{\"1\":{\"98\":1}}],[\"它传染的速度远超过瘟疫\",{\"1\":{\"126\":1}}],[\"它的目标是\",{\"1\":{\"133\":1}}],[\"它的盈利及增长的可能性\",{\"1\":{\"124\":1}}],[\"它的管理层\",{\"1\":{\"124\":1}}],[\"它的精华可以浓缩成两句话\",{\"1\":{\"118\":1}}],[\"它不应跌回我当天入场的最低点\",{\"1\":{\"123\":1}}],[\"它不会长久留在某只股票上\",{\"1\":{\"120\":1}}],[\"它不仅介绍了设计模式的定义\",{\"1\":{\"68\":1}}],[\"它总是走自己要走的路\",{\"1\":{\"118\":1}}],[\"它有时很活跃\",{\"1\":{\"118\":1}}],[\"它取代了农业社会丈量土地的方法\",{\"1\":{\"117\":1}}],[\"它往上一波高过一波\",{\"1\":{\"116\":1}}],[\"它定义了一系列算法\",{\"1\":{\"104\":1}}],[\"它定义了一种一对多的依赖关系\",{\"1\":{\"102\":1}}],[\"它定义了一个创建对象的接口\",{\"1\":{\"83\":2}}],[\"它保持了对象的封装性\",{\"1\":{\"101\":1}}],[\"它保证了一个类只有一个实例\",{\"1\":{\"87\":1}}],[\"它保证一个类只有一个实例\",{\"1\":{\"87\":1}}],[\"它提供一种方法顺序访问一个聚合对象中的各个元素\",{\"1\":{\"99\":1}}],[\"它提供了一种通用的解决方案\",{\"1\":{\"76\":1}}],[\"它允许你定义一些操作\",{\"1\":{\"106\":1}}],[\"它允许你将对象组合成树状结构来表示\",{\"1\":{\"91\":1}}],[\"它允许对象在其内部状态改变时改变其行为\",{\"1\":{\"103\":1}}],[\"它允许在不破坏封装的前提下\",{\"1\":{\"101\":1}}],[\"它允许多个对象都有机会处理请求\",{\"1\":{\"97\":1}}],[\"它适用于需要遍历不同类型的集合对象\",{\"1\":{\"99\":1}}],[\"它适用于需要对请求进行排队\",{\"1\":{\"98\":1}}],[\"它适用于需要表示部分\",{\"1\":{\"91\":1}}],[\"它适用于系统中存在大量相似对象且对象的状态可以共享的场景\",{\"1\":{\"94\":1}}],[\"它摒弃了在每个对象中保存所有数据的方式\",{\"1\":{\"94\":1}}],[\"它为子系统中的一组接口提供一个统一的高层接口\",{\"1\":{\"93\":3}}],[\"它为更高层提供了一个独立于硬件的接口\",{\"1\":{\"35\":1}}],[\"它可以控制对真实对象的访问\",{\"1\":{\"95\":1}}],[\"它可以将这些业务逻辑封装起来\",{\"1\":{\"93\":1}}],[\"它可以在不改变原有对象结构的情况下\",{\"1\":{\"92\":1}}],[\"它可能会导致类层次结构的复杂性增加\",{\"1\":{\"81\":1}}],[\"它是\",{\"1\":{\"153\":1}}],[\"它是在忍无可忍的时候\",{\"1\":{\"118\":1}}],[\"它是一种结构型设计模式\",{\"1\":{\"92\":1}}],[\"它是通过组合而不是继承来达到目的\",{\"1\":{\"90\":1}}],[\"它是组件建模\",{\"0\":{\"24\":1}}],[\"它能使你亏掉较预期多得多的\",{\"1\":{\"111\":1}}],[\"它能使接口不兼容的对象能够相互合作\",{\"1\":{\"89\":2}}],[\"它能够有效地增加新的操作而不改变元素类结构\",{\"1\":{\"106\":1}}],[\"它能创建一系列相关的对象\",{\"1\":{\"84\":2}}],[\"它还包含一个静态成员变量来存储唯一的实例\",{\"1\":{\"87\":1}}],[\"它使你能够复制已有对象\",{\"1\":{\"86\":1}}],[\"它使你能够分步骤创建复杂对象\",{\"1\":{\"85\":2}}],[\"它实现了生成器接口\",{\"1\":{\"85\":1}}],[\"它包含一系列的\",{\"1\":{\"106\":1}}],[\"它包含一个指向realcar对象的指针\",{\"1\":{\"95\":1}}],[\"它包含一个汽车工厂对象factory\",{\"1\":{\"93\":1}}],[\"它包含一个汽车结构体car和一个燃油容量fuelcapacity\",{\"1\":{\"89\":1}}],[\"它包含一个汽车结构体car和一个电池容量batterycapacity\",{\"1\":{\"89\":1}}],[\"它包含一个创建汽车对象的函数指针createcar\",{\"1\":{\"93\":1}}],[\"它包含一个电动汽车接口electriccarinterface和一个传统燃油汽车结构体gasolinecar的指针\",{\"1\":{\"89\":1}}],[\"它包含了一个生成器实例\",{\"1\":{\"85\":1}}],[\"它包含了一个测试方法testaddition\",{\"1\":{\"81\":1}}],[\"它包含了设置汽车模型\",{\"1\":{\"85\":1}}],[\"它包含汽车的模型\",{\"1\":{\"85\":1}}],[\"它知道如何按照一定的顺序调用生成器的方法来创建产品\",{\"1\":{\"85\":1}}],[\"它根据传入的汽车类型参数创建相应类型的汽车\",{\"1\":{\"83\":1,\"84\":1}}],[\"它通过将字符\",{\"1\":{\"171\":1}}],[\"它通过将抽象部分与实现部分分离\",{\"1\":{\"90\":1}}],[\"它通过引入一个中介对象来封装一系列对象之间的交互\",{\"1\":{\"100\":1}}],[\"它通过复制已有对象来创建新对象\",{\"1\":{\"86\":1}}],[\"它通过使用mcal层的api来访问can收发器硬件\",{\"1\":{\"35\":1}}],[\"它通常循着一条比较固定的路径运行\",{\"1\":{\"118\":1}}],[\"它通常包含了整个应用程序的基础架构\",{\"1\":{\"81\":1}}],[\"它通常涉及将一些常见的模式\",{\"1\":{\"81\":1}}],[\"它指导着框架与应用程序代码之间的交互方式\",{\"1\":{\"81\":1}}],[\"它接受一个动物对象并喂养它\",{\"1\":{\"81\":1}}],[\"它描述了系统的架构\",{\"1\":{\"74\":1}}],[\"它们就变成了原型\",{\"1\":{\"239\":1}}],[\"它们就像能根据需求进行调整的预制蓝图\",{\"1\":{\"69\":1,\"76\":1}}],[\"它们常常并不同步\",{\"1\":{\"111\":1}}],[\"它们通过中介者进行通信\",{\"1\":{\"100\":1}}],[\"它们可以将这些业务逻辑封装起来\",{\"1\":{\"93\":1}}],[\"它们是子系统中的具体实现类\",{\"1\":{\"93\":1}}],[\"它们扩展了car\",{\"1\":{\"90\":1}}],[\"它们分别创建相应类型的汽车对象\",{\"1\":{\"83\":1,\"84\":1}}],[\"它们实际上是对一组类的关系及\",{\"1\":{\"81\":1}}],[\"它们将复杂的系统分解为简单的模块\",{\"1\":{\"70\":1}}],[\"它们提供了一种通用的解决方案\",{\"1\":{\"70\":2}}],[\"配置方法\",{\"0\":{\"222\":1}}],[\"配置文件在仓库下的\",{\"1\":{\"162\":1}}],[\"配置文件在用户目录中\",{\"1\":{\"162\":1}}],[\"配置文件在程序的配置目录中\",{\"1\":{\"162\":1}}],[\"配置错误\",{\"1\":{\"155\":1}}],[\"配置结构\",{\"1\":{\"139\":1}}],[\"配置can的接收发送邮箱以及使用的filter\",{\"1\":{\"34\":1}}],[\"配置mcu的can外设操作功能以及can的filter\",{\"1\":{\"34\":1}}],[\"配置一些api的使能函数周期等\",{\"1\":{\"34\":1}}],[\"包括一系列步骤\",{\"1\":{\"105\":1}}],[\"包括一些抽象方法来延迟到子类实现\",{\"1\":{\"105\":1}}],[\"包括\",{\"1\":{\"103\":2,\"104\":1}}],[\"包括汽车的状态\",{\"1\":{\"101\":1}}],[\"包括引擎\",{\"1\":{\"100\":1}}],[\"包括playmusic和navigate方法\",{\"1\":{\"90\":1}}],[\"包括车型\",{\"1\":{\"87\":1}}],[\"包括用于区分can通信的接口\",{\"1\":{\"32\":1}}],[\"包含\",{\"1\":{\"182\":1}}],[\"包含大多数通用优化\",{\"1\":{\"182\":1}}],[\"包含服务未见\",{\"1\":{\"144\":1}}],[\"包含汽车对象的集合\",{\"1\":{\"99\":1}}],[\"包含汽车的模型和年份信息\",{\"1\":{\"83\":1}}],[\"包含了具体的共享状态\",{\"1\":{\"94\":1}}],[\"包含了一个对象的部分状态\",{\"1\":{\"94\":1}}],[\"包含操作方法\",{\"1\":{\"91\":1}}],[\"包含子节点\",{\"1\":{\"91\":1}}],[\"包含一个指向服务对象的引用成员变量\",{\"1\":{\"95\":1}}],[\"包含一个指向carsystem的指针\",{\"1\":{\"90\":1}}],[\"包含一个私有构造函数\",{\"1\":{\"87\":1}}],[\"包含一个抽象的产品方法\",{\"1\":{\"83\":1}}],[\"包含多个部件\",{\"1\":{\"85\":1}}],[\"包换can的状态管理以及pdu和信号的处理相关的模块\",{\"1\":{\"32\":1}}],[\"接近\",{\"1\":{\"187\":1}}],[\"接着\",{\"1\":{\"85\":2,\"92\":1}}],[\"接下来\",{\"1\":{\"83\":1,\"89\":1,\"95\":1,\"178\":1}}],[\"接收后应停止向该\",{\"1\":{\"152\":1}}],[\"接收推送的地址\",{\"1\":{\"147\":1}}],[\"接收服务状态改变通知\",{\"1\":{\"134\":1}}],[\"接收者\",{\"1\":{\"98\":2}}],[\"接收\",{\"1\":{\"32\":1}}],[\"接口隔离原则\",{\"1\":{\"81\":1}}],[\"接口\",{\"1\":{\"15\":1}}],[\"接口模型\",{\"1\":{\"6\":1,\"22\":1}}],[\"接口类型\",{\"1\":{\"3\":1}}],[\"html\",{\"1\":{\"223\":1}}],[\"http\",{\"1\":{\"160\":2,\"161\":1,\"163\":1,\"215\":2}}],[\"https\",{\"1\":{\"59\":1,\"160\":2,\"161\":1,\"163\":1,\"215\":2,\"223\":1}}],[\"heap\",{\"1\":{\"200\":1}}],[\"header\",{\"1\":{\"139\":2}}],[\"head\",{\"1\":{\"107\":1}}],[\"h\",{\"1\":{\"178\":6}}],[\"home\",{\"1\":{\"216\":2}}],[\"honda\",{\"1\":{\"86\":1,\"94\":2,\"99\":1,\"106\":1}}],[\"hope主题\",{\"1\":{\"57\":1}}],[\"h>\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":3,\"87\":2,\"89\":1,\"90\":2,\"91\":3,\"92\":1,\"93\":2,\"94\":2,\"95\":1,\"97\":3,\"98\":3,\"99\":3,\"100\":3,\"101\":3,\"102\":2,\"103\":2,\"104\":2,\"105\":1,\"106\":1,\"178\":1}}],[\"hand\",{\"1\":{\"240\":1}}],[\"handler\",{\"1\":{\"97\":1}}],[\"hatchback\",{\"1\":{\"83\":13,\"84\":13,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":2}}],[\"has\",{\"1\":{\"50\":1,\"100\":2}}],[\"haedwareabs\",{\"1\":{\"32\":1}}],[\"h和can\",{\"1\":{\"30\":1}}],[\"主动寻找目标服务\",{\"1\":{\"154\":1}}],[\"主动取消订阅\",{\"0\":{\"152\":1}}],[\"主动查找服务的行为\",{\"1\":{\"149\":1}}],[\"主动搜索服务\",{\"1\":{\"134\":1}}],[\"主题可以向所有注册的观察者广播更新通知\",{\"1\":{\"102\":1}}],[\"主题接口\",{\"1\":{\"102\":1}}],[\"主题\",{\"1\":{\"102\":1}}],[\"主管的manufacturecar方法按照一定的顺序调用生成器的方法来创建汽车\",{\"1\":{\"85\":1}}],[\"主管\",{\"1\":{\"85\":2}}],[\"主干需求与术语\",{\"1\":{\"48\":1}}],[\"主要结构说明\",{\"1\":{\"90\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1}}],[\"主要分为dio控制的和spi控制的\",{\"1\":{\"37\":1}}],[\"主要配置相关api的使能以及是否支持唤醒等功能\",{\"1\":{\"37\":1}}],[\"主要数处理can的控制器中的功能\",{\"1\":{\"33\":1}}],[\"主要包括can的driver\",{\"1\":{\"32\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"隐性电平则为逻辑1\",{\"1\":{\"30\":1}}],[\"其实现是由编译器提供的\",{\"1\":{\"193\":1}}],[\"其原理包括\",{\"1\":{\"183\":1}}],[\"其结果是一个新的字符串\",{\"1\":{\"171\":1}}],[\"其结果是惊人的\",{\"1\":{\"118\":1}}],[\"其\",{\"1\":{\"149\":1}}],[\"其它因素都是次要的\",{\"1\":{\"116\":1}}],[\"其相关依赖对象会得到通知并自动更新\",{\"1\":{\"102\":1}}],[\"其互动方式的描述\",{\"1\":{\"81\":1}}],[\"其中定义了一个类myclass和相关的方法和属性\",{\"1\":{\"178\":1}}],[\"其中某些步骤是抽象的\",{\"1\":{\"105\":1}}],[\"其中有两种具体的汽车制造流程\",{\"1\":{\"105\":1}}],[\"其中有两个主要功能维度\",{\"1\":{\"81\":1}}],[\"其中包括不同的汽车部件\",{\"1\":{\"100\":1}}],[\"其中包含汽车的名称和速度\",{\"1\":{\"92\":1}}],[\"其中包含一个drive方法\",{\"1\":{\"95\":1}}],[\"其中包含一个指向car结构体的指针和一个装饰函数指针\",{\"1\":{\"92\":1}}],[\"其中包含一个加油方法refuel\",{\"1\":{\"89\":1}}],[\"其中包含一个充电方法charge\",{\"1\":{\"89\":1}}],[\"其中包含一个car类型的指针car\",{\"1\":{\"87\":1}}],[\"其中包含一个抽象的工厂方法\",{\"1\":{\"83\":1}}],[\"其中只会有一个名为clone的方法\",{\"1\":{\"86\":1}}],[\"其中显性电平规定为逻辑0\",{\"1\":{\"30\":1}}],[\"其作用类似于人体的神经系统\",{\"1\":{\"46\":1}}],[\"其具体定义可通过下图来理解\",{\"1\":{\"30\":1}}],[\"其定义有\",{\"1\":{\"28\":1}}],[\"分散风险\",{\"1\":{\"124\":1}}],[\"分离关注点\",{\"1\":{\"106\":1}}],[\"分离遍历算法\",{\"1\":{\"99\":1}}],[\"分离抽象和实现\",{\"1\":{\"90\":1}}],[\"分别实现了不同的驾驶模式\",{\"1\":{\"104\":1}}],[\"分别实现了状态接口的具体行为\",{\"1\":{\"103\":1}}],[\"分别实现了carsystem接口的方法\",{\"1\":{\"90\":1}}],[\"分别用于添加gps和天窗功能\",{\"1\":{\"92\":1}}],[\"分别用于为汽车添加gps和天窗功能\",{\"1\":{\"92\":1}}],[\"分类和应用场景\",{\"1\":{\"68\":1}}],[\"分类总览\",{\"0\":{\"4\":1}}],[\"分为显性电平\",{\"1\":{\"30\":1}}],[\"llvm\",{\"1\":{\"190\":1}}],[\"list\",{\"1\":{\"215\":2}}],[\"links\",{\"1\":{\"215\":2}}],[\"linux上\",{\"1\":{\"222\":1}}],[\"linux\",{\"1\":{\"200\":1}}],[\"library\",{\"1\":{\"215\":1,\"223\":1}}],[\"licm\",{\"1\":{\"185\":1}}],[\"lighttextbox\",{\"1\":{\"81\":1}}],[\"lighttheme\",{\"1\":{\"81\":3}}],[\"lightbutton\",{\"1\":{\"81\":1}}],[\"large\",{\"1\":{\"105\":1}}],[\"luxury\",{\"1\":{\"105\":6}}],[\"luxurycar\",{\"1\":{\"105\":9}}],[\"leafgetchild\",{\"1\":{\"91\":2}}],[\"leafremove\",{\"1\":{\"91\":2}}],[\"leafadd\",{\"1\":{\"91\":2}}],[\"leafoperation\",{\"1\":{\"91\":2}}],[\"leaf\",{\"1\":{\"91\":19}}],[\"location\",{\"1\":{\"216\":3}}],[\"local级是仓库级别的配置\",{\"1\":{\"162\":1}}],[\"local\",{\"1\":{\"161\":1,\"162\":1,\"215\":2}}],[\"local三个级别的代理配置及优先级\",{\"1\":{\"158\":1}}],[\"loaded\",{\"1\":{\"50\":1}}],[\"logger\",{\"1\":{\"15\":1}}],[\"l线上的电位差来表示can信号\",{\"1\":{\"30\":1}}],[\"通用\",{\"1\":{\"136\":1}}],[\"通用性\",{\"1\":{\"76\":1}}],[\"通货膨胀\",{\"1\":{\"113\":1}}],[\"通知延迟\",{\"1\":{\"102\":1}}],[\"通知剩余观察者\",{\"1\":{\"102\":1}}],[\"通知观察者\",{\"1\":{\"102\":1}}],[\"通知相关的监控系统\",{\"1\":{\"102\":1}}],[\"通常由操作系统加一页保护区\",{\"1\":{\"204\":1}}],[\"通常配置于\",{\"1\":{\"156\":1}}],[\"通常每\",{\"1\":{\"153\":1}}],[\"通常是偶像人物\",{\"1\":{\"126\":1}}],[\"通常是一个抽象类或接口\",{\"1\":{\"106\":1}}],[\"通常是高层业务逻辑\",{\"1\":{\"90\":1}}],[\"通常情况下\",{\"1\":{\"95\":1}}],[\"通常包含一系列创建方法\",{\"1\":{\"85\":1}}],[\"通常会使用其他设计模式\",{\"1\":{\"81\":1}}],[\"通过图形视图或文本网格视图\",{\"1\":{\"235\":1}}],[\"通过图着色算法分配物理寄存器\",{\"1\":{\"186\":1}}],[\"通过调用myclass\",{\"1\":{\"178\":1}}],[\"通过调用单例类的公共静态方法来获取唯一的实例\",{\"1\":{\"87\":1}}],[\"通过将test\",{\"1\":{\"195\":1}}],[\"通过将字符\",{\"1\":{\"171\":1}}],[\"通过将现有字符串s和字符\",{\"1\":{\"171\":1}}],[\"通过将操作封装在访问者对象中\",{\"1\":{\"106\":1}}],[\"通过执行代理查看指令\",{\"1\":{\"163\":1}}],[\"通过增加新的具体访问者\",{\"1\":{\"106\":1}}],[\"通过备忘录模式\",{\"1\":{\"101\":1}}],[\"通过备忘录\",{\"1\":{\"101\":1}}],[\"通过定义统一的遍历接口\",{\"1\":{\"99\":1}}],[\"通过命令对象来解耦请求的发送者和接收者\",{\"1\":{\"98\":1}}],[\"通过共享相同的状态\",{\"1\":{\"94\":1}}],[\"通过共享多个对象所共有的相同状态\",{\"1\":{\"94\":1}}],[\"通过创建一个装饰类来包装原有的类\",{\"1\":{\"92\":1}}],[\"通过组合来减少继承层次\",{\"1\":{\"90\":1}}],[\"通过适配器对象调用充电方法\",{\"1\":{\"89\":1}}],[\"通过使用享元模式\",{\"1\":{\"94\":1}}],[\"通过使用工厂方法模式\",{\"1\":{\"83\":1}}],[\"通过使用设计模式\",{\"1\":{\"70\":4}}],[\"通过继承复用代码可能导致平行继承体系的产生\",{\"1\":{\"81\":1}}],[\"通过复用已有的代码\",{\"1\":{\"81\":1}}],[\"通过can\",{\"1\":{\"30\":1}}],[\"通信\",{\"1\":{\"46\":1}}],[\"通信介质选择灵活\",{\"1\":{\"29\":1}}],[\"通信标准\",{\"1\":{\"28\":2}}],[\"通信方向\",{\"1\":{\"3\":1}}],[\"信号表现为电压形式\",{\"1\":{\"30\":1}}],[\"信号类\",{\"1\":{\"6\":1}}],[\"某些特定的应用对标识符的分配进行了标准化\",{\"1\":{\"29\":1}}],[\"区分\",{\"1\":{\"29\":1}}],[\"非常简单\",{\"1\":{\"203\":1}}],[\"非破坏性的基于优先级的总线仲裁\",{\"1\":{\"29\":1}}],[\"非响应式\",{\"1\":{\"15\":1}}],[\"光纤\",{\"1\":{\"29\":1}}],[\"同样\",{\"1\":{\"117\":1}}],[\"同事类\",{\"1\":{\"100\":2}}],[\"同时避免了重复定义的问题\",{\"1\":{\"177\":1}}],[\"同时保持算法的整体结构不变\",{\"1\":{\"105\":1}}],[\"同时保持结构的灵活性和高效\",{\"1\":{\"79\":1}}],[\"同时又不改变其结构\",{\"1\":{\"92\":1}}],[\"同时适用于cp和ap两种系统\",{\"1\":{\"48\":1}}],[\"同时参与\",{\"0\":{\"11\":1}}],[\"同轴电缆\",{\"1\":{\"29\":1}}],[\"双肩图和头肩图\",{\"1\":{\"116\":1}}],[\"双绞线\",{\"1\":{\"29\":1}}],[\"双向通信\",{\"1\":{\"21\":1}}],[\"双向\",{\"1\":{\"6\":1}}],[\"距离最远可达10km\",{\"1\":{\"29\":1}}],[\"属于开环总线\",{\"1\":{\"28\":1}}],[\"属于闭环总线\",{\"1\":{\"28\":1}}],[\"≤\",{\"1\":{\"28\":1}}],[\"总之\",{\"1\":{\"177\":1}}],[\"总线上节点的数量可以动态改变\",{\"1\":{\"29\":1}}],[\"总线长度可达1000米\",{\"1\":{\"28\":1}}],[\"总线长度\",{\"1\":{\"28\":1}}],[\"总结对比\",{\"0\":{\"211\":1}}],[\"总结\",{\"0\":{\"22\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"~1mbps\",{\"1\":{\"28\":1}}],[\"kbps\",{\"1\":{\"28\":2}}],[\"有了判断\",{\"1\":{\"129\":1}}],[\"有人赚到钱\",{\"1\":{\"126\":1}}],[\"有别于股价的短期波动\",{\"1\":{\"124\":1}}],[\"有疑问的时候\",{\"1\":{\"124\":1}}],[\"有时很安静\",{\"1\":{\"118\":1}}],[\"有时子类想要改变骨架可能比较困难\",{\"1\":{\"105\":1}}],[\"有多个算法\",{\"1\":{\"105\":1}}],[\"有下面的公式\",{\"1\":{\"63\":1}}],[\"有计划的动态性\",{\"1\":{\"45\":1}}],[\"有两种\",{\"1\":{\"31\":1}}],[\"有\",{\"1\":{\"28\":1,\"81\":1,\"126\":1}}],[\"有响应\",{\"1\":{\"6\":1}}],[\"国际标准化的串行通信协议\",{\"1\":{\"28\":1}}],[\"国外已有许多大公司的产品采用了这一技术\",{\"1\":{\"27\":1}}],[\"采用面向服务的架构\",{\"1\":{\"45\":1}}],[\"采用双线差分信号\",{\"1\":{\"29\":1}}],[\"采用can总线上述问题便得到很好地解决\",{\"1\":{\"27\":1}}],[\"采用硬接信号线的方式不但烦琐\",{\"1\":{\"27\":1}}],[\"昂贵\",{\"1\":{\"27\":1}}],[\"由于数组索引是从零开始的\",{\"1\":{\"194\":1}}],[\"由于\",{\"1\":{\"193\":1}}],[\"由于我自己以中短期炒作为主\",{\"1\":{\"117\":1}}],[\"由于我们还没有创建真实汽车对象\",{\"1\":{\"95\":1}}],[\"由于引入了迭代器对象\",{\"1\":{\"99\":1}}],[\"由于请求是在责任链中传递的\",{\"1\":{\"97\":1}}],[\"由于使用了通用的组件接口\",{\"1\":{\"91\":1}}],[\"由于这些控制需检测及交换大量数据\",{\"1\":{\"27\":1}}],[\"由于其高性能\",{\"1\":{\"27\":1}}],[\"等调试器追踪函数调用链\",{\"1\":{\"207\":1}}],[\"等早期架构都默认向下增长\",{\"1\":{\"205\":1}}],[\"等工具分析瓶颈\",{\"1\":{\"189\":1}}],[\"等待回应\",{\"1\":{\"146\":1}}],[\"等待广播窗口开始\",{\"1\":{\"145\":1}}],[\"等到真正需要时再创建真实对象\",{\"1\":{\"95\":1}}],[\"等\",{\"1\":{\"27\":1}}],[\"及复杂的抗锁定刹车系统\",{\"1\":{\"27\":1}}],[\"及独\",{\"1\":{\"27\":1}}],[\"刹车控制\",{\"1\":{\"27\":1}}],[\"注\",{\"1\":{\"149\":1}}],[\"注册观察者\",{\"1\":{\"102\":1}}],[\"注油控制\",{\"1\":{\"27\":1}}],[\"注意危险信号\",{\"1\":{\"123\":1}}],[\"注意事项\",{\"0\":{\"20\":1}}],[\"注意\",{\"1\":{\"9\":1,\"149\":1}}],[\"特别在这些好消息公布之前\",{\"1\":{\"120\":1}}],[\"特别是在增加新元素类型时需要谨慎设计\",{\"1\":{\"106\":1}}],[\"特别是在创建复杂对象时\",{\"1\":{\"86\":1}}],[\"特别是有多个变种的算法时\",{\"1\":{\"105\":1}}],[\"特别是涉及到对象的深拷贝\",{\"1\":{\"101\":1}}],[\"特的设计\",{\"1\":{\"27\":1}}],[\"特性\",{\"1\":{\"6\":1}}],[\"高地址\",{\"1\":{\"199\":1,\"200\":1}}],[\"高\",{\"1\":{\"117\":1}}],[\"高层模块不应该依赖于低层模块\",{\"1\":{\"81\":1}}],[\"高效和可靠\",{\"1\":{\"76\":1}}],[\"高安全性嵌入式系统\",{\"1\":{\"46\":1}}],[\"高可靠性\",{\"1\":{\"27\":1}}],[\"高级实践\",{\"0\":{\"16\":1}}],[\"即超时\",{\"1\":{\"154\":1}}],[\"即使\",{\"1\":{\"153\":1}}],[\"即将\",{\"1\":{\"151\":1}}],[\"即将抽象和实现用组合的方式桥接在一起\",{\"1\":{\"90\":1}}],[\"即选择正确或选择赚钱\",{\"1\":{\"111\":1}}],[\"即控制器局域网络\",{\"1\":{\"27\":1}}],[\"即包含多个\",{\"1\":{\"17\":1}}],[\"架构主机上\",{\"1\":{\"187\":1}}],[\"架构清晰与系统稳定的基础\",{\"0\":{\"24\":1}}],[\"架构中\",{\"1\":{\"2\":1}}],[\"结果如下\",{\"1\":{\"187\":1}}],[\"结合实际示例\",{\"1\":{\"181\":1}}],[\"结论\",{\"0\":{\"157\":1}}],[\"结语\",{\"0\":{\"23\":1,\"191\":1,\"212\":1}}],[\"结构体等会存入\",{\"1\":{\"206\":1}}],[\"结构体\",{\"1\":{\"101\":2,\"102\":2,\"103\":1,\"104\":1}}],[\"结构或者逻辑抽象出来\",{\"1\":{\"81\":1}}],[\"结构型模式包括适配器模式\",{\"1\":{\"79\":1}}],[\"结构型模式介绍了如何将对象和类组装成较大的结构\",{\"1\":{\"79\":1}}],[\"结构型模式\",{\"1\":{\"79\":2}}],[\"结构型模式主要用于组织对象\",{\"1\":{\"79\":1}}],[\"结构型模式和行为型模式三大类\",{\"1\":{\"79\":1}}],[\"结构\",{\"1\":{\"77\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"结构接口字段分拆\",{\"1\":{\"21\":1}}],[\"结构化接口的字段级连接\",{\"0\":{\"16\":1}}],[\"十六进制\",{\"1\":{\"149\":2}}],[\"十\",{\"0\":{\"23\":1}}],[\"多播\",{\"1\":{\"141\":2}}],[\"多玩几种游戏\",{\"1\":{\"128\":1}}],[\"多级联动更新\",{\"1\":{\"102\":1}}],[\"多个算法有共同的流程\",{\"1\":{\"105\":1}}],[\"多个对象可以处理同一请求\",{\"1\":{\"97\":1}}],[\"多个产品等级结构\",{\"1\":{\"84\":1}}],[\"多重继承\",{\"1\":{\"81\":1}}],[\"多主站结构\",{\"1\":{\"29\":1}}],[\"多\",{\"1\":{\"22\":2,\"135\":1}}],[\"多组件共享数据\",{\"1\":{\"21\":1}}],[\"内联汇编与手动\",{\"1\":{\"190\":1}}],[\"内联函数展开\",{\"1\":{\"188\":1}}],[\"内存效率\",{\"1\":{\"212\":1}}],[\"内存地址从低到高排列\",{\"1\":{\"199\":1}}],[\"内存布局\",{\"1\":{\"198\":1}}],[\"内存访问频繁\",{\"1\":{\"188\":1}}],[\"内存消耗\",{\"1\":{\"86\":1,\"101\":1}}],[\"内幕消息\",{\"1\":{\"124\":1}}],[\"内容\",{\"1\":{\"22\":1}}],[\"内部代理\",{\"1\":{\"21\":1}}],[\"内部连接\",{\"1\":{\"9\":1}}],[\"八\",{\"0\":{\"22\":1,\"156\":1}}],[\"避免冲突\",{\"0\":{\"202\":1}}],[\"避免买太多股票\",{\"1\":{\"124\":1}}],[\"避免代码重复\",{\"1\":{\"105\":1}}],[\"避免多重条件语句\",{\"1\":{\"104\":1}}],[\"避免暴露内部细节\",{\"1\":{\"101\":1}}],[\"避免对象之间的直接依赖\",{\"1\":{\"100\":1}}],[\"避免其直接暴露在客户端代码中\",{\"1\":{\"95\":1}}],[\"避免了代码重复\",{\"1\":{\"105\":1}}],[\"避免了重复创建相同的对象\",{\"1\":{\"94\":1}}],[\"避免了多次创建和销毁实例所带来的资源浪费\",{\"1\":{\"87\":1}}],[\"避免了多个实例之间的竞争和冲突\",{\"1\":{\"87\":1}}],[\"避免出现内存泄漏等问题\",{\"1\":{\"87\":1}}],[\"避免重复生成\",{\"1\":{\"87\":1}}],[\"避免资源竞争和冲突\",{\"1\":{\"87\":1}}],[\"避免混合连接\",{\"1\":{\"21\":1}}],[\"避免数据冲突\",{\"1\":{\"21\":1}}],[\"单例类\",{\"1\":{\"87\":2}}],[\"单例模式适用于需要全局访问的对象\",{\"1\":{\"87\":1}}],[\"单例模式的优点是保证唯一性\",{\"1\":{\"87\":1}}],[\"单例模式的实例是在程序启动时创建的\",{\"1\":{\"87\":1}}],[\"单例模式是一种简单而实用的设计模式\",{\"1\":{\"87\":1}}],[\"单例模式是一种创建型设计模式\",{\"1\":{\"87\":1}}],[\"单例模式可能会出现线程安全问题\",{\"1\":{\"87\":1}}],[\"单例模式将创建实例和管理实例的职责集中在一个类中\",{\"1\":{\"87\":1}}],[\"单例模式避免了多个实例之间的竞争和冲突\",{\"1\":{\"87\":1}}],[\"单例模式只创建一个实例\",{\"1\":{\"87\":1}}],[\"单例模式提供了一个全局访问点来访问唯一的实例\",{\"1\":{\"87\":1}}],[\"单例模式保证一个类只有一个实例\",{\"1\":{\"87\":1}}],[\"单例模式\",{\"0\":{\"87\":1}}],[\"单一职责原则\",{\"1\":{\"81\":1}}],[\"单一职责\",{\"1\":{\"21\":1}}],[\"单向\",{\"1\":{\"6\":1}}],[\"禁用\",{\"1\":{\"21\":1}}],[\"映射\",{\"1\":{\"21\":1}}],[\"目标架构优化\",{\"1\":{\"186\":1}}],[\"目标接口\",{\"1\":{\"89\":1}}],[\"目标是为适用于大多数当前和未来can收发器设备定义接口和行为\",{\"1\":{\"35\":1}}],[\"目标\",{\"1\":{\"21\":1}}],[\"七\",{\"0\":{\"21\":1,\"155\":1,\"211\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1}}],[\"所谓\",{\"1\":{\"199\":1}}],[\"所经历的\",{\"1\":{\"143\":1}}],[\"所见到的大多是玩股的\",{\"1\":{\"125\":1}}],[\"所以\",{\"1\":{\"125\":1,\"154\":1}}],[\"所以很不愿意多谈\",{\"1\":{\"124\":1}}],[\"所以入场点的获胜概率应大过失败概率\",{\"1\":{\"120\":1}}],[\"所以我久赌必赢\",{\"1\":{\"119\":1}}],[\"所以成功的机会不大\",{\"1\":{\"111\":1}}],[\"所以代理会输出\",{\"1\":{\"95\":1}}],[\"所以你可在一切需要服务对象的代码中使用代理\",{\"1\":{\"95\":1}}],[\"所使用的\",{\"1\":{\"20\":1}}],[\"所有变量存栈\",{\"1\":{\"188\":1}}],[\"所有的疯狂都有梦醒时分\",{\"1\":{\"126\":1}}],[\"所有的专业炒手都不在乎赚钱或亏钱\",{\"1\":{\"124\":1}}],[\"所有连接必须为\",{\"1\":{\"20\":1}}],[\"所有连接为\",{\"1\":{\"15\":1}}],[\"所有\",{\"1\":{\"18\":1}}],[\"各同事类只知道中介者\",{\"1\":{\"100\":1}}],[\"各节点平等\",{\"1\":{\"29\":1}}],[\"各\",{\"1\":{\"20\":1}}],[\"只是利用了指针运算的语法\",{\"1\":{\"195\":1}}],[\"只要你\",{\"1\":{\"239\":1}}],[\"只要你自己喜欢\",{\"1\":{\"127\":1}}],[\"只要条件允许\",{\"1\":{\"123\":1}}],[\"只要股票运动正常\",{\"1\":{\"118\":1}}],[\"只有在交易量增加的前提下\",{\"1\":{\"120\":1}}],[\"只需要修改外观类中的汽车工厂对象\",{\"1\":{\"93\":1}}],[\"只需要创建新的生成器类即可\",{\"1\":{\"85\":1}}],[\"只需要创建新的具体工厂类即可\",{\"1\":{\"84\":2}}],[\"只需要通过生成器类提供的方法来获取产品即可\",{\"1\":{\"85\":1}}],[\"只需要通过抽象工厂类提供的方法来获取产品即可\",{\"1\":{\"84\":2}}],[\"只需要在新的工厂类中实现createshape方法\",{\"1\":{\"83\":1}}],[\"只需要调用抽象工厂函数即可创建所需类型的汽车对象\",{\"1\":{\"83\":1}}],[\"只被一个\",{\"1\":{\"19\":1}}],[\"只能参与一种连接类型\",{\"1\":{\"9\":1}}],[\"明确指定每个\",{\"1\":{\"19\":1}}],[\"中间代码优化\",{\"0\":{\"185\":1}}],[\"中间代码优化和后端生成优化\",{\"1\":{\"183\":1}}],[\"中间层次的组件通常更加模块化和可组合\",{\"1\":{\"81\":1}}],[\"中间层次的优点在于\",{\"1\":{\"81\":1}}],[\"中间层次的优点在于模式提供的复用方式要比框架的风险小\",{\"1\":{\"81\":1}}],[\"中间层次的设计模式提供了一种介于框架和单个类之间的解决方案\",{\"1\":{\"81\":1}}],[\"中介者的复杂性也会增加\",{\"1\":{\"100\":1}}],[\"中介者复杂性\",{\"1\":{\"100\":1}}],[\"中介者封装了对象之间的交互逻辑\",{\"1\":{\"100\":1}}],[\"中介者接口\",{\"1\":{\"100\":2}}],[\"中介者模式可以用于协调汽车部件\",{\"1\":{\"100\":1}}],[\"中介者模式引入了额外的中介对象\",{\"1\":{\"100\":1}}],[\"中介者模式将交互逻辑集中到中介者中\",{\"1\":{\"100\":1}}],[\"中介者模式通过引入一个中介对象\",{\"1\":{\"100\":2}}],[\"中介者模式主要包括以下几个部分\",{\"1\":{\"100\":1}}],[\"中介者模式是一种行为型设计模式\",{\"1\":{\"100\":1}}],[\"中介者模式\",{\"0\":{\"100\":1},\"1\":{\"79\":1}}],[\"中序遍历等\",{\"1\":{\"99\":1}}],[\"中的各种操作\",{\"1\":{\"106\":1}}],[\"中的\",{\"1\":{\"81\":1}}],[\"中\",{\"1\":{\"19\":1,\"99\":1,\"156\":1}}],[\"that\",{\"1\":{\"215\":1}}],[\"theory\",{\"1\":{\"124\":1}}],[\"the\",{\"1\":{\"89\":2,\"97\":3,\"215\":10}}],[\"txt\",{\"1\":{\"215\":3,\"216\":1}}],[\"t\",{\"1\":{\"194\":3,\"195\":4}}],[\"ttl=0\",{\"1\":{\"149\":1}}],[\"ttl\",{\"1\":{\"134\":1,\"135\":1,\"139\":1,\"144\":1,\"146\":1,\"147\":1,\"149\":16,\"151\":1,\"152\":1,\"154\":2,\"155\":1,\"157\":2}}],[\"tool\",{\"2\":{\"233\":1,\"246\":1}}],[\"to\",{\"1\":{\"103\":1,\"215\":4,\"240\":7}}],[\"toyota\",{\"1\":{\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":1,\"94\":2,\"98\":1,\"99\":1,\"106\":1}}],[\"table\",{\"1\":{\"149\":1}}],[\"target\",{\"1\":{\"89\":1}}],[\"task\",{\"1\":{\"50\":1}}],[\"types\",{\"0\":{\"239\":1}}],[\"type\",{\"1\":{\"83\":2,\"84\":2,\"85\":4,\"86\":4,\"87\":2,\"89\":2,\"93\":6,\"194\":4,\"195\":12,\"238\":3,\"239\":2}}],[\"typedef\",{\"1\":{\"81\":4,\"83\":2,\"84\":2,\"85\":5,\"86\":2,\"87\":3,\"89\":7,\"90\":6,\"91\":3,\"92\":2,\"93\":4,\"94\":4,\"95\":3,\"97\":4,\"98\":5,\"99\":3,\"100\":5,\"101\":3,\"102\":5,\"103\":5,\"104\":5,\"105\":3,\"106\":5,\"178\":1}}],[\"terminal\",{\"1\":{\"215\":1}}],[\"tesla\",{\"1\":{\"99\":1}}],[\"testing\",{\"1\":{\"97\":1}}],[\"testaddition\",{\"1\":{\"81\":1}}],[\"test\",{\"1\":{\"81\":2,\"194\":1}}],[\"textbox\",{\"1\":{\"81\":3}}],[\"text\",{\"1\":{\"49\":1,\"53\":1,\"143\":1,\"144\":1,\"163\":2,\"200\":1,\"236\":2,\"237\":1,\"238\":1,\"239\":1,\"244\":1}}],[\"template\",{\"0\":{\"105\":1}}],[\"tempsensor\",{\"1\":{\"18\":1}}],[\"temp\",{\"1\":{\"17\":1,\"18\":1}}],[\"trigger\",{\"1\":{\"240\":2}}],[\"triggers\",{\"1\":{\"237\":1}}],[\"truckaccept\",{\"1\":{\"106\":3}}],[\"truck\",{\"1\":{\"106\":19}}],[\"transmission\",{\"1\":{\"100\":23}}],[\"tr\",{\"1\":{\"40\":1,\"54\":1}}],[\"trcv抽象了can收发器硬件\",{\"1\":{\"35\":1}}],[\"trcv模块主要控制can外部收发器的模式\",{\"1\":{\"35\":1}}],[\"tresos\",{\"1\":{\"19\":1}}],[\"⚙️\",{\"0\":{\"19\":1}}],[\"均使用相同结构接口\",{\"1\":{\"18\":1}}],[\"↓\",{\"1\":{\"18\":1,\"156\":2}}],[\"→\",{\"1\":{\"18\":3,\"22\":2,\"137\":5,\"140\":5,\"199\":2}}],[\"func\",{\"1\":{\"203\":1}}],[\"fuel\",{\"1\":{\"101\":5,\"102\":11,\"104\":1}}],[\"fuelcapacity\",{\"1\":{\"89\":2}}],[\"fprofile\",{\"1\":{\"189\":1}}],[\"ftree\",{\"1\":{\"185\":1}}],[\"ffast\",{\"1\":{\"182\":1}}],[\"f\",{\"1\":{\"106\":1}}],[\"features\",{\"1\":{\"105\":1}}],[\"feed\",{\"1\":{\"81\":7}}],[\"file\",{\"1\":{\"215\":3,\"216\":1,\"238\":1}}],[\"files\",{\"1\":{\"215\":1}}],[\"find\",{\"1\":{\"139\":1,\"157\":1}}],[\"findservice\",{\"0\":{\"154\":1},\"1\":{\"134\":1,\"136\":1,\"137\":1,\"140\":1,\"141\":1,\"146\":1,\"149\":5,\"154\":4}}],[\"finalizeluxury\",{\"1\":{\"105\":2}}],[\"finalized\",{\"1\":{\"105\":2}}],[\"finalizeeconomy\",{\"1\":{\"105\":2}}],[\"finalize\",{\"1\":{\"105\":5}}],[\"first\",{\"1\":{\"99\":4,\"103\":1,\"107\":1}}],[\"fixed\",{\"1\":{\"50\":1}}],[\"factory\",{\"1\":{\"93\":4,\"94\":18}}],[\"facade\",{\"1\":{\"93\":1}}],[\"fan\",{\"0\":{\"13\":1,\"15\":1},\"1\":{\"21\":2,\"22\":2}}],[\"free\",{\"1\":{\"83\":3,\"84\":3,\"85\":3,\"86\":4,\"87\":1,\"90\":4,\"91\":9,\"92\":3,\"93\":2,\"94\":6,\"97\":3,\"98\":2,\"99\":6,\"100\":3,\"101\":2,\"102\":3,\"103\":4,\"104\":4}}],[\"from\",{\"1\":{\"50\":2,\"103\":3}}],[\"flask\",{\"1\":{\"215\":1}}],[\"flask>=1\",{\"1\":{\"215\":1}}],[\"flask~=1\",{\"1\":{\"215\":1}}],[\"flyweight\",{\"1\":{\"94\":3}}],[\"flexray\",{\"1\":{\"50\":1}}],[\"float32\",{\"1\":{\"17\":1}}],[\"found\",{\"1\":{\"247\":1}}],[\"foundation包含了ap和cp之间通用的内容以保证二者之间以及二者与非autosar系统之间的兼容性\",{\"1\":{\"47\":1}}],[\"foundation\",{\"0\":{\"47\":1}}],[\"foundationreleaseoverview\",{\"1\":{\"40\":1,\"54\":1}}],[\"follow\",{\"1\":{\"215\":2}}],[\"force\",{\"1\":{\"215\":1,\"216\":1}}],[\"ford\",{\"1\":{\"106\":1}}],[\"for\",{\"1\":{\"50\":3,\"91\":3,\"94\":1,\"97\":3,\"99\":1,\"102\":3,\"146\":1,\"187\":1,\"215\":2}}],[\"fo间的关系\",{\"0\":{\"49\":1}}],[\"fo部分所定义的内容为\",{\"1\":{\"48\":1}}],[\"fo部分所定义的通用特性\",{\"0\":{\"48\":1}}],[\"fo\",{\"0\":{\"47\":1}}],[\"up\",{\"1\":{\"215\":1}}],[\"updatenavigation\",{\"1\":{\"102\":2}}],[\"updatedashboard\",{\"1\":{\"102\":2}}],[\"update\",{\"1\":{\"102\":6}}],[\"usage\",{\"1\":{\"215\":1}}],[\"user\",{\"0\":{\"263\":1}}],[\"used\",{\"1\":{\"239\":2}}],[\"use\",{\"1\":{\"189\":1,\"215\":5,\"240\":1}}],[\"udp\",{\"1\":{\"136\":1,\"139\":1,\"155\":1,\"156\":1}}],[\"unset\",{\"1\":{\"161\":2}}],[\"unsubscribe\",{\"0\":{\"150\":1}}],[\"uni\",{\"1\":{\"140\":1}}],[\"undocommand\",{\"1\":{\"98\":3}}],[\"undostopengine\",{\"1\":{\"98\":2}}],[\"undostartengine\",{\"1\":{\"98\":2}}],[\"undo\",{\"1\":{\"98\":3}}],[\"unknown\",{\"1\":{\"97\":1}}],[\"untitled\",{\"1\":{\"73\":1}}],[\"unqueued\",{\"1\":{\"15\":1}}],[\"uint8\",{\"1\":{\"17\":1}}],[\"uint16\",{\"1\":{\"17\":1}}],[\"ignore\",{\"1\":{\"215\":2}}],[\"ip\",{\"0\":{\"132\":1,\"133\":1},\"1\":{\"133\":4,\"136\":1,\"138\":2,\"139\":3,\"144\":1,\"149\":1,\"150\":1,\"155\":1,\"156\":3,\"157\":1}}],[\"iterator\",{\"0\":{\"99\":1},\"1\":{\"99\":46}}],[\"its\",{\"1\":{\"50\":1}}],[\"i++\",{\"1\":{\"94\":1,\"102\":2,\"187\":1}}],[\"i\",{\"1\":{\"91\":8,\"94\":5,\"102\":8,\"187\":3}}],[\"implementor\",{\"1\":{\"90\":2}}],[\"implementation\",{\"1\":{\"81\":1}}],[\"imported\",{\"1\":{\"215\":1}}],[\"imports\",{\"1\":{\"215\":1}}],[\"import\",{\"1\":{\"81\":2}}],[\"isdone\",{\"1\":{\"99\":4}}],[\"is\",{\"1\":{\"50\":1,\"81\":2,\"95\":5,\"98\":3,\"103\":8}}],[\"iso11519\",{\"1\":{\"28\":1}}],[\"iso\",{\"1\":{\"28\":3}}],[\"id\",{\"1\":{\"29\":1,\"139\":1,\"147\":4}}],[\"ifndef\",{\"1\":{\"178\":1}}],[\"if\",{\"1\":{\"17\":1,\"18\":1,\"87\":1,\"91\":3,\"94\":1,\"95\":1,\"97\":6,\"98\":2,\"99\":3,\"100\":2,\"102\":2}}],[\"information\",{\"1\":{\"215\":1,\"240\":3}}],[\"info\",{\"1\":{\"215\":1}}],[\"init\",{\"1\":{\"146\":1,\"154\":1,\"178\":4,\"237\":1}}],[\"initial\",{\"1\":{\"143\":1,\"145\":1}}],[\"initializestates\",{\"1\":{\"103\":2}}],[\"invoker\",{\"1\":{\"98\":25}}],[\"instead\",{\"1\":{\"215\":1}}],[\"install\",{\"1\":{\"214\":1}}],[\"installing\",{\"1\":{\"105\":4}}],[\"installwheelsluxury\",{\"1\":{\"105\":2}}],[\"installwheelseconomy\",{\"1\":{\"105\":2}}],[\"installwheels\",{\"1\":{\"105\":5}}],[\"installengineluxury\",{\"1\":{\"105\":2}}],[\"installengineeconomy\",{\"1\":{\"105\":2}}],[\"installengine\",{\"1\":{\"105\":5}}],[\"instance\",{\"1\":{\"87\":7,\"147\":1}}],[\"inspection\",{\"1\":{\"97\":4}}],[\"inspecting\",{\"1\":{\"97\":3}}],[\"inspectbrake\",{\"1\":{\"97\":2}}],[\"inspectwheel\",{\"1\":{\"97\":2}}],[\"inspector\",{\"1\":{\"97\":15}}],[\"inspectengine\",{\"1\":{\"97\":2}}],[\"inspect\",{\"1\":{\"97\":8}}],[\"index\",{\"1\":{\"91\":5}}],[\"include\",{\"1\":{\"81\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":3,\"87\":2,\"89\":1,\"90\":2,\"91\":3,\"92\":1,\"93\":2,\"94\":2,\"95\":1,\"97\":3,\"98\":3,\"99\":3,\"100\":3,\"101\":3,\"102\":2,\"103\":2,\"104\":2,\"105\":1,\"106\":1,\"178\":3}}],[\"int\",{\"1\":{\"81\":2,\"83\":2,\"84\":2,\"85\":4,\"86\":3,\"87\":2,\"89\":4,\"90\":1,\"91\":9,\"92\":3,\"93\":2,\"94\":3,\"95\":1,\"97\":1,\"98\":1,\"99\":8,\"100\":1,\"101\":5,\"102\":19,\"103\":1,\"104\":1,\"105\":1,\"106\":4,\"177\":2,\"178\":2,\"187\":5,\"194\":2,\"195\":1,\"203\":2,\"209\":2}}],[\"into\",{\"1\":{\"50\":1}}],[\"interfaces\",{\"0\":{\"239\":1}}],[\"interface代表对象的共有部分\",{\"1\":{\"73\":1}}],[\"interface概念\",{\"0\":{\"73\":1}}],[\"interface\",{\"1\":{\"17\":1,\"20\":1,\"81\":2,\"95\":1,\"239\":1}}],[\"in\",{\"0\":{\"13\":1},\"1\":{\"21\":1,\"22\":1,\"104\":3,\"215\":6,\"216\":1,\"220\":1,\"239\":2}}],[\"六\",{\"0\":{\"16\":1,\"148\":1,\"208\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1}}],[\"如何生成requirements依赖文件\",{\"1\":{\"213\":1}}],[\"如循环展开和函数内联\",{\"1\":{\"182\":1}}],[\"如未收到续订\",{\"1\":{\"154\":1}}],[\"如听话\",{\"1\":{\"118\":1}}],[\"如经济模式\",{\"1\":{\"104\":2}}],[\"如订阅\",{\"1\":{\"102\":1}}],[\"如图形界面中的数据绑定\",{\"1\":{\"102\":1}}],[\"如仪表盘和导航系统\",{\"1\":{\"102\":1}}],[\"如仪表盘\",{\"1\":{\"102\":1}}],[\"如撤销操作\",{\"1\":{\"101\":1}}],[\"如速度和燃油量\",{\"1\":{\"101\":1}}],[\"如速度\",{\"1\":{\"101\":1,\"102\":1}}],[\"如前序遍历\",{\"1\":{\"99\":1}}],[\"如启动\",{\"1\":{\"103\":1}}],[\"如启动引擎\",{\"1\":{\"98\":1}}],[\"如启动发动机\",{\"1\":{\"98\":1}}],[\"如引擎\",{\"1\":{\"97\":1,\"100\":2}}],[\"如车轮\",{\"1\":{\"91\":1}}],[\"如android\",{\"1\":{\"90\":1}}],[\"如轿车\",{\"1\":{\"90\":1}}],[\"如组合或策略模式\",{\"1\":{\"81\":1}}],[\"如浅色主题\",{\"1\":{\"81\":1}}],[\"如按钮\",{\"1\":{\"81\":1}}],[\"如果计划手动实现swc\",{\"1\":{\"244\":1}}],[\"如果不想使用预定义的数据类型\",{\"1\":{\"240\":1}}],[\"如果不能处理则将请求传递给下一个处理者\",{\"1\":{\"97\":1}}],[\"如果本文有帮助\",{\"1\":{\"212\":1}}],[\"如果帧方向改变\",{\"1\":{\"210\":1}}],[\"如果栈向上增长\",{\"0\":{\"208\":1}}],[\"如果有\",{\"1\":{\"206\":1}}],[\"如果中间空间不足\",{\"1\":{\"202\":1}}],[\"如果你的系统上同时安装了多个版本的python\",{\"1\":{\"222\":1}}],[\"如果你想创建一个名为myenv的虚拟环境\",{\"1\":{\"222\":1}}],[\"如果你想在c\",{\"1\":{\"222\":1}}],[\"如果你想保留原始字符串不变\",{\"1\":{\"171\":1}}],[\"如果你不需要保留原始字符串\",{\"1\":{\"171\":1}}],[\"如果你只需要处理一些简单的http请求和响应\",{\"1\":{\"81\":1}}],[\"如果第一手没给你利润\",{\"1\":{\"124\":1}}],[\"如果犯了错\",{\"1\":{\"124\":1}}],[\"如果进展顺利\",{\"1\":{\"124\":1}}],[\"如果我的入场点选的正确\",{\"1\":{\"123\":1}}],[\"如果我们有更多的控件类型和主题样式\",{\"1\":{\"81\":1}}],[\"如果我们使用了多重继承\",{\"1\":{\"81\":1}}],[\"如果我们在子类中重写了动物的\",{\"1\":{\"81\":1}}],[\"如果我们要更换汽车的引擎\",{\"1\":{\"81\":1}}],[\"如果大市不好\",{\"1\":{\"121\":1}}],[\"如果是小股民的话\",{\"1\":{\"120\":1}}],[\"如果是大户的话\",{\"1\":{\"120\":1}}],[\"如果交易量没有增加\",{\"1\":{\"120\":1}}],[\"如果读者觉得还很抽象的话\",{\"1\":{\"118\":1}}],[\"如果股市交易总量很大\",{\"1\":{\"117\":1}}],[\"如果股票一跌破支撑线便反弹到支撑线之上\",{\"1\":{\"117\":1}}],[\"如果需要在系统中增加新的元素类型\",{\"1\":{\"106\":1}}],[\"如果需要频繁创建对象\",{\"1\":{\"86\":1}}],[\"如果策略过多\",{\"1\":{\"104\":1}}],[\"如果顺序很重要\",{\"1\":{\"102\":1}}],[\"如果观察者和主题之间的依赖关系过于复杂\",{\"1\":{\"102\":1}}],[\"如果观察者较多\",{\"1\":{\"102\":1}}],[\"如果责任链过长\",{\"1\":{\"97\":1}}],[\"如果系统的性能是一个关键因素\",{\"1\":{\"94\":1}}],[\"如果系统中存在大量相似的对象\",{\"1\":{\"94\":1}}],[\"如果系统中需要创建的产品种类较多\",{\"1\":{\"83\":1}}],[\"如果对象的状态非常复杂\",{\"1\":{\"101\":1}}],[\"如果对象的状态可以共享\",{\"1\":{\"94\":1}}],[\"如果对象的状态经常变化\",{\"1\":{\"94\":1}}],[\"如果对象的状态变化较小\",{\"1\":{\"86\":1}}],[\"如果享元对象需要依赖外部状态\",{\"1\":{\"94\":1}}],[\"如果存在则直接返回该对象\",{\"1\":{\"94\":1}}],[\"如果层次结构较深\",{\"1\":{\"91\":1}}],[\"如果一个对象的创建和销毁非常频繁\",{\"1\":{\"87\":1}}],[\"如果一个对象需要保证唯一性\",{\"1\":{\"87\":1}}],[\"如果一个对象需要被多个线程或进程共享\",{\"1\":{\"87\":1}}],[\"如果一个对象需要在整个程序中被全局访问\",{\"1\":{\"87\":1}}],[\"如果单例模式的实例没有被正确释放\",{\"1\":{\"87\":1}}],[\"如果instance已经存在\",{\"1\":{\"87\":1}}],[\"如果instance为空\",{\"1\":{\"87\":1}}],[\"如果创建一个复杂对象的过程比较复杂\",{\"1\":{\"86\":1}}],[\"如果原型对象包含敏感信息\",{\"1\":{\"86\":1}}],[\"如果原型对象包含指向其他对象的引用\",{\"1\":{\"86\":1}}],[\"如果原型对象数量较多\",{\"1\":{\"86\":1}}],[\"如果\",{\"1\":{\"81\":1}}],[\"如果父类实现了某个接口\",{\"1\":{\"73\":1}}],[\"如通信协议\",{\"1\":{\"48\":1}}],[\"如电驱控制\",{\"1\":{\"46\":1}}],[\"如自动驾驶\",{\"1\":{\"45\":1}}],[\"如下图\",{\"1\":{\"28\":2,\"31\":1}}],[\"如发动机的定时\",{\"1\":{\"27\":1}}],[\"如\",{\"1\":{\"15\":1,\"106\":1,\"182\":1,\"185\":1,\"189\":1,\"199\":1,\"202\":1}}],[\"合理化\",{\"1\":{\"118\":1}}],[\"合群\",{\"1\":{\"118\":1}}],[\"合法\",{\"1\":{\"22\":1}}],[\"合法连接方式\",{\"0\":{\"18\":1}}],[\"合法条件\",{\"1\":{\"15\":1}}],[\"合并逻辑后输出给\",{\"1\":{\"14\":1}}],[\"d\",{\"1\":{\"83\":3,\"84\":3,\"85\":2,\"86\":2,\"87\":2,\"93\":1,\"94\":2,\"99\":1,\"101\":2,\"102\":4,\"106\":3,\"178\":1}}],[\"drivingstatestop\",{\"1\":{\"103\":3}}],[\"drivingstatestart\",{\"1\":{\"103\":3}}],[\"drivingstatedrive\",{\"1\":{\"103\":3}}],[\"drivingstate\",{\"1\":{\"103\":11}}],[\"driving\",{\"1\":{\"95\":2,\"103\":5,\"104\":3}}],[\"drivenormal\",{\"1\":{\"104\":2}}],[\"drivesport\",{\"1\":{\"104\":2}}],[\"drivestrategy\",{\"1\":{\"104\":9}}],[\"driveeconomic\",{\"1\":{\"104\":2}}],[\"drive\",{\"1\":{\"95\":1,\"103\":5,\"104\":5}}],[\"driver\",{\"0\":{\"33\":1},\"1\":{\"32\":1}}],[\"draw\",{\"1\":{\"81\":1}}],[\"docs\",{\"1\":{\"223\":1}}],[\"do\",{\"1\":{\"215\":1}}],[\"double\",{\"1\":{\"195\":1}}],[\"down\",{\"1\":{\"145\":1,\"151\":1}}],[\"door\",{\"1\":{\"91\":5,\"97\":1}}],[\"dog\",{\"1\":{\"81\":10}}],[\"dominant\",{\"1\":{\"30\":1}}],[\"design\",{\"1\":{\"239\":1}}],[\"development\",{\"1\":{\"235\":1}}],[\"developer\",{\"0\":{\"226\":1,\"234\":1},\"1\":{\"234\":1},\"2\":{\"233\":1,\"246\":1}}],[\"debug\",{\"1\":{\"215\":2}}],[\"declaration\",{\"1\":{\"178\":1}}],[\"declarator\",{\"0\":{\"167\":1}}],[\"decoratewithsunroof\",{\"1\":{\"92\":2}}],[\"decoratewithgps\",{\"1\":{\"92\":2}}],[\"decorate\",{\"1\":{\"92\":3}}],[\"decoratorwithsunroof\",{\"1\":{\"92\":4}}],[\"decoratorwithgps\",{\"1\":{\"92\":4}}],[\"decorator\",{\"1\":{\"92\":24}}],[\"dealer\",{\"1\":{\"93\":10}}],[\"definition\",{\"1\":{\"178\":1}}],[\"define\",{\"1\":{\"102\":1,\"178\":1,\"194\":1}}],[\"defaults\",{\"1\":{\"215\":1}}],[\"default\",{\"1\":{\"83\":1,\"84\":1}}],[\"def\",{\"1\":{\"81\":7}}],[\"delegation\",{\"0\":{\"9\":1,\"11\":1},\"1\":{\"9\":1,\"11\":1,\"20\":1,\"21\":1,\"22\":1}}],[\"dynamic\",{\"1\":{\"50\":1,\"215\":1}}],[\"diff\",{\"1\":{\"215\":1}}],[\"difference\",{\"1\":{\"178\":1}}],[\"discovery\",{\"0\":{\"132\":1},\"1\":{\"133\":1}}],[\"display\",{\"1\":{\"15\":1,\"18\":1}}],[\"directories\",{\"1\":{\"215\":1}}],[\"directory\",{\"1\":{\"215\":2}}],[\"director\",{\"1\":{\"85\":23}}],[\"directly\",{\"1\":{\"50\":1}}],[\"dio控制的根据使用的pin关联到dio通道\",{\"1\":{\"37\":1}}],[\"da\",{\"0\":{\"262\":1}}],[\"data\",{\"1\":{\"137\":1,\"178\":4,\"200\":1,\"237\":2}}],[\"dataelementtoportmapping\",{\"1\":{\"19\":1}}],[\"dataelement\",{\"1\":{\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1}}],[\"dashboard\",{\"1\":{\"102\":15}}],[\"darktextbox\",{\"1\":{\"81\":1}}],[\"darktheme\",{\"1\":{\"81\":3}}],[\"darkbutton\",{\"1\":{\"81\":1}}],[\"davinci\",{\"0\":{\"226\":1,\"234\":1},\"1\":{\"19\":1,\"234\":1}}],[\"ntesting\",{\"1\":{\"97\":3}}],[\"normal\",{\"1\":{\"104\":1}}],[\"normalmode\",{\"1\":{\"104\":10}}],[\"now\",{\"1\":{\"100\":1,\"103\":1}}],[\"no\",{\"1\":{\"97\":3,\"215\":1}}],[\"notifyobservers\",{\"1\":{\"102\":5}}],[\"notify\",{\"1\":{\"100\":5}}],[\"not\",{\"1\":{\"95\":2,\"143\":1,\"215\":2,\"240\":1,\"247\":1}}],[\"nums\",{\"1\":{\"167\":1}}],[\"numcars\",{\"1\":{\"94\":1}}],[\"null\",{\"1\":{\"83\":1,\"84\":1,\"87\":2,\"91\":2,\"95\":2,\"97\":6,\"98\":3,\"99\":2,\"100\":2,\"104\":1}}],[\"name\",{\"1\":{\"91\":12,\"92\":3}}],[\"navigation\",{\"1\":{\"102\":14}}],[\"navigating\",{\"1\":{\"90\":2}}],[\"navigate\",{\"1\":{\"90\":8}}],[\"ncloned\",{\"1\":{\"86\":1}}],[\"needs\",{\"1\":{\"103\":1}}],[\"next\",{\"1\":{\"99\":4}}],[\"nextinspector\",{\"1\":{\"97\":6}}],[\"newcar\",{\"1\":{\"86\":6}}],[\"network\",{\"1\":{\"27\":1}}],[\"n\",{\"0\":{\"15\":1},\"1\":{\"81\":2,\"83\":3,\"84\":3,\"85\":3,\"86\":5,\"87\":3,\"89\":2,\"90\":4,\"91\":2,\"92\":2,\"93\":1,\"94\":1,\"95\":3,\"97\":10,\"98\":3,\"99\":1,\"100\":4,\"101\":1,\"102\":2,\"103\":9,\"104\":3,\"105\":13,\"106\":3,\"178\":1}}],[\"五\",{\"0\":{\"15\":1,\"147\":1,\"190\":1,\"207\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1}}],[\"允许向一个现有的对象添加新的功能\",{\"1\":{\"92\":1}}],[\"允许\",{\"1\":{\"13\":1}}],[\"不只是为了写好\",{\"1\":{\"212\":1}}],[\"不只是通信通道\",{\"0\":{\"24\":1}}],[\"不兼容主流系统\",{\"1\":{\"211\":1}}],[\"不显著影响编译时间\",{\"1\":{\"182\":1}}],[\"不再接受订阅\",{\"1\":{\"151\":1}}],[\"不支持\",{\"1\":{\"149\":1}}],[\"不支持多线程\",{\"1\":{\"87\":1}}],[\"不失效\",{\"1\":{\"146\":1}}],[\"不正常\",{\"1\":{\"129\":2}}],[\"不开心的游戏便快些离开\",{\"1\":{\"128\":1}}],[\"不读华尔街证券行的研究报告\",{\"1\":{\"124\":1}}],[\"不标新立异等等都成为炒股成功的障碍\",{\"1\":{\"118\":1}}],[\"不要尝试成为万事通\",{\"1\":{\"124\":1}}],[\"不要将钱全部投入股市\",{\"1\":{\"124\":1}}],[\"不要第一次就入市太深\",{\"1\":{\"124\":1}}],[\"不要不懂装懂\",{\"1\":{\"124\":1}}],[\"不要向下摊也可用另一种说法\",{\"1\":{\"124\":1}}],[\"不要向下摊平\",{\"1\":{\"124\":1}}],[\"不要试图寻找股票的最高点\",{\"1\":{\"122\":1}}],[\"不要把\",{\"1\":{\"120\":2}}],[\"不要把技术分析孤立起来看\",{\"1\":{\"117\":1}}],[\"不要怕\",{\"1\":{\"111\":1}}],[\"不会执行实际的运算\",{\"1\":{\"193\":1}}],[\"不会马上停止\",{\"1\":{\"116\":1}}],[\"不会暴露对象的内部细节\",{\"1\":{\"101\":1}}],[\"不贪\",{\"1\":{\"111\":1}}],[\"不适合用于频繁变化的对象\",{\"1\":{\"94\":1}}],[\"不希望使用继承或层次过深的继承结构\",{\"1\":{\"90\":1}}],[\"不同的命令可以控制汽车的操作\",{\"1\":{\"98\":1}}],[\"不同的汽车零部件\",{\"1\":{\"91\":1}}],[\"不同的实现方式或不同的配置选项的场景\",{\"1\":{\"85\":1}}],[\"不同类型的汽车可以使用不同的操作系统\",{\"1\":{\"90\":1}}],[\"不同类型的汽车\",{\"1\":{\"90\":1}}],[\"不允许\",{\"1\":{\"22\":1}}],[\"不能混用\",{\"1\":{\"22\":1}}],[\"不得存在\",{\"1\":{\"20\":1}}],[\"不被\",{\"1\":{\"13\":1}}],[\"不包含功能实现\",{\"1\":{\"3\":1}}],[\"─┘\",{\"1\":{\"13\":1}}],[\"─┐\",{\"1\":{\"13\":1}}],[\"被多个\",{\"0\":{\"13\":1}}],[\"拆分为两个独立端口\",{\"1\":{\"12\":1}}],[\"将值\",{\"1\":{\"195\":2}}],[\"将这个地址转换为\",{\"1\":{\"195\":1}}],[\"将这些对象连成一条链\",{\"1\":{\"97\":1}}],[\"将整数\",{\"1\":{\"195\":1}}],[\"将一个空指针转换为类型\",{\"1\":{\"194\":1}}],[\"将一些步骤延迟到子类中实现\",{\"1\":{\"105\":2}}],[\"将标量操作改为\",{\"1\":{\"185\":1}}],[\"将玩的费用分散些\",{\"1\":{\"128\":1}}],[\"将它当成是娱乐场所\",{\"1\":{\"128\":1}}],[\"将注意力集中在三至五只最有潜力的股票\",{\"1\":{\"124\":1}}],[\"将相关的操作集中到一个访问者中\",{\"1\":{\"106\":1}}],[\"将遍历算法与集合对象分离\",{\"1\":{\"99\":1}}],[\"将汽车对象添加到集合中\",{\"1\":{\"99\":1}}],[\"将请求委托给接收者执行\",{\"1\":{\"98\":1}}],[\"将请求的发送者和接收者解耦\",{\"1\":{\"97\":1}}],[\"将真实汽车对象与代理关联\",{\"1\":{\"95\":1}}],[\"将对象的状态分离出来\",{\"1\":{\"94\":1}}],[\"将零部件添加到汽车\",{\"1\":{\"91\":1}}],[\"将现有的接口转换为客户端期望的接口\",{\"1\":{\"89\":3}}],[\"将传统燃油汽车对象作为参数传递给适配器的构造函数\",{\"1\":{\"89\":1}}],[\"将源接口转换为目标接口的对象\",{\"1\":{\"89\":1}}],[\"将\",{\"1\":{\"12\":1}}],[\"└──→\",{\"1\":{\"15\":1}}],[\"└──\",{\"1\":{\"11\":1}}],[\"├──→\",{\"1\":{\"13\":1,\"15\":1}}],[\"├──\",{\"1\":{\"11\":1}}],[\"和炒手们谈谈天\",{\"1\":{\"125\":1}}],[\"和买股票一样\",{\"1\":{\"122\":1}}],[\"和变速箱\",{\"1\":{\"100\":1}}],[\"和当前索引\",{\"1\":{\"99\":1}}],[\"和一个组合节点\",{\"1\":{\"91\":1}}],[\"和掀背车的具体函数createsedan\",{\"1\":{\"83\":1,\"84\":1}}],[\"和隐性电平\",{\"1\":{\"30\":1}}],[\"和\",{\"0\":{\"11\":1,\"72\":1},\"1\":{\"28\":1,\"91\":2,\"99\":1,\"102\":1,\"103\":2,\"104\":1,\"105\":1,\"149\":1,\"170\":1,\"238\":1}}],[\"❌\",{\"0\":{\"11\":1,\"13\":1,\"209\":1,\"210\":1},\"1\":{\"13\":1,\"22\":1,\"211\":7}}],[\"四人组\",{\"1\":{\"69\":1}}],[\"四\",{\"0\":{\"10\":1,\"142\":1,\"189\":1,\"206\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1}}],[\"仅在\",{\"1\":{\"149\":1}}],[\"仅限\",{\"1\":{\"21\":1}}],[\"仅\",{\"1\":{\"9\":1}}],[\"仅定义\",{\"1\":{\"3\":1}}],[\"bin\",{\"1\":{\"221\":1}}],[\"by\",{\"1\":{\"215\":2,\"239\":1}}],[\"bss\",{\"1\":{\"200\":1}}],[\"b点分别是波峰和波谷\",{\"1\":{\"119\":1}}],[\"body\",{\"1\":{\"105\":2,\"176\":1}}],[\"between\",{\"1\":{\"178\":1}}],[\"before\",{\"1\":{\"103\":1}}],[\"be\",{\"1\":{\"103\":1,\"215\":2}}],[\"been\",{\"1\":{\"100\":1}}],[\"benz\",{\"1\":{\"94\":2}}],[\"bmw\",{\"1\":{\"94\":2}}],[\"black\",{\"1\":{\"94\":2}}],[\"blue\",{\"1\":{\"94\":2}}],[\"blueprint\",{\"0\":{\"74\":1}}],[\"browser\",{\"1\":{\"239\":1}}],[\"browser中\",{\"1\":{\"239\":1}}],[\"browser界面有三种视图\",{\"1\":{\"238\":1}}],[\"brake\",{\"1\":{\"97\":4}}],[\"brakeinspector\",{\"1\":{\"97\":15}}],[\"brand\",{\"1\":{\"94\":5}}],[\"branch>\",{\"1\":{\"59\":2}}],[\"branch\",{\"1\":{\"59\":1}}],[\"break\",{\"1\":{\"91\":1,\"102\":1}}],[\"backtrace\",{\"1\":{\"207\":1}}],[\"balanced\",{\"1\":{\"104\":1}}],[\"batterycapacity\",{\"1\":{\"89\":1}}],[\"base\",{\"1\":{\"85\":2,\"97\":3,\"221\":3}}],[\"based\",{\"1\":{\"50\":3}}],[\"build\",{\"1\":{\"85\":4}}],[\"builder\",{\"1\":{\"85\":29}}],[\"button\",{\"1\":{\"81\":3}}],[\"b表示a除以b的余数\",{\"1\":{\"63\":1}}],[\"b\",{\"1\":{\"8\":1,\"11\":1,\"13\":1,\"59\":1,\"63\":6}}],[\">|\",{\"1\":{\"141\":3}}],[\">visittruck\",{\"1\":{\"106\":1}}],[\">visitsuv\",{\"1\":{\"106\":1}}],[\">visitcar\",{\"1\":{\"106\":1}}],[\">accept\",{\"1\":{\"106\":3}}],[\">aggregate\",{\"1\":{\"99\":3}}],[\">update\",{\"1\":{\"102\":1}}],[\">undo\",{\"1\":{\"98\":1}}],[\">observers\",{\"1\":{\"102\":6}}],[\">observercount++\",{\"1\":{\"102\":1}}],[\">observercount\",{\"1\":{\"102\":5}}],[\">observer\",{\"1\":{\"102\":2}}],[\">operation\",{\"1\":{\"91\":1}}],[\">mediator\",{\"1\":{\"100\":1}}],[\">model\",{\"1\":{\"83\":6,\"84\":6,\"85\":2,\"86\":7,\"87\":2,\"93\":2,\"98\":3,\"99\":4,\"106\":3}}],[\">transmission\",{\"1\":{\"100\":4}}],[\">type\",{\"1\":{\"85\":2,\"86\":4,\"87\":2,\"93\":1}}],[\">isdone\",{\"1\":{\"99\":2}}],[\">inspect\",{\"1\":{\"97\":3}}],[\">fuel\",{\"1\":{\"101\":5,\"102\":1}}],[\">first\",{\"1\":{\"99\":2}}],[\">factory\",{\"1\":{\"93\":2}}],[\">execute\",{\"1\":{\"98\":1}}],[\">engine\",{\"1\":{\"81\":2,\"100\":2}}],[\">drive\",{\"1\":{\"95\":1,\"103\":2,\"104\":3}}],[\">decorate\",{\"1\":{\"92\":3}}],[\">realcar\",{\"1\":{\"95\":2}}],[\">notify\",{\"1\":{\"100\":2}}],[\">next\",{\"1\":{\"99\":2}}],[\">nextinspector\",{\"1\":{\"97\":10}}],[\">numcars++\",{\"1\":{\"94\":1}}],[\">numcars\",{\"1\":{\"94\":2}}],[\">name\",{\"1\":{\"91\":2,\"92\":3}}],[\">navigate\",{\"1\":{\"90\":2}}],[\">=\",{\"1\":{\"91\":2,\"99\":1}}],[\">playmusic\",{\"1\":{\"90\":2}}],[\">gasolinecar\",{\"1\":{\"89\":1}}],[\">currentstate\",{\"1\":{\"103\":10}}],[\">currentitem\",{\"1\":{\"99\":2}}],[\">currentindex++\",{\"1\":{\"99\":1}}],[\">currentindex\",{\"1\":{\"99\":5}}],[\">colleague\",{\"1\":{\"100\":6}}],[\">color\",{\"1\":{\"94\":3}}],[\">command\",{\"1\":{\"98\":11}}],[\">component\",{\"1\":{\"91\":18}}],[\">createcar\",{\"1\":{\"93\":2}}],[\">capacity\",{\"1\":{\"91\":4,\"99\":2}}],[\">cars\",{\"1\":{\"94\":4,\"99\":4}}],[\">carsystem\",{\"1\":{\"90\":9}}],[\">car\",{\"1\":{\"85\":5,\"87\":4,\"89\":2,\"90\":10,\"92\":3,\"98\":6}}],[\">children\",{\"1\":{\"91\":11}}],[\">childcount++\",{\"1\":{\"91\":1}}],[\">childcount\",{\"1\":{\"91\":7}}],[\">clone\",{\"1\":{\"86\":4}}],[\">brand\",{\"1\":{\"94\":3}}],[\">base\",{\"1\":{\"85\":4,\"97\":10}}],[\">build\",{\"1\":{\"85\":1}}],[\">builder\",{\"1\":{\"85\":9}}],[\">subject\",{\"1\":{\"102\":12}}],[\">shiftgear\",{\"1\":{\"100\":2}}],[\">size++\",{\"1\":{\"99\":1}}],[\">size\",{\"1\":{\"99\":4}}],[\">speed\",{\"1\":{\"92\":1,\"101\":5,\"102\":1}}],[\">settype\",{\"1\":{\"85\":1}}],[\">setyear\",{\"1\":{\"85\":1}}],[\">setmodel\",{\"1\":{\"85\":1}}],[\">strategy\",{\"1\":{\"104\":8}}],[\">state\",{\"1\":{\"101\":4,\"103\":9}}],[\">startengine\",{\"1\":{\"100\":2}}],[\">start\",{\"1\":{\"81\":1,\"103\":1}}],[\">stop\",{\"1\":{\"81\":1,\"103\":2}}],[\">year\",{\"1\":{\"83\":6,\"84\":6,\"85\":2,\"86\":5,\"87\":2,\"93\":2,\"99\":4,\"106\":3}}],[\">\",{\"1\":{\"8\":1,\"9\":1,\"11\":2,\"149\":5,\"162\":2,\"239\":2}}],[\"⇌\",{\"1\":{\"8\":1}}],[\"abi\",{\"1\":{\"205\":1,\"206\":1,\"211\":1}}],[\"abstract\",{\"1\":{\"105\":1}}],[\"abstraction\",{\"1\":{\"90\":2}}],[\"abs\",{\"1\":{\"27\":1}}],[\"attribute\",{\"1\":{\"190\":1}}],[\"avx\",{\"1\":{\"190\":1}}],[\"avx2\",{\"1\":{\"189\":1}}],[\"available\",{\"1\":{\"95\":2,\"97\":3,\"143\":1,\"145\":1,\"153\":1}}],[\"are\",{\"1\":{\"215\":1}}],[\"area\",{\"1\":{\"27\":1}}],[\"arguments\",{\"1\":{\"215\":1}}],[\"arr\",{\"1\":{\"187\":2}}],[\"arxml\",{\"1\":{\"156\":1}}],[\"activate\",{\"1\":{\"222\":1}}],[\"ack\",{\"1\":{\"136\":1,\"137\":1,\"140\":1,\"141\":1,\"155\":1}}],[\"access\",{\"0\":{\"243\":1},\"1\":{\"237\":1}}],[\"accept\",{\"1\":{\"106\":13}}],[\"accelerating\",{\"1\":{\"98\":1}}],[\"accelerate\",{\"1\":{\"98\":1}}],[\"accord\",{\"1\":{\"86\":1,\"99\":1}}],[\"aggregate\",{\"1\":{\"99\":4}}],[\"audi\",{\"1\":{\"94\":2}}],[\"auto\",{\"0\":{\"226\":1,\"228\":1,\"261\":1},\"1\":{\"90\":4,\"226\":1}}],[\"autosar年度关键节点\",{\"0\":{\"53\":1}}],[\"autosar标准制定方式\",{\"0\":{\"52\":1}}],[\"autosar技术标准针对不同的需求提供了不同的解决方案\",{\"1\":{\"44\":1}}],[\"autosar技术标准框架\",{\"0\":{\"44\":1}}],[\"autosar解决方案概述\",{\"0\":{\"43\":1}}],[\"autosar中国官方培训课程\",{\"1\":{\"40\":1,\"54\":1}}],[\"autosar\",{\"0\":{\"2\":1,\"24\":1,\"25\":1,\"32\":1,\"38\":1,\"39\":1,\"149\":1,\"156\":1,\"234\":1,\"249\":1},\"1\":{\"2\":1,\"13\":1,\"40\":1,\"54\":1,\"133\":1,\"144\":1,\"149\":1},\"2\":{\"41\":1,\"55\":1,\"232\":1,\"245\":1}}],[\"animal\",{\"1\":{\"81\":16}}],[\"androidnavigate\",{\"1\":{\"90\":2}}],[\"androidplaymusic\",{\"1\":{\"90\":2}}],[\"androidauto\",{\"1\":{\"90\":14}}],[\"android\",{\"1\":{\"90\":3}}],[\"and\",{\"0\":{\"239\":1},\"1\":{\"50\":1,\"178\":1,\"237\":1,\"240\":1}}],[\"also\",{\"1\":{\"215\":1}}],[\"already\",{\"1\":{\"103\":4}}],[\"alexander\",{\"1\":{\"68\":1}}],[\"all\",{\"1\":{\"50\":1}}],[\"alt\",{\"1\":{\"49\":1,\"53\":1,\"143\":1,\"144\":1,\"163\":2,\"236\":2,\"237\":1,\"238\":1,\"239\":1,\"244\":1}}],[\"adas\",{\"1\":{\"135\":1}}],[\"adaptee\",{\"1\":{\"89\":1}}],[\"adaptercharge\",{\"1\":{\"89\":2}}],[\"adapter\",{\"1\":{\"89\":9,\"156\":1}}],[\"adaptive\",{\"0\":{\"45\":1},\"1\":{\"45\":1}}],[\"additional\",{\"1\":{\"105\":1}}],[\"addcar\",{\"1\":{\"99\":4}}],[\"add\",{\"1\":{\"59\":1,\"91\":8}}],[\"address\",{\"1\":{\"50\":2}}],[\"api\",{\"1\":{\"156\":1}}],[\"ap演示代码在次年春季发布\",{\"1\":{\"53\":1}}],[\"ap不会替代ap\",{\"1\":{\"51\":1}}],[\"ap与cp相辅相成\",{\"1\":{\"51\":1}}],[\"applenavigate\",{\"1\":{\"90\":2}}],[\"appleplaymusic\",{\"1\":{\"90\":2}}],[\"applecarplay\",{\"1\":{\"90\":14}}],[\"apple\",{\"1\":{\"90\":4}}],[\"apply\",{\"1\":{\"81\":2}}],[\"application\",{\"0\":{\"238\":1},\"1\":{\"50\":1,\"156\":1,\"215\":1,\"237\":1}}],[\"applications\",{\"1\":{\"50\":1}}],[\"app\",{\"1\":{\"50\":1}}],[\"ap分层软件架构特点\",{\"1\":{\"45\":1}}],[\"ap\",{\"0\":{\"45\":1,\"49\":1,\"50\":1},\"1\":{\"50\":1}}],[\"assembling\",{\"1\":{\"105\":2}}],[\"assemblebodyluxury\",{\"1\":{\"105\":2}}],[\"assemblebodyeconomy\",{\"1\":{\"105\":2}}],[\"assemblebody\",{\"1\":{\"105\":5}}],[\"assemblyconnector\",{\"1\":{\"15\":1,\"20\":1}}],[\"assembly\",{\"0\":{\"8\":1,\"11\":1},\"1\":{\"8\":1,\"11\":1,\"21\":1,\"22\":1}}],[\"assertequals\",{\"1\":{\"81\":2}}],[\"assert\",{\"1\":{\"81\":1}}],[\"asc\",{\"1\":{\"27\":1}}],[\"a\",{\"1\":{\"8\":1,\"9\":1,\"11\":1,\"13\":1,\"63\":7,\"93\":1,\"119\":1,\"167\":1,\"170\":2,\"171\":10,\"215\":2,\"239\":1}}],[\"✅\",{\"0\":{\"8\":1,\"9\":1,\"12\":1,\"14\":1,\"17\":1,\"18\":1,\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"151\":1,\"152\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1},\"1\":{\"22\":1,\"189\":1,\"200\":1,\"211\":7}}],[\"三\",{\"0\":{\"7\":1,\"140\":1,\"187\":1,\"201\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"128\":1}}],[\"周期数据\",{\"1\":{\"6\":1}}],[\"场景描述\",{\"0\":{\"17\":1}}],[\"场景\",{\"1\":{\"6\":1}}],[\"按照标准规范\",{\"1\":{\"154\":1}}],[\"按规矩做\",{\"1\":{\"129\":1}}],[\"按这些游戏规则\",{\"1\":{\"128\":1}}],[\"按自己定好的规则买进卖出\",{\"1\":{\"121\":1}}],[\"按原来的预想\",{\"1\":{\"118\":1}}],[\"按接口类型\",{\"0\":{\"6\":1}}],[\"按通信角色\",{\"0\":{\"5\":1}}],[\"20\",{\"1\":{\"101\":1,\"102\":1}}],[\"200\",{\"1\":{\"92\":1,\"102\":1}}],[\"2021\",{\"1\":{\"106\":1}}],[\"2022\",{\"1\":{\"99\":1,\"106\":1}}],[\"2024\",{\"1\":{\"86\":1,\"99\":1}}],[\"2023\",{\"1\":{\"83\":3,\"84\":3,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":1,\"99\":1,\"106\":1,\"178\":2}}],[\"2\",{\"0\":{\"6\":1,\"71\":1,\"73\":1,\"77\":1,\"152\":1,\"185\":1,\"203\":1,\"236\":1,\"239\":1},\"1\":{\"59\":1,\"81\":2,\"91\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"118\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"149\":2,\"185\":1,\"203\":1,\"206\":1,\"209\":1,\"215\":2}}],[\"pin>\",{\"1\":{\"215\":2}}],[\"pipreqs\",{\"1\":{\"214\":1,\"215\":1,\"216\":2,\"217\":1},\"2\":{\"219\":1}}],[\"pip\",{\"1\":{\"214\":1}}],[\"pypi\",{\"1\":{\"215\":3}}],[\"python37\",{\"1\":{\"222\":1}}],[\"python=c\",{\"1\":{\"222\":1}}],[\"python虚拟环境配置及其工作原理\",{\"0\":{\"220\":1}}],[\"python项目生成requirements文件\",{\"0\":{\"213\":1}}],[\"python\",{\"0\":{\"260\":1},\"1\":{\"81\":1,\"220\":1,\"222\":3,\"223\":1},\"2\":{\"219\":1,\"225\":1}}],[\"ppireqs\",{\"0\":{\"214\":1}}],[\"pdp\",{\"1\":{\"205\":1}}],[\"pdf\",{\"1\":{\"81\":10}}],[\"pgo\",{\"1\":{\"189\":1}}],[\"phase\",{\"1\":{\"143\":3,\"155\":1}}],[\"perf\",{\"1\":{\"189\":1,\"207\":1}}],[\"performance\",{\"1\":{\"104\":2}}],[\"periodically\",{\"1\":{\"140\":1}}],[\"persistent\",{\"1\":{\"50\":1}}],[\"package\",{\"1\":{\"215\":1,\"238\":1}}],[\"path\",{\"1\":{\"215\":1}}],[\"patterns\",{\"0\":{\"230\":1}}],[\"pattern\",{\"0\":{\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"229\":1},\"1\":{\"92\":1}}],[\"page\",{\"1\":{\"204\":1,\"211\":1}}],[\"parameters\",{\"1\":{\"240\":1}}],[\"parameter\",{\"0\":{\"167\":1},\"1\":{\"215\":3}}],[\"paintluxury\",{\"1\":{\"105\":2}}],[\"painting\",{\"1\":{\"105\":2}}],[\"painteconomy\",{\"1\":{\"105\":2}}],[\"paint\",{\"1\":{\"105\":6}}],[\"passed\",{\"1\":{\"215\":1}}],[\"pass\",{\"1\":{\"81\":9}}],[\"playing\",{\"1\":{\"90\":2}}],[\"playmusic\",{\"1\":{\"90\":8}}],[\"platform是autosar为开发硬实时\",{\"1\":{\"46\":1}}],[\"platform是autosar为开发安全相关的高算力ecu\",{\"1\":{\"45\":1}}],[\"platform\",{\"0\":{\"45\":1,\"46\":1}}],[\"public\",{\"1\":{\"81\":2}}],[\"push\",{\"1\":{\"59\":1,\"140\":1,\"199\":2,\"207\":2}}],[\"powerful\",{\"1\":{\"105\":1}}],[\"posix\",{\"1\":{\"50\":1,\"221\":1}}],[\"ports\",{\"1\":{\"237\":1,\"240\":7}}],[\"port\",{\"0\":{\"2\":1,\"3\":1,\"4\":1,\"21\":1,\"24\":2,\"226\":1,\"243\":1,\"261\":1},\"1\":{\"2\":3,\"3\":1,\"5\":2,\"8\":2,\"9\":3,\"12\":1,\"18\":1,\"21\":2,\"22\":4,\"139\":1,\"155\":1,\"157\":1,\"160\":2,\"161\":1,\"226\":1,\"237\":2,\"239\":2,\"240\":1}}],[\"prefix来确定当前解释器是否从虚拟环境中运行\",{\"1\":{\"221\":1}}],[\"prefix\",{\"1\":{\"221\":1}}],[\"prefix指向用于创建环境的基本python\",{\"1\":{\"221\":1}}],[\"prefix指向虚拟环境的目录\",{\"1\":{\"221\":1}}],[\"prefix和\",{\"1\":{\"221\":1}}],[\"prefix和sys\",{\"1\":{\"221\":1}}],[\"prefix则指向虚拟环境的目录\",{\"1\":{\"221\":1}}],[\"private\",{\"1\":{\"167\":1}}],[\"printdata\",{\"1\":{\"178\":7}}],[\"printcarstate\",{\"1\":{\"101\":4}}],[\"printcar\",{\"1\":{\"86\":3,\"94\":6}}],[\"print\",{\"1\":{\"81\":2,\"215\":2}}],[\"printf\",{\"1\":{\"81\":2,\"83\":3,\"84\":3,\"85\":3,\"86\":5,\"87\":3,\"89\":2,\"90\":4,\"91\":2,\"92\":2,\"93\":1,\"94\":1,\"95\":3,\"97\":10,\"98\":3,\"99\":1,\"100\":4,\"101\":1,\"102\":2,\"103\":9,\"104\":3,\"105\":13,\"106\":3,\"178\":1}}],[\"provide\",{\"1\":{\"240\":3}}],[\"provider\",{\"0\":{\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"151\":1},\"1\":{\"5\":1,\"134\":1,\"137\":3,\"140\":3,\"141\":1,\"143\":1,\"149\":4,\"151\":2,\"152\":1,\"153\":4,\"154\":2,\"155\":1,\"157\":1}}],[\"projects\",{\"1\":{\"222\":1}}],[\"projects目录下创建虚拟环境\",{\"1\":{\"222\":1}}],[\"project\",{\"1\":{\"215\":3,\"216\":2}}],[\"protocol\",{\"1\":{\"139\":1}}],[\"prototypes\",{\"0\":{\"239\":1,\"261\":1}}],[\"prototypecar\",{\"1\":{\"86\":6}}],[\"prototype\",{\"1\":{\"86\":2,\"239\":2}}],[\"proxy=\",{\"1\":{\"215\":2}}],[\"proxy\",{\"1\":{\"95\":2,\"160\":2,\"161\":2,\"163\":2,\"215\":2}}],[\"product\",{\"1\":{\"85\":1}}],[\"pr\",{\"1\":{\"12\":1,\"21\":1}}],[\"p\",{\"1\":{\"5\":1,\"8\":1,\"22\":1,\"63\":13}}],[\"含义与特点\",{\"1\":{\"182\":1}}],[\"含义\",{\"1\":{\"5\":1,\"147\":1}}],[\"168\",{\"1\":{\"147\":1}}],[\"192\",{\"1\":{\"147\":1}}],[\"15\",{\"1\":{\"124\":1}}],[\"150\",{\"1\":{\"101\":1,\"102\":1,\"106\":1}}],[\"14\",{\"1\":{\"124\":1}}],[\"13\",{\"1\":{\"124\":1}}],[\"127\",{\"1\":{\"160\":2}}],[\"12\",{\"1\":{\"124\":1,\"209\":1}}],[\"125\",{\"1\":{\"28\":1}}],[\"1080\",{\"1\":{\"160\":1,\"215\":1}}],[\"10倒过来\",{\"1\":{\"117\":1}}],[\"10\",{\"1\":{\"102\":2,\"124\":2,\"147\":1,\"215\":6}}],[\"100\",{\"1\":{\"94\":1,\"101\":1,\"102\":1}}],[\"10～125\",{\"1\":{\"28\":1}}],[\"11\",{\"1\":{\"124\":1,\"205\":1}}],[\"11519两个系列\",{\"1\":{\"28\":1}}],[\"11898\",{\"1\":{\"28\":2}}],[\"1\",{\"0\":{\"5\":1,\"15\":1,\"68\":1,\"72\":1,\"76\":1,\"151\":1,\"184\":1,\"202\":1,\"235\":1,\"238\":1},\"1\":{\"59\":1,\"91\":2,\"102\":2,\"113\":1,\"114\":1,\"115\":1,\"118\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"149\":1,\"160\":2,\"187\":1,\"194\":2,\"195\":6,\"203\":1,\"206\":1,\"209\":1,\"215\":4}}],[\"二者都应该依赖于抽象\",{\"1\":{\"81\":1}}],[\"二\",{\"0\":{\"4\":1,\"139\":1,\"183\":1,\"200\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"111\":1,\"124\":1,\"128\":1}}],[\"certain\",{\"1\":{\"240\":1}}],[\"cd\",{\"1\":{\"222\":1}}],[\"cmd\",{\"1\":{\"222\":1}}],[\"custom\",{\"1\":{\"215\":1}}],[\"current\",{\"1\":{\"215\":1}}],[\"currentstate\",{\"1\":{\"103\":1}}],[\"currentindex\",{\"1\":{\"99\":2}}],[\"currentinspector\",{\"1\":{\"97\":2}}],[\"currentitem\",{\"1\":{\"99\":4}}],[\"c文件编译成汇编文件可发现\",{\"1\":{\"195\":1}}],[\"c文件\",{\"1\":{\"194\":1}}],[\"cse\",{\"1\":{\"185\":1}}],[\"c中定义的myobject对象\",{\"1\":{\"178\":1}}],[\"c中引用了在myclass\",{\"1\":{\"178\":1}}],[\"c语言sizeof宏分析\",{\"0\":{\"192\":1}}],[\"c语言\",{\"2\":{\"180\":1,\"197\":1}}],[\"c语言extern关键字作用分析\",{\"0\":{\"175\":1}}],[\"c语言汽车举例\",{\"1\":{\"93\":1}}],[\"c++中两种字符串拼接的区别\",{\"0\":{\"170\":1}}],[\"c++\",{\"2\":{\"169\":1,\"174\":1}}],[\"c++语法报错问题\",{\"1\":{\"166\":1}}],[\"c++语法报错集合汇总\",{\"0\":{\"166\":1}}],[\"cr\",{\"1\":{\"106\":1}}],[\"createnormalmode\",{\"1\":{\"104\":2}}],[\"createnavigation\",{\"1\":{\"102\":2}}],[\"createeconomicmode\",{\"1\":{\"104\":2}}],[\"createengine\",{\"1\":{\"100\":2}}],[\"createengineinspector\",{\"1\":{\"97\":2}}],[\"creatememento\",{\"1\":{\"101\":2}}],[\"createtransmission\",{\"1\":{\"100\":2}}],[\"createiterator\",{\"1\":{\"99\":2}}],[\"createbrakeinspector\",{\"1\":{\"97\":2}}],[\"createwheelinspector\",{\"1\":{\"97\":2}}],[\"createleaf\",{\"1\":{\"91\":4}}],[\"createapplecarplay\",{\"1\":{\"90\":2}}],[\"createandroidauto\",{\"1\":{\"90\":2}}],[\"createdrivingstate\",{\"1\":{\"103\":2}}],[\"createdashboard\",{\"1\":{\"102\":2}}],[\"createdecorator\",{\"1\":{\"92\":3}}],[\"createdirector\",{\"1\":{\"85\":2}}],[\"created\",{\"1\":{\"83\":3,\"84\":3}}],[\"createhatchback\",{\"1\":{\"83\":2,\"84\":2}}],[\"createsportmode\",{\"1\":{\"104\":2}}],[\"createstoppedstate\",{\"1\":{\"103\":2}}],[\"createstopenginecommand\",{\"1\":{\"98\":2}}],[\"createstartstate\",{\"1\":{\"103\":2}}],[\"createstartenginecommand\",{\"1\":{\"98\":2}}],[\"createsuv和createhatchback\",{\"1\":{\"83\":1,\"84\":1}}],[\"createsuv\",{\"1\":{\"83\":2,\"84\":2,\"90\":2}}],[\"createsedan\",{\"1\":{\"83\":2,\"84\":2,\"90\":2}}],[\"createcomposite\",{\"1\":{\"91\":2}}],[\"createconcreteengine\",{\"1\":{\"81\":2}}],[\"createcarmediator\",{\"1\":{\"100\":2}}],[\"createcarcollection\",{\"1\":{\"99\":2}}],[\"createcardealer\",{\"1\":{\"93\":2}}],[\"createcarfactory\",{\"1\":{\"93\":2,\"94\":2}}],[\"createcar\",{\"1\":{\"81\":2,\"83\":4,\"84\":4,\"86\":2,\"90\":1,\"92\":2,\"93\":3,\"102\":2,\"103\":2,\"104\":2}}],[\"chain\",{\"0\":{\"97\":1}}],[\"charging\",{\"1\":{\"89\":1}}],[\"charge\",{\"1\":{\"89\":4}}],[\"char\",{\"1\":{\"83\":1,\"84\":1,\"85\":3,\"86\":2,\"87\":1,\"89\":1,\"91\":3,\"92\":2,\"93\":1,\"97\":4,\"98\":1,\"99\":1,\"100\":2,\"106\":3}}],[\"checking\",{\"1\":{\"95\":1}}],[\"checkout\",{\"1\":{\"59\":1}}],[\"childcount\",{\"1\":{\"91\":1}}],[\"children\",{\"1\":{\"91\":1}}],[\"child\",{\"1\":{\"91\":6}}],[\"calibration\",{\"1\":{\"240\":2}}],[\"cast\",{\"1\":{\"140\":3}}],[\"case\",{\"1\":{\"83\":3,\"84\":3}}],[\"capacity\",{\"1\":{\"91\":1,\"99\":4}}],[\"camry\",{\"1\":{\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"93\":1,\"98\":1,\"99\":1,\"106\":1}}],[\"caraccept\",{\"1\":{\"106\":3}}],[\"carfeaturesvisitor\",{\"1\":{\"106\":6}}],[\"carfactory\",{\"1\":{\"93\":6,\"94\":7}}],[\"carmanufacturingprocess\",{\"1\":{\"105\":4}}],[\"carmediator\",{\"1\":{\"100\":19}}],[\"caretaker\",{\"1\":{\"101\":2}}],[\"carcollection\",{\"1\":{\"99\":15}}],[\"carcolor\",{\"1\":{\"94\":3}}],[\"carinspector\",{\"1\":{\"97\":21}}],[\"carproxy结构体是car接口的代理\",{\"1\":{\"95\":1}}],[\"carproxydrive\",{\"1\":{\"95\":3}}],[\"carproxy\",{\"1\":{\"95\":8}}],[\"carplaymusic\",{\"1\":{\"90\":4}}],[\"carplay\",{\"1\":{\"90\":4}}],[\"car5\",{\"1\":{\"94\":3}}],[\"car4\",{\"1\":{\"94\":3}}],[\"car3\",{\"1\":{\"94\":3,\"99\":5}}],[\"car2\",{\"1\":{\"94\":3,\"99\":5}}],[\"car1\",{\"1\":{\"94\":3,\"99\":5}}],[\"carstate\",{\"1\":{\"101\":2}}],[\"cars\",{\"1\":{\"94\":1,\"99\":1}}],[\"carsystem\",{\"1\":{\"90\":31}}],[\"carbrand\",{\"1\":{\"94\":3}}],[\"cardealer\",{\"1\":{\"93\":7}}],[\"carnavigate\",{\"1\":{\"90\":4}}],[\"cartype\",{\"1\":{\"83\":2,\"84\":2,\"85\":4,\"86\":3,\"87\":2,\"89\":2,\"93\":5}}],[\"car类依赖于engine接口\",{\"1\":{\"81\":1}}],[\"car\",{\"1\":{\"81\":17,\"83\":17,\"84\":17,\"85\":14,\"86\":28,\"87\":10,\"89\":8,\"90\":29,\"91\":13,\"92\":19,\"93\":16,\"94\":21,\"95\":9,\"98\":26,\"99\":24,\"101\":29,\"102\":32,\"103\":76,\"104\":33,\"105\":12,\"106\":19}}],[\"can调试策略\",{\"0\":{\"39\":1}}],[\"cantrcv的模式转换主要通过控制dio或者spi来控制硬件trcv\",{\"1\":{\"36\":1}}],[\"cantrcv\",{\"0\":{\"35\":1,\"36\":1}}],[\"canharadwareobject\",{\"1\":{\"34\":1}}],[\"cancontroller\",{\"1\":{\"34\":1}}],[\"cangeneral\",{\"1\":{\"34\":1}}],[\"can模块的收发\",{\"1\":{\"33\":1}}],[\"can系统构成\",{\"0\":{\"31\":1}}],[\"can功能特性\",{\"0\":{\"30\":1}}],[\"can特性\",{\"0\":{\"29\":1}}],[\"can总线上\",{\"1\":{\"30\":1}}],[\"can总线协议是一种iso\",{\"1\":{\"28\":1}}],[\"can总线是一种用于在不同的ecu\",{\"1\":{\"28\":1}}],[\"can标准及原理图\",{\"0\":{\"28\":1}}],[\"can最初是由德国的bosch公司为汽车监测\",{\"1\":{\"27\":1}}],[\"can越来越受到人们的重视\",{\"1\":{\"27\":1}}],[\"can通信概述\",{\"0\":{\"27\":1}}],[\"can通信基本原理\",{\"0\":{\"26\":1}}],[\"can\",{\"0\":{\"33\":1},\"1\":{\"25\":1,\"27\":1,\"28\":2,\"35\":2,\"50\":1,\"215\":1},\"2\":{\"42\":1}}],[\"can协议栈集成\",{\"0\":{\"38\":1}}],[\"can协议栈概述\",{\"0\":{\"32\":1}}],[\"can协议栈\",{\"0\":{\"25\":1}}],[\"cpu\",{\"1\":{\"189\":1}}],[\"cp和ap标准\",{\"1\":{\"53\":1}}],[\"cp应用范围更广\",{\"1\":{\"51\":1}}],[\"cp所定义的系统服务\",{\"1\":{\"46\":1}}],[\"cp分层软件架构支持\",{\"1\":{\"46\":1}}],[\"cp\",{\"0\":{\"46\":1,\"49\":1,\"50\":1},\"1\":{\"50\":1}}],[\"clean\",{\"1\":{\"215\":2}}],[\"clang\",{\"1\":{\"190\":1}}],[\"classes\",{\"1\":{\"93\":1}}],[\"class\",{\"1\":{\"81\":13,\"105\":2,\"167\":1}}],[\"classic基本使用\",{\"1\":{\"234\":1}}],[\"classic使用教程\",{\"0\":{\"234\":1}}],[\"classic\",{\"0\":{\"46\":1,\"226\":1,\"262\":1},\"1\":{\"46\":1}}],[\"clonedcar\",{\"1\":{\"86\":6}}],[\"clonecar\",{\"1\":{\"86\":2}}],[\"clone\",{\"1\":{\"86\":1}}],[\"click\",{\"1\":{\"81\":1}}],[\"client完成绑定\",{\"1\":{\"153\":1}}],[\"client\",{\"0\":{\"141\":1,\"144\":1,\"146\":1,\"152\":1,\"154\":1},\"1\":{\"6\":1,\"22\":1,\"86\":1,\"89\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":2,\"134\":1,\"135\":1,\"137\":2,\"138\":1,\"140\":2,\"141\":1,\"144\":1,\"149\":4,\"151\":1,\"152\":2,\"153\":4,\"154\":5,\"157\":1,\"240\":1}}],[\"colleague\",{\"1\":{\"100\":8}}],[\"collection\",{\"1\":{\"99\":24,\"181\":1}}],[\"color\",{\"1\":{\"94\":5}}],[\"compare\",{\"1\":{\"215\":1}}],[\"compiler\",{\"1\":{\"181\":1}}],[\"compositegetchild\",{\"1\":{\"91\":2}}],[\"compositeremove\",{\"1\":{\"91\":2}}],[\"compositeadd\",{\"1\":{\"91\":2}}],[\"compositeoperation\",{\"1\":{\"91\":2}}],[\"composite\",{\"1\":{\"91\":51}}],[\"composition\",{\"1\":{\"9\":3,\"11\":1,\"12\":1,\"21\":1}}],[\"components\",{\"0\":{\"238\":1},\"1\":{\"237\":1}}],[\"component\",{\"1\":{\"91\":55,\"92\":2,\"97\":16,\"238\":1,\"239\":3}}],[\"comma\",{\"1\":{\"215\":1}}],[\"command\",{\"0\":{\"98\":1},\"1\":{\"98\":40}}],[\"communication\",{\"1\":{\"50\":2}}],[\"com\",{\"1\":{\"59\":1}}],[\"code\",{\"1\":{\"50\":2}}],[\"connections\",{\"1\":{\"237\":1}}],[\"connect\",{\"0\":{\"226\":1,\"228\":1,\"261\":1},\"1\":{\"226\":1}}],[\"connector\",{\"0\":{\"8\":1,\"9\":1},\"1\":{\"21\":2}}],[\"consumer\",{\"0\":{\"142\":1,\"144\":1,\"146\":1}}],[\"constructluxurycar\",{\"1\":{\"105\":2}}],[\"constructeconomycar\",{\"1\":{\"105\":2}}],[\"const\",{\"1\":{\"91\":2,\"97\":4,\"100\":2}}],[\"containing\",{\"1\":{\"215\":1}}],[\"context\",{\"1\":{\"103\":2,\"104\":2}}],[\"controller\",{\"1\":{\"27\":1}}],[\"concreteelement\",{\"1\":{\"106\":1}}],[\"concreteengine是一个具体的实现\",{\"1\":{\"81\":1}}],[\"concreteengine\",{\"1\":{\"81\":2}}],[\"concretevisitor\",{\"1\":{\"106\":1}}],[\"concretestrategy\",{\"1\":{\"104\":2}}],[\"concretestate\",{\"1\":{\"103\":2}}],[\"concretesubject\",{\"1\":{\"102\":2}}],[\"concreteobserver\",{\"1\":{\"102\":2}}],[\"concretemediator\",{\"1\":{\"100\":2}}],[\"concreteaggregate\",{\"1\":{\"99\":2}}],[\"concreteiterator\",{\"1\":{\"99\":2}}],[\"concreteimplementor\",{\"1\":{\"90\":2}}],[\"concretecommand\",{\"1\":{\"98\":2}}],[\"concretehandler\",{\"1\":{\"97\":1}}],[\"concretebuilder\",{\"1\":{\"85\":31}}],[\"concrete\",{\"1\":{\"81\":3,\"85\":1,\"86\":1,\"92\":2,\"94\":1,\"105\":1}}],[\"configurator\",{\"0\":{\"262\":1}}],[\"configuration\",{\"1\":{\"50\":1}}],[\"config\",{\"1\":{\"139\":1,\"160\":2,\"161\":2,\"163\":2}}],[\"configset\",{\"1\":{\"37\":1}}],[\"c\",{\"0\":{\"166\":1,\"258\":1},\"1\":{\"3\":1,\"13\":1,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"94\":1,\"95\":1,\"178\":4,\"187\":1,\"193\":2,\"203\":1,\"212\":1,\"222\":1},\"2\":{\"109\":1,\"169\":1}}],[\"runnables\",{\"1\":{\"237\":1,\"240\":1}}],[\"r9\",{\"1\":{\"206\":1}}],[\"r8\",{\"1\":{\"206\":1}}],[\"rcx\",{\"1\":{\"206\":1}}],[\"rdx\",{\"1\":{\"206\":1}}],[\"rdi\",{\"1\":{\"206\":1}}],[\"rsi\",{\"1\":{\"206\":1}}],[\"rsp\",{\"1\":{\"199\":2,\"207\":1}}],[\"rbx\",{\"1\":{\"199\":1}}],[\"rbp+16\",{\"1\":{\"206\":1}}],[\"rbp+8\",{\"1\":{\"206\":1}}],[\"rbp+0\",{\"1\":{\"206\":1}}],[\"rbp\",{\"0\":{\"207\":1},\"1\":{\"195\":4,\"203\":5,\"206\":2,\"207\":4,\"209\":2,\"210\":1}}],[\"rtl\",{\"0\":{\"186\":1}}],[\"rte\",{\"0\":{\"156\":1},\"1\":{\"136\":2,\"156\":2}}],[\"ram\",{\"1\":{\"50\":1}}],[\"rom\",{\"1\":{\"50\":1}}],[\"router\",{\"1\":{\"14\":1,\"21\":1}}],[\"requests\",{\"1\":{\"215\":1}}],[\"requirements\",{\"1\":{\"215\":6,\"216\":2}}],[\"required\",{\"1\":{\"5\":1}}],[\"repetition\",{\"1\":{\"143\":1,\"145\":1,\"153\":1}}],[\"ready\",{\"1\":{\"143\":1}}],[\"real\",{\"1\":{\"95\":4}}],[\"realcar结构体实现了car接口\",{\"1\":{\"95\":1}}],[\"realcardrive\",{\"1\":{\"95\":2}}],[\"realcar\",{\"1\":{\"95\":7}}],[\"realloc\",{\"1\":{\"91\":1}}],[\"releasestates\",{\"1\":{\"103\":2}}],[\"registerobserver\",{\"1\":{\"102\":6}}],[\"response\",{\"1\":{\"140\":1}}],[\"responsibility\",{\"0\":{\"97\":1}}],[\"restorefrommemento\",{\"1\":{\"101\":2}}],[\"result\",{\"1\":{\"81\":2}}],[\"red\",{\"1\":{\"94\":2}}],[\"removing\",{\"1\":{\"215\":1}}],[\"removeobserver\",{\"1\":{\"102\":5}}],[\"remove\",{\"1\":{\"91\":5}}],[\"remote\",{\"1\":{\"59\":1}}],[\"reference\",{\"0\":{\"231\":1}}],[\"refresh\",{\"1\":{\"146\":1}}],[\"reflexivity\",{\"1\":{\"124\":1}}],[\"refinedabstraction\",{\"1\":{\"90\":2}}],[\"refueling\",{\"1\":{\"89\":1}}],[\"refuel\",{\"1\":{\"89\":3}}],[\"return\",{\"1\":{\"81\":3,\"83\":8,\"84\":8,\"85\":4,\"86\":3,\"87\":2,\"89\":1,\"90\":6,\"91\":6,\"92\":3,\"93\":4,\"94\":4,\"95\":1,\"97\":4,\"98\":3,\"99\":6,\"100\":4,\"101\":2,\"102\":4,\"103\":5,\"104\":5,\"105\":1,\"106\":1,\"178\":1,\"187\":1,\"194\":1}}],[\"receive\",{\"1\":{\"240\":2}}],[\"receiverport\",{\"0\":{\"13\":1},\"1\":{\"13\":1,\"15\":2,\"17\":1,\"18\":1}}],[\"receiver\",{\"1\":{\"6\":1,\"11\":1,\"14\":1,\"21\":1,\"22\":4,\"98\":2,\"240\":2}}],[\"recessive\",{\"1\":{\"30\":1}}],[\"r\",{\"1\":{\"3\":1,\"5\":1,\"8\":1,\"9\":2,\"15\":1,\"18\":1,\"22\":1}}],[\"scripts\",{\"1\":{\"221\":1,\"222\":1}}],[\"schemes\",{\"1\":{\"215\":1}}],[\"scheduling\",{\"1\":{\"50\":1}}],[\"sys\",{\"1\":{\"221\":4}}],[\"system级指的是程序级别的配置\",{\"1\":{\"162\":1}}],[\"system\",{\"1\":{\"97\":1,\"158\":1,\"161\":1,\"162\":1,\"206\":1}}],[\"symbolic\",{\"1\":{\"215\":1}}],[\"ssa\",{\"0\":{\"185\":1}}],[\"sd\",{\"0\":{\"133\":1,\"134\":1,\"149\":1},\"1\":{\"133\":1,\"136\":1,\"138\":1,\"139\":2,\"144\":1,\"146\":1,\"149\":3,\"150\":1,\"156\":1,\"157\":1}}],[\"should\",{\"1\":{\"215\":1}}],[\"shifted\",{\"1\":{\"100\":1}}],[\"shifting\",{\"1\":{\"100\":2}}],[\"shiftgear\",{\"1\":{\"100\":3}}],[\"shvets\",{\"1\":{\"68\":1}}],[\"simple\",{\"0\":{\"229\":1}}],[\"simd\",{\"1\":{\"185\":1,\"190\":1}}],[\"siezof\",{\"2\":{\"197\":1}}],[\"size\",{\"1\":{\"99\":1,\"187\":2,\"194\":4,\"195\":4}}],[\"sizeof\",{\"1\":{\"83\":3,\"84\":3,\"85\":3,\"86\":2,\"87\":1,\"90\":5,\"91\":4,\"92\":2,\"93\":3,\"94\":2,\"97\":3,\"98\":2,\"99\":6,\"100\":3,\"101\":2,\"102\":3,\"103\":4,\"104\":4,\"193\":4,\"194\":4,\"195\":2}}],[\"singleton\",{\"1\":{\"87\":9}}],[\"signal\",{\"1\":{\"50\":1}}],[\"switch\",{\"1\":{\"83\":1,\"84\":1}}],[\"swc\",{\"0\":{\"237\":1},\"1\":{\"3\":1,\"8\":4,\"9\":2,\"11\":2,\"13\":3,\"14\":1,\"15\":3,\"18\":4,\"21\":1,\"133\":1,\"156\":1}}],[\"successfully\",{\"1\":{\"216\":1}}],[\"sum\",{\"1\":{\"187\":1}}],[\"super\",{\"1\":{\"105\":14,\"106\":2}}],[\"support\",{\"1\":{\"50\":3}}],[\"sub\",{\"1\":{\"157\":1}}],[\"subscribed\",{\"1\":{\"146\":1,\"154\":1}}],[\"subscribe\",{\"1\":{\"137\":1,\"139\":1,\"141\":1,\"154\":2,\"155\":1}}],[\"subscribeeventgroupnack\",{\"1\":{\"149\":2}}],[\"subscribeeventgroupack\",{\"1\":{\"149\":2}}],[\"subscribeeventgroup\",{\"0\":{\"147\":1},\"1\":{\"136\":1,\"140\":1,\"149\":2,\"152\":1}}],[\"subsystem\",{\"1\":{\"93\":1}}],[\"subject\",{\"1\":{\"102\":33}}],[\"suvaccept\",{\"1\":{\"106\":3}}],[\"suvwithapple\",{\"1\":{\"90\":6}}],[\"suv\",{\"1\":{\"83\":16,\"84\":16,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":14,\"93\":2,\"106\":20}}],[\"software\",{\"1\":{\"235\":1,\"239\":1}}],[\"someip\",{\"0\":{\"256\":1}}],[\"somefunction\",{\"1\":{\"177\":1}}],[\"some\",{\"0\":{\"132\":1,\"133\":1},\"1\":{\"133\":2,\"138\":1,\"139\":2,\"144\":1,\"149\":1,\"150\":1,\"156\":2}}],[\"sold\",{\"1\":{\"93\":1}}],[\"solid\",{\"1\":{\"81\":1}}],[\"soa\",{\"1\":{\"45\":1}}],[\"standard\",{\"1\":{\"215\":1}}],[\"stack\",{\"1\":{\"156\":1,\"200\":1}}],[\"state\",{\"0\":{\"103\":1},\"1\":{\"101\":2,\"103\":39}}],[\"static\",{\"1\":{\"81\":1,\"87\":1}}],[\"startstatestop\",{\"1\":{\"103\":3}}],[\"startstatestart\",{\"1\":{\"103\":3}}],[\"startstatedrive\",{\"1\":{\"103\":3}}],[\"startstate\",{\"1\":{\"103\":11}}],[\"starting\",{\"1\":{\"98\":1,\"103\":1}}],[\"startenginecommand\",{\"1\":{\"98\":11}}],[\"startengine\",{\"1\":{\"98\":3,\"100\":3}}],[\"started\",{\"1\":{\"81\":1,\"100\":2,\"103\":2}}],[\"startcommand\",{\"1\":{\"98\":7}}],[\"startconcreteengine\",{\"1\":{\"81\":2}}],[\"startcar\",{\"1\":{\"81\":2}}],[\"start\",{\"1\":{\"81\":2,\"103\":6}}],[\"stopsubscribeeventgroup\",{\"1\":{\"149\":2}}],[\"stopofferservice\",{\"1\":{\"149\":2,\"151\":1}}],[\"stopping\",{\"1\":{\"98\":1,\"103\":2}}],[\"stoppedstatestop\",{\"1\":{\"103\":3}}],[\"stoppedstatestart\",{\"1\":{\"103\":3}}],[\"stoppedstatedrive\",{\"1\":{\"103\":3}}],[\"stoppedstate\",{\"1\":{\"103\":14}}],[\"stopped\",{\"1\":{\"81\":1,\"103\":1}}],[\"stopenginecommand\",{\"1\":{\"98\":11}}],[\"stopengine\",{\"1\":{\"98\":3}}],[\"stopcommand\",{\"1\":{\"98\":7}}],[\"stopconcreteengine\",{\"1\":{\"81\":2}}],[\"stopcar\",{\"1\":{\"81\":2}}],[\"stop\",{\"0\":{\"150\":1},\"1\":{\"81\":2,\"103\":6}}],[\"strategy\",{\"0\":{\"104\":1},\"1\":{\"104\":8}}],[\"strategies\",{\"1\":{\"50\":1}}],[\"strcmp\",{\"1\":{\"97\":3,\"100\":2}}],[\"strdup\",{\"1\":{\"86\":3,\"91\":2}}],[\"structure\",{\"1\":{\"106\":1}}],[\"struct\",{\"1\":{\"81\":2,\"83\":1,\"84\":1,\"85\":9,\"86\":3,\"87\":2,\"89\":8,\"90\":10,\"91\":10,\"92\":3,\"93\":3,\"94\":2,\"95\":3,\"97\":6,\"98\":7,\"99\":7,\"100\":8,\"101\":3,\"102\":11,\"103\":6,\"104\":6,\"105\":3,\"106\":9,\"178\":1}}],[\"saved\",{\"1\":{\"216\":1}}],[\"save\",{\"1\":{\"215\":1}}],[\"savepath\",{\"1\":{\"215\":1}}],[\"saving\",{\"1\":{\"104\":1}}],[\"safety\",{\"1\":{\"50\":1}}],[\"same\",{\"1\":{\"50\":1}}],[\"sport\",{\"1\":{\"104\":1}}],[\"sportmode\",{\"1\":{\"104\":10}}],[\"specification\",{\"1\":{\"50\":2}}],[\"speedsensor\",{\"1\":{\"18\":1}}],[\"speed\",{\"1\":{\"17\":1,\"18\":1,\"92\":3,\"101\":5,\"102\":11}}],[\"space\",{\"1\":{\"50\":2}}],[\"spi控制的要分配spi的sequence\",{\"1\":{\"37\":1}}],[\"separated\",{\"1\":{\"215\":1}}],[\"sec\",{\"1\":{\"154\":1}}],[\"sellcar\",{\"1\":{\"93\":4}}],[\"self\",{\"1\":{\"81\":7}}],[\"set\",{\"1\":{\"215\":1}}],[\"setstrategy\",{\"1\":{\"104\":4}}],[\"setcarstate\",{\"1\":{\"102\":4}}],[\"setcommand\",{\"1\":{\"98\":3}}],[\"setnextinspector\",{\"1\":{\"97\":3}}],[\"settype\",{\"1\":{\"85\":4}}],[\"setyear\",{\"1\":{\"85\":4}}],[\"setmodel\",{\"1\":{\"85\":4}}],[\"setmode函数用于被mainfunction或者canif接口调用控制\",{\"1\":{\"36\":1}}],[\"sedanwithandroid\",{\"1\":{\"90\":6}}],[\"sedan\",{\"1\":{\"83\":13,\"84\":13,\"85\":2,\"86\":2,\"87\":2,\"89\":2,\"90\":12,\"93\":2}}],[\"servlets\",{\"1\":{\"81\":1}}],[\"service\",{\"0\":{\"132\":1},\"1\":{\"50\":1,\"95\":2,\"133\":1,\"147\":1}}],[\"services\",{\"1\":{\"32\":1,\"240\":2}}],[\"server\",{\"1\":{\"6\":1,\"22\":1,\"81\":1,\"215\":2,\"240\":1}}],[\"sensor\",{\"1\":{\"15\":1}}],[\"senderport\",{\"0\":{\"11\":1,\"13\":1,\"15\":1},\"1\":{\"11\":1,\"12\":1,\"15\":1,\"17\":1,\"18\":2,\"19\":1,\"22\":1}}],[\"sender\",{\"1\":{\"6\":1,\"13\":2,\"19\":1,\"20\":1,\"21\":1,\"22\":3,\"240\":2}}],[\"s\",{\"1\":{\"3\":2,\"15\":1,\"83\":3,\"84\":3,\"85\":1,\"86\":1,\"87\":1,\"89\":2,\"91\":2,\"92\":2,\"93\":1,\"97\":3,\"98\":3,\"99\":1,\"106\":3,\"170\":3,\"171\":7,\"187\":3}}],[\"一致\",{\"1\":{\"211\":1}}],[\"一句话总结\",{\"0\":{\"138\":1}}],[\"一时这些资金集中在某个领域\",{\"1\":{\"126\":1}}],[\"一位成功投资者的重要素质之一便是市场情况不允许时\",{\"1\":{\"124\":1}}],[\"一位成功的炒手必须如一位成功的商人\",{\"1\":{\"118\":1}}],[\"一定要参照一下股票的走势图\",{\"1\":{\"120\":1}}],[\"一定要摸清对方的心理\",{\"1\":{\"111\":1}}],[\"一般来说\",{\"1\":{\"171\":1}}],[\"一般人常常想像出各种理由把这一不正常的运动\",{\"1\":{\"118\":1}}],[\"一般投资者入场买股票主要不是因为股票的成本收益比率低或红利高\",{\"1\":{\"116\":1}}],[\"一只正常运动的股票\",{\"1\":{\"118\":1}}],[\"一只无势的股票通常不适合炒作\",{\"1\":{\"116\":1}}],[\"一旦\",{\"1\":{\"154\":1}}],[\"一旦怀抱\",{\"1\":{\"125\":1}}],[\"一旦股价超过a点\",{\"1\":{\"119\":1}}],[\"一旦股票开始一个新的走势\",{\"1\":{\"118\":1}}],[\"一旦支撑线被突破\",{\"1\":{\"117\":1}}],[\"一旦阻力线被突破\",{\"1\":{\"117\":1}}],[\"一书出版以来\",{\"1\":{\"69\":1}}],[\"一些算法公式技巧摘录\",{\"0\":{\"62\":1}}],[\"一个是通货膨胀\",{\"1\":{\"117\":1}}],[\"一个元素的集合\",{\"1\":{\"106\":1}}],[\"一个对象的更新需要触发其他对象的更新\",{\"1\":{\"102\":1}}],[\"一个类存在两个独立变化的维度\",{\"1\":{\"90\":1}}],[\"一个类应该只负责一项职责\",{\"1\":{\"81\":1}}],[\"一个类应该只有一个引起它变化的原因\",{\"1\":{\"81\":1}}],[\"一个产品等级结构\",{\"1\":{\"84\":1}}],[\"一个\",{\"1\":{\"9\":1,\"17\":1,\"22\":3}}],[\"一\",{\"0\":{\"3\":1,\"133\":1,\"182\":1,\"199\":1},\"1\":{\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"111\":1,\"124\":1,\"128\":1}}],[\"是的\",{\"1\":{\"207\":1}}],[\"是什么\",{\"0\":{\"207\":1}}],[\"是现代进程最灵活的内存布局方式\",{\"1\":{\"200\":1}}],[\"是编译时计算大小的\",{\"1\":{\"193\":1}}],[\"是每位系统级开发者的必修课\",{\"1\":{\"191\":1}}],[\"是理解服务提供\",{\"1\":{\"149\":1}}],[\"是否占空间\",{\"0\":{\"207\":1}}],[\"是否完成订阅\",{\"1\":{\"144\":1}}],[\"是否过期\",{\"1\":{\"144\":1}}],[\"是否收到\",{\"1\":{\"144\":1}}],[\"是软件服务分布和动态绑定的基础\",{\"1\":{\"138\":1}}],[\"是软件组件\",{\"1\":{\"3\":1}}],[\"是怎么判断合理股价的\",{\"1\":{\"117\":1}}],[\"是极其危险的\",{\"1\":{\"111\":1}}],[\"是经验\",{\"1\":{\"111\":1}}],[\"是人性\",{\"1\":{\"111\":1}}],[\"是无需知道decorator的存在的\",{\"1\":{\"92\":1}}],[\"是抽象产品的具体实现\",{\"1\":{\"84\":1}}],[\"是具体工厂的父类\",{\"1\":{\"84\":1}}],[\"是具体产品的父类\",{\"1\":{\"84\":1}}],[\"是具体的产品对象\",{\"1\":{\"83\":1}}],[\"是\",{\"1\":{\"81\":1,\"133\":2,\"149\":1,\"154\":1,\"193\":1}}],[\"是建立稳定\",{\"1\":{\"2\":1}}],[\"是组件之间通信的桥梁\",{\"1\":{\"2\":1}}],[\"连接器和内部行为\",{\"1\":{\"235\":1}}],[\"连接原则\",{\"0\":{\"227\":1}}],[\"连接原理与实践总结\",{\"0\":{\"2\":1}}],[\"连接起来创建一个新的字符串对象\",{\"1\":{\"171\":1}}],[\"连接远程分支\",{\"1\":{\"59\":1}}],[\"连接职责单一\",{\"0\":{\"24\":1}}],[\"连接类型\",{\"1\":{\"22\":1}}],[\"连接\",{\"0\":{\"13\":1},\"1\":{\"237\":1}}],[\"连接方式解析\",{\"0\":{\"7\":1}}],[\"连接方式\",{\"1\":{\"2\":1,\"8\":1}}],[\"的合理性\",{\"1\":{\"198\":1}}],[\"的偏移量即为type的字节大小\",{\"1\":{\"195\":1}}],[\"的地址为0\",{\"1\":{\"195\":1}}],[\"的位置\",{\"1\":{\"195\":2}}],[\"的空指针时type\",{\"1\":{\"195\":1}}],[\"的空指针\",{\"1\":{\"195\":1}}],[\"的指针\",{\"1\":{\"195\":3}}],[\"的运算顺序可以分解为以下步骤\",{\"1\":{\"195\":1}}],[\"的实现通常依赖于编译器和目标体系结构\",{\"1\":{\"193\":1}}],[\"的多层次优化机制不仅提升了程序性能\",{\"1\":{\"191\":1}}],[\"的平台专属优化\",{\"1\":{\"186\":1}}],[\"的广播机制\",{\"1\":{\"153\":1}}],[\"的情况下有效\",{\"1\":{\"149\":1}}],[\"的语义由\",{\"1\":{\"149\":1}}],[\"的交互时序图\",{\"0\":{\"141\":1}}],[\"的能力\",{\"1\":{\"129\":1}}],[\"的上升几率\",{\"1\":{\"129\":1}}],[\"的特性\",{\"1\":{\"126\":1}}],[\"的恐惧和失去\",{\"1\":{\"125\":1}}],[\"的人士\",{\"1\":{\"124\":1}}],[\"的股民入市并非以赚钱为主要目的\",{\"1\":{\"118\":1}}],[\"的胜算或80\",{\"1\":{\"118\":1}}],[\"的胜算时应该为少\",{\"1\":{\"118\":1}}],[\"的胜算\",{\"1\":{\"118\":2}}],[\"的层次结构\",{\"1\":{\"91\":1}}],[\"的\",{\"0\":{\"154\":1},\"1\":{\"69\":1,\"151\":1,\"152\":1,\"154\":1,\"199\":1}}],[\"的区别\",{\"0\":{\"50\":1},\"1\":{\"170\":1}}],[\"的低速\",{\"1\":{\"28\":1}}],[\"的高速\",{\"1\":{\"28\":1}}],[\"的每个字段来自不同\",{\"1\":{\"22\":1}}],[\"的连接机制\",{\"1\":{\"2\":1}}],[\"的类型\",{\"1\":{\"2\":1}}],[\"的设计\",{\"0\":{\"2\":1}}],[\"理解类型\",{\"0\":{\"239\":1}}],[\"理解它\",{\"1\":{\"212\":1}}],[\"理解并善用这些优化手段\",{\"1\":{\"191\":1}}],[\"理解\",{\"1\":{\"2\":1}}],[\"在应用程序组件中配置服务端口\",{\"0\":{\"241\":1}}],[\"在object\",{\"1\":{\"239\":1}}],[\"在命令提示符或者powershell中\",{\"1\":{\"222\":1}}],[\"在windows\",{\"1\":{\"222\":1}}],[\"在每次\",{\"1\":{\"199\":1}}],[\"在现代编译器的加持下\",{\"1\":{\"191\":1}}],[\"在资源受限设备上优化体积\",{\"1\":{\"189\":1}}],[\"在嵌入式开发与高性能计算领域\",{\"1\":{\"181\":1}}],[\"在其中使用类和对象\",{\"1\":{\"178\":1}}],[\"在其中调用访问者对象的对应方法以便对自身进行操作\",{\"1\":{\"106\":1}}],[\"在全局范围内使用extern可以使变量在当前文件中具有全局作用域\",{\"1\":{\"177\":1}}],[\"在c++中\",{\"1\":{\"171\":1}}],[\"在c++类中vector声明\",{\"0\":{\"167\":1}}],[\"在c语言中声明和定义一个变量是同时进行的\",{\"1\":{\"176\":1}}],[\"在c语言中\",{\"1\":{\"81\":1,\"177\":1,\"178\":1}}],[\"在一台\",{\"1\":{\"187\":1}}],[\"在一个文件中使用\",{\"1\":{\"177\":1}}],[\"在一个文件中声明变量\",{\"1\":{\"177\":1}}],[\"在一个git脚本中当执行取消代理指令\",{\"1\":{\"163\":1}}],[\"在一固定的区间波动\",{\"1\":{\"118\":1}}],[\"在发现阶段使用的唯一探测方式\",{\"1\":{\"154\":1}}],[\"在假象被公众认识之前退出游戏\",{\"1\":{\"126\":1}}],[\"在本书的最后一章\",{\"1\":{\"125\":1}}],[\"在本例中是\",{\"1\":{\"100\":1}}],[\"在卖股时争取最大的税务效益\",{\"1\":{\"124\":1}}],[\"在你买股票之前\",{\"1\":{\"124\":1}}],[\"在买入之前\",{\"1\":{\"120\":2}}],[\"在实际中它们也最为有效\",{\"1\":{\"119\":1}}],[\"在炒股问题上\",{\"1\":{\"118\":1}}],[\"在正确的时间和环境做正确的事才有可能得到预想的效果\",{\"1\":{\"118\":1}}],[\"在忍无可忍的时候\",{\"1\":{\"118\":1}}],[\"在牛市结束或接近结束的时候卖掉你的所有股票\",{\"1\":{\"117\":1}}],[\"在跌势时\",{\"1\":{\"116\":1}}],[\"在升势图中\",{\"1\":{\"116\":1}}],[\"在股市\",{\"1\":{\"111\":1}}],[\"在示例中\",{\"1\":{\"106\":1}}],[\"在汽车制造的示例中\",{\"1\":{\"105\":1}}],[\"在汽车应用中\",{\"1\":{\"90\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1}}],[\"在运行时需要根据不同的条件选择不同的算法\",{\"1\":{\"104\":1}}],[\"在某些情况下\",{\"1\":{\"101\":1}}],[\"在getcar方法中\",{\"1\":{\"94\":1}}],[\"在getsingleton方法中\",{\"1\":{\"87\":1}}],[\"在sellcar函数中\",{\"1\":{\"93\":1}}],[\"在适配器的充电方法adaptercharge中\",{\"1\":{\"89\":1}}],[\"在适配器的构造函数中\",{\"1\":{\"89\":1}}],[\"在使用应用程序端口之前\",{\"1\":{\"240\":1}}],[\"在使用代理模式时\",{\"1\":{\"95\":1}}],[\"在使用享元模式时\",{\"1\":{\"94\":1}}],[\"在使用单例模式时\",{\"1\":{\"87\":1}}],[\"在使用框架时\",{\"1\":{\"81\":1}}],[\"在多线程环境下\",{\"1\":{\"87\":1}}],[\"在绝大多数情况下\",{\"1\":{\"86\":1}}],[\"在main函数中\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"87\":1,\"89\":1,\"93\":1,\"95\":1}}],[\"在函数内部\",{\"1\":{\"83\":1,\"84\":1}}],[\"在上升阶段\",{\"1\":{\"116\":1}}],[\"在上述示例代码中\",{\"1\":{\"93\":1}}],[\"在上述示例中\",{\"1\":{\"83\":1,\"84\":1,\"85\":1,\"87\":1,\"89\":1,\"94\":1,\"95\":1}}],[\"在上述代码中\",{\"1\":{\"92\":1}}],[\"在上面的示例中\",{\"1\":{\"81\":1}}],[\"在junit中\",{\"1\":{\"81\":1}}],[\"在这里我要强调的是\",{\"1\":{\"118\":1}}],[\"在这个判断过程中不应占有任何地位\",{\"1\":{\"125\":1}}],[\"在这个过程中\",{\"1\":{\"81\":1}}],[\"在这个例子中\",{\"1\":{\"81\":4,\"178\":1}}],[\"在这种原则下\",{\"1\":{\"81\":1}}],[\"在这种情况下\",{\"1\":{\"81\":1}}],[\"在重写方法时\",{\"1\":{\"81\":1}}],[\"在不预知对方\",{\"1\":{\"133\":1}}],[\"在不同的条件下创建不同的对象以及将对象的创建过程与使用过程分离的场景\",{\"1\":{\"83\":1}}],[\"在不同语言中的实现\",{\"1\":{\"77\":1}}],[\"在不修改现有代码的情况下\",{\"1\":{\"81\":1}}],[\"在软件开发中\",{\"1\":{\"81\":1}}],[\"在支持唤醒的trcv一定要确保下电进入sleep\",{\"1\":{\"36\":1}}],[\"在项目建模初期\",{\"0\":{\"24\":1}}],[\"在\",{\"1\":{\"2\":1,\"19\":1,\"121\":1,\"153\":2,\"206\":1,\"238\":2}}]],\"version\":2}}")).map(([e,t])=>[e,_t(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:n,options:o,id:s}})=>{const r=xt[n];e==="suggest"?self.postMessage([e,s,ve(t,r,o)]):e==="search"?self.postMessage([e,s,Ie(t,r,o,"max")]):self.postMessage({suggestions:[e,s,ve(t,r,o)],results:[e,s,Ie(t,r,o,__SLIMSEARCH_SORT_STRATEGY__)]})};
//# sourceMappingURL=index.js.map
