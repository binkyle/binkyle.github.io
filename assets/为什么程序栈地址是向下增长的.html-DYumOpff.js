import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as n}from"./app-CNJ3ilUI.js";const t={};function l(h,s){return n(),a("div",null,s[0]||(s[0]=[e(`<blockquote><p>💡 本文从体系结构、内存布局、寄存器设计、调试回溯角度全面分析“栈向下增长”的合理性。</p></blockquote><hr><h2 id="一、什么是-栈向下增长" tabindex="-1"><a class="header-anchor" href="#一、什么是-栈向下增长"><span>一、什么是“栈向下增长”？</span></a></h2><p>现代计算机中，内存地址从低到高排列：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>0x00000000 → 低地址</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>0xFFFFFFFF → 高地址</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓**“栈向下增长”<strong>，指的是栈顶指针（如 x86_64 的 <code>%rsp</code>）在每次 <code>push</code> 或局部变量分配时</strong>向低地址方向移动**，从而使新的数据被压入更低的地址：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> %</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ; %rsp -= 8，数据压入低地址</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="二、进程内存布局-栈在什么位置" tabindex="-1"><a class="header-anchor" href="#二、进程内存布局-栈在什么位置"><span>二、进程内存布局：栈在什么位置？</span></a></h2><p>以下是典型的 Linux 进程虚拟内存布局：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>高地址 ↑</span></span>
<span class="line"><span>+------------------------+ ← 栈 Stack（向下增长）</span></span>
<span class="line"><span>| 局部变量、返回地址等   |</span></span>
<span class="line"><span>+------------------------+</span></span>
<span class="line"><span>| 空闲区                 |</span></span>
<span class="line"><span>+------------------------+</span></span>
<span class="line"><span>| 堆 Heap（向上增长）     |</span></span>
<span class="line"><span>+------------------------+</span></span>
<span class="line"><span>| .bss / .data / .text   |</span></span>
<span class="line"><span>+------------------------+ ← 低地址</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>✅ 栈与堆背靠背扩展，是现代进程最灵活的内存布局方式。</p></blockquote><hr><h2 id="三、为什么程序栈向下增长" tabindex="-1"><a class="header-anchor" href="#三、为什么程序栈向下增长"><span>三、为什么程序栈向下增长？</span></a></h2><h3 id="✅-1-与堆对称增长-避免冲突" tabindex="-1"><a class="header-anchor" href="#✅-1-与堆对称增长-避免冲突"><span>✅ 1. 与堆对称增长，避免冲突</span></a></h3><ul><li>堆区从低地址向上扩展（如 malloc）。</li><li>栈从高地址向下扩展，两者互不干扰。</li><li>如果中间空间不足，可检测“栈溢出”或“堆撞栈”。</li></ul><hr><h3 id="✅-2-地址计算自然-负偏移更高效" tabindex="-1"><a class="header-anchor" href="#✅-2-地址计算自然-负偏移更高效"><span>✅ 2. 地址计算自然，负偏移更高效</span></a></h3><p>以 C 函数为例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> y </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>栈帧如下（向下增长）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[rbp]      ← 保存的旧帧地址</span></span>
<span class="line"><span>[rbp-4]    ← y</span></span>
<span class="line"><span>[rbp-8]    ← x</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>汇编：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">movl </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">$1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, -</span><span style="--shiki-light:#986801;--shiki-dark:#C678DD;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(%</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">movl </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">$2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, -</span><span style="--shiki-light:#986801;--shiki-dark:#C678DD;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(%</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 编译器只需不断“向下分配”变量偏移，非常简单。</p><p>❗ 若是“向上增长”，则需要不断维护最大正偏移，还要避免覆盖参数区，增加管理复杂度。</p><hr><h3 id="✅-3-页式管理高效-防溢出安全" tabindex="-1"><a class="header-anchor" href="#✅-3-页式管理高效-防溢出安全"><span>✅ 3. 页式管理高效，防溢出安全</span></a></h3><ul><li>栈的“底部”通常由操作系统加一页保护区（guard page），用于防止无限栈增长。</li><li>向下增长的设计使得每次扩展栈只需申请“更低地址的一页”，逻辑更简洁。</li></ul><hr><h3 id="✅-4-向后兼容旧架构" tabindex="-1"><a class="header-anchor" href="#✅-4-向后兼容旧架构"><span>✅ 4. 向后兼容旧架构</span></a></h3><ul><li>PDP-11、x86 等早期架构都默认向下增长。</li><li>为兼容早期汇编、调试器与 ABI，现代系统继续采用此设计。</li></ul><hr><h2 id="四、参数在栈中哪里" tabindex="-1"><a class="header-anchor" href="#四、参数在栈中哪里"><span>四、参数在栈中哪里？</span></a></h2><p>现代系统如 <strong>x86_64 (System V ABI)</strong>，参数主要通过寄存器传递：</p><table><thead><tr><th>参数编号</th><th>寄存器</th></tr></thead><tbody><tr><td>1</td><td><code>%rdi</code></td></tr><tr><td>2</td><td><code>%rsi</code></td></tr><tr><td>3</td><td><code>%rdx</code></td></tr><tr><td>4</td><td><code>%rcx</code></td></tr><tr><td>5</td><td><code>%r8</code></td></tr><tr><td>6</td><td><code>%r9</code></td></tr><tr><td>第 7 个及之后</td><td>压栈，在 <code>%rbp</code> 上方</td></tr></tbody></table><p>📌 <strong>溢出的参数、结构体等会存入“当前栈帧上方”，也就是“正偏移”部分：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[rbp+0]   ← 上一个 %rbp（保存）</span></span>
<span class="line"><span>[rbp+8]   ← 返回地址</span></span>
<span class="line"><span>[rbp+16]  ← 参数7（如果有）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="五、-上一个-rbp-是什么-是否占空间" tabindex="-1"><a class="header-anchor" href="#五、-上一个-rbp-是什么-是否占空间"><span>五、“上一个 %rbp” 是什么？是否占空间？</span></a></h2><p>是的，占用 <strong>8 字节</strong>（x86_64 下）！</p><p>每个函数在进入时都会执行：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> %</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        ; 保存上一个函数的基址</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">mov</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> %</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rsp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, %</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ; 建立当前栈帧基址</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 <code>push %rbp</code> 把调用者的栈帧基址压入栈中，构成“链式调用栈”。</p><p>这个设计的好处包括：</p><ul><li>支持 <code>gdb</code>, <code>perf</code> 等调试器追踪函数调用链（backtrace）</li><li>编译器可以通过 <code>%rbp</code> 统一管理局部变量和参数偏移</li></ul><hr><h2 id="六、如果栈向上增长-会怎样" tabindex="-1"><a class="header-anchor" href="#六、如果栈向上增长-会怎样"><span>六、如果栈向上增长，会怎样？</span></a></h2><h3 id="❌-问题一-变量管理复杂" tabindex="-1"><a class="header-anchor" href="#❌-问题一-变量管理复杂"><span>❌ 问题一：变量管理复杂</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> y </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>若使用“向上栈”，可能写成：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">movl </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">$1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#C678DD;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(%</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">movl </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">$2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#C678DD;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(%</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">rbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>难以保证不越界覆盖参数区</li><li>每次添加变量都要重新分配正偏移</li><li>参数和变量容易冲突</li></ul><hr><h3 id="❌-问题二-编译器和调试器成本增加" tabindex="-1"><a class="header-anchor" href="#❌-问题二-编译器和调试器成本增加"><span>❌ 问题二：编译器和调试器成本增加</span></a></h3><ul><li><code>gdb</code> 回溯函数时，需要逐级读取 <code>[rbp]</code> 链接的旧帧</li><li>如果帧方向改变，堆栈解引用逻辑复杂化，影响可维护性</li></ul><hr><h2 id="七、总结对比" tabindex="-1"><a class="header-anchor" href="#七、总结对比"><span>七、总结对比</span></a></h2><table><thead><tr><th>项目</th><th>向下增长 ✅</th><th>向上增长 ❌</th></tr></thead><tbody><tr><td>与堆布局互补</td><td>✅ 背靠背，空间灵活</td><td>❌ 可能冲突</td></tr><tr><td>偏移寻址逻辑</td><td>✅ 负偏移统一</td><td>❌ 需维护正偏移边界</td></tr><tr><td>参数和变量分区</td><td>✅ 清晰</td><td>❌ 重叠管理复杂</td></tr><tr><td>调试器栈回溯</td><td>✅ 简单，链式回溯</td><td>❌ 成本高</td></tr><tr><td>页式扩展与 guard page</td><td>✅ 自然扩展防溢出</td><td>❌ 控制复杂</td></tr><tr><td>向后兼容性</td><td>✅ ABI 一致</td><td>❌ 不兼容主流系统</td></tr></tbody></table><hr><h2 id="结语-原理即美学" tabindex="-1"><a class="header-anchor" href="#结语-原理即美学"><span>结语：原理即美学</span></a></h2><p>程序栈向下增长的设计并不是偶然，而是对<strong>架构一致性、内存效率、调试能力和软件兼容性</strong>的深思熟虑结果。</p><p>理解它，不只是为了写好 C 程序，更是通往底层世界的大门。</p><hr><p>📬 如果本文有帮助，欢迎留言、收藏或分享到你的朋友圈。</p>`,65)]))}const p=i(t,[["render",l]]),k=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E6%A0%88%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%91%E4%B8%8B%E5%A2%9E%E9%95%BF%E7%9A%84.html","title":"为什么程序栈地址是向下增长的？","lang":"zh-CN","frontmatter":{"title":"为什么程序栈地址是向下增长的？","date":"2025-06-08T00:00:00.000Z","categories":["操作系统","计算机体系结构"],"tags":["栈帧","内存布局","汇编","参数传递","调用栈"],"isOriginal":true,"article":true,"timeline":true,"description":"💡 本文从体系结构、内存布局、寄存器设计、调试回溯角度全面分析“栈向下增长”的合理性。 一、什么是“栈向下增长”？ 现代计算机中，内存地址从低到高排列： 所谓**“栈向下增长”，指的是栈顶指针（如 x86_64 的 %rsp）在每次 push 或局部变量分配时向低地址方向移动**，从而使新的数据被压入更低的地址： 二、进程内存布局：栈在什么位置？ 以...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么程序栈地址是向下增长的？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-08T15:18:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"孤星旅记\\",\\"url\\":\\"https://binkyle.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://binkyle.github.io/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E6%A0%88%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%91%E4%B8%8B%E5%A2%9E%E9%95%BF%E7%9A%84.html"}],["meta",{"property":"og:site_name","content":"孤星旅记"}],["meta",{"property":"og:title","content":"为什么程序栈地址是向下增长的？"}],["meta",{"property":"og:description","content":"💡 本文从体系结构、内存布局、寄存器设计、调试回溯角度全面分析“栈向下增长”的合理性。 一、什么是“栈向下增长”？ 现代计算机中，内存地址从低到高排列： 所谓**“栈向下增长”，指的是栈顶指针（如 x86_64 的 %rsp）在每次 push 或局部变量分配时向低地址方向移动**，从而使新的数据被压入更低的地址： 二、进程内存布局：栈在什么位置？ 以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-08T15:18:47.000Z"}],["meta",{"property":"article:tag","content":"调用栈"}],["meta",{"property":"article:tag","content":"参数传递"}],["meta",{"property":"article:tag","content":"汇编"}],["meta",{"property":"article:tag","content":"内存布局"}],["meta",{"property":"article:tag","content":"栈帧"}],["meta",{"property":"article:published_time","content":"2025-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-08T15:18:47.000Z"}]]},"git":{"createdTime":1749395927000,"updatedTime":1749395927000,"contributors":[{"name":"cxqd","username":"cxqd","email":"xb142857@outlook.com","commits":1,"url":"https://github.com/cxqd"}]},"readingTime":{"minutes":3.84,"words":1153},"filePathRelative":"技术笔记/编程语言/C/为什么程序栈地址是向下增长的.md","excerpt":"<blockquote>\\n<p>💡 本文从体系结构、内存布局、寄存器设计、调试回溯角度全面分析“栈向下增长”的合理性。</p>\\n</blockquote>\\n<hr>\\n<h2>一、什么是“栈向下增长”？</h2>\\n<p>现代计算机中，内存地址从低到高排列：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>0x00000000 → 低地址</span></span>\\n<span class=\\"line\\"><span>...</span></span>\\n<span class=\\"line\\"><span>0xFFFFFFFF → 高地址</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{p as comp,k as data};
