import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as r,a as n,d as i,o as s}from"./app-CNJ3ilUI.js";const l="/assets/1702912662265-B7K1kiGX.png",o="/assets/image-8-DxgORefB.png",c="/assets/1702912974159-qqa11pVJ.png",p="/assets/image-10-T3Dq12Dt.png",A="/assets/image-9-DT2b0jmE.png",d="/assets/image-11-3Wp5oE0C.png",h="/assets/image-12-JCOECkST.png",C="/assets/image-13-_1MqAajM.png",m="/assets/image-14-CXISMfiC.png",u={};function N(g,a){return s(),t("div",null,[a[0]||(a[0]=r("p",null,"本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略",-1)),n(" more "),a[1]||(a[1]=i('<h2 id="can通信基本原理" tabindex="-1"><a class="header-anchor" href="#can通信基本原理"><span>CAN通信基本原理</span></a></h2><h3 id="can通信概述" tabindex="-1"><a class="header-anchor" href="#can通信概述"><span>CAN通信概述</span></a></h3><p>CAN（Controller Area Network）即控制器局域网络。由于其高性能、高可靠性、及独 特的设计，CAN越来越受到人们的重视。国外已有许多大公司的产品采用了这一技术。</p><p>CAN最初是由德国的BOSCH公司为汽车监测、控制系统而设计的。现代汽车越来越多地采用电子装置控制，如发动机的定时、注油控制，加速、刹车控制（ASC）及复杂的抗锁定刹车系统（ABS）等。由于这些控制需检测及交换大量数据，采用硬接信号线的方式不但烦琐、昂贵，而且难以解决问题，采用CAN总线上述问题便得到很好地解决。</p><h3 id="can标准及原理图" tabindex="-1"><a class="header-anchor" href="#can标准及原理图"><span>CAN标准及原理图</span></a></h3><p>CAN总线是一种用于在不同的ECU（电子控制单元）之间传输数据的线，CAN总线协议是一种ISO 国际标准化的串行通信协议，有 ISO-11898 和 ISO-11519两个系列。其定义有：<br> ISO-11898 定义了通信速率为 125 kbps ~1Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米，如下图。</p><p>ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米，如下图。<br><img src="'+l+'" alt="Alt text" loading="lazy"></p><h3 id="can特性" tabindex="-1"><a class="header-anchor" href="#can特性"><span>CAN特性</span></a></h3><ul><li>传输速率最高可达1Mbps，距离最远可达10km</li><li>通信介质选择灵活（双绞线、同轴电缆、光纤）</li><li>采用双线差分信号</li><li>协议本身对节点的数量没有限制</li><li>总线上节点的数量可以动态改变，组网灵活</li><li>短帧结构，传输时间短，受干扰概率低</li><li>多主站结构，各节点平等，任一节点可在任一时刻主动发送</li><li>非破坏性的基于优先级的总线仲裁</li><li>优先级通过报文的标识符（ID）区分，报文标识符在网络中是唯一的 <ol><li>标识符描述了数据的含义</li><li>某些特定的应用对标识符的分配进行了标准化</li></ol></li><li>广播发送报文，报文可以被所有节点同时接收</li><li>根据需要可进行相关性报文过滤<br><img src="'+o+'" alt="Alt text" loading="lazy"><br><img src="'+c+'" alt="Alt text" loading="lazy"></li></ul><h3 id="can功能特性" tabindex="-1"><a class="header-anchor" href="#can功能特性"><span>CAN功能特性</span></a></h3><p>CAN总线上，信号表现为电压形式，通过CAN_H和CAN_L线上的电位差来表示CAN信号，分为显性电平(dominant)和隐性电平(recessive)两种类型。其中显性电平规定为逻辑0，隐性电平则为逻辑1。其具体定义可通过下图来理解。<br><img src="'+p+'" alt="Alt text" loading="lazy"></p><h3 id="can系统构成" tabindex="-1"><a class="header-anchor" href="#can系统构成"><span>CAN系统构成</span></a></h3><p>有两种，如下图；第三种是CAN收发器也集成到微控制器中<br><img src="'+A+'" alt="Alt text" loading="lazy"></p><h2 id="autosar-can协议栈概述" tabindex="-1"><a class="header-anchor" href="#autosar-can协议栈概述"><span>AUTOSAR CAN协议栈概述</span></a></h2><ul><li>Driver：主要包括CAN的Driver，以及根据外部的CAN的收</li></ul><ul><li>HaedwareAbs：包括用于区分CAN通信的接口，接收／发送不同功能的PDU以及控制CAN收发器进行工作的Transceiver</li></ul><ul><li>Services：包换CAN的状态管理以及PDU和信号的处理相关的模块<br><img src="'+d+'" alt="Alt text" loading="lazy"></li></ul><h3 id="can-driver" tabindex="-1"><a class="header-anchor" href="#can-driver"><span>CAN Driver</span></a></h3><ul><li>MCU的CAN外设控制模块</li><li>主要数处理CAN的控制器中的功能，实现 数据在MCU CAN模块的收发<br><img src="'+h+'" alt="Alt text" loading="lazy"></li></ul><h4 id="mcal相关配置" tabindex="-1"><a class="header-anchor" href="#mcal相关配置"><span>MCAL相关配置</span></a></h4><ul><li>CanGeneral：配置一些API的使能函数周期等</li><li>CanController：配置MCU的CAN外设操作功能以及CAN的Filter</li><li>CanHaradwareObject：配置CAN的接收发送邮箱以及使用的Filter</li></ul><h3 id="cantrcv" tabindex="-1"><a class="header-anchor" href="#cantrcv"><span>CANTrcv</span></a></h3><p>CAN Trcv模块主要控制CAN外部收发器的模式，MCU的CAN信号与CAN总线建立起数据交互;目标是为适用于大多数当前和未来CAN收发器设备定义接口和行为。CAN Trcv抽象了CAN收发器硬件。它为更高层提供了一个独立于硬件的接口。 它通过使用MCAL层的API来访问CAN收发器硬件，以便实现ECU布局中的抽象化。<br><img src="'+C+'" alt="Alt text" loading="lazy"></p><h4 id="cantrcv-模式切换" tabindex="-1"><a class="header-anchor" href="#cantrcv-模式切换"><span>CANTrcv 模式切换</span></a></h4><ul><li>CANTrcv的模式转换主要通过控制Dio或者SPI来控制硬件Trcv</li><li>上电调用Init可以直接切换到任意一个模式</li><li>SetMode函数用于被MainFunction或者CANIf接口调用控制</li><li>在支持唤醒的Trcv一定要确保下电进入Sleep，才能有唤醒功能，这个时候Trcv处于常电模式，且唤醒中断引脚连接SBC的唤醒引脚<br><img src="'+m+'" alt="Alt text" loading="lazy"></li></ul><h4 id="mcal配置" tabindex="-1"><a class="header-anchor" href="#mcal配置"><span>MCAL配置</span></a></h4><p>·General：主要配置相关API的使能以及是否支持唤醒等功能<br> ·ConfigSet：根据外部电路配置Trcv的通道，主要分为DIO控制的和SPI控制的，DIO控制的根据使用的PIN关联到DIO通道，SPI控制的要分配SPI的Sequence</p><h2 id="autosar-can协议栈集成" tabindex="-1"><a class="header-anchor" href="#autosar-can协议栈集成"><span>AUTOSAR CAN协议栈集成</span></a></h2><h2 id="autosar-can调试策略" tabindex="-1"><a class="header-anchor" href="#autosar-can调试策略"><span>AUTOSAR CAN调试策略</span></a></h2><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h3><p><a href="https://www.autosar.org/fileadmin/standards/R20-11/FO/AUTOSAR_TR_FoundationReleaseOverview.pdf" target="_blank" rel="noopener noreferrer">AUTOSAR_TR_FoundationReleaseOverview</a><br> AUTOSAR中国官方培训课程</p>',31))])}const f=e(u,[["render",N]]),x=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Autosar/autosar_can_protocol.html","title":"Autosar can协议栈","lang":"zh-CN","frontmatter":{"title":"Autosar can协议栈","icon":"file","order":1,"date":"2023-12-18T00:00:00.000Z","category":["Autosar"],"tag":["CAN","协议"],"star":true,"isOriginal":false,"article":true,"timeline":true,"description":"本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Autosar can协议栈\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-03T12:28:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"孤星旅记\\",\\"url\\":\\"https://binkyle.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://binkyle.github.io/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Autosar/autosar_can_protocol.html"}],["meta",{"property":"og:site_name","content":"孤星旅记"}],["meta",{"property":"og:title","content":"Autosar can协议栈"}],["meta",{"property":"og:description","content":"本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-03T12:28:44.000Z"}],["meta",{"property":"article:tag","content":"协议"}],["meta",{"property":"article:tag","content":"CAN"}],["meta",{"property":"article:published_time","content":"2023-12-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-03T12:28:44.000Z"}]]},"git":{"createdTime":1703048232000,"updatedTime":1748953724000,"contributors":[{"name":"cxqd","username":"cxqd","email":"xb142857@outlook.com","commits":4,"url":"https://github.com/cxqd"}]},"readingTime":{"minutes":4.72,"words":1416},"filePathRelative":"技术笔记/Autosar/autosar_can_protocol.md","excerpt":"<p>本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略</p>\\n","autoDesc":true}');export{f as comp,x as data};
