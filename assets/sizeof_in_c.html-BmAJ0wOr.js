import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as t,a,d as n,o as p}from"./app-CUS-QytW.js";const o={};function d(l,i){return p(),s("div",null,[i[0]||(i[0]=t("p",null,"本文主要介绍C语言中sizeof的原理分析",-1)),a(" more "),i[1]||(i[1]=n(`<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p><code>sizeof</code> 是 C 语言的一个运算符，用于返回一个对象或数据类型的大小，以字节为单位。<code>sizeof</code> 运算符在编译时计算，不会执行实际的运算。</p><p>由于 <code>sizeof</code> 是编译时计算大小的，其实现是由编译器提供的，而不是由标准 C 库提供的函数。因此，<code>sizeof</code> 的实现通常依赖于编译器和目标体系结构。</p><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h2><p>以下是 <code>sizeof</code> 运算符的一种可能的简化实现，假设一个字节等于 8 比特：</p><p>test.c文件</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SIZEOF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ((</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((type</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 示例用法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> size </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SIZEOF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个宏的工作原理是，将一个空指针转换为类型 <code>type*</code>，然后取数组的第一个元素的地址。由于数组索引是从零开始的，<code>&amp;((type*)0)[1]</code> 计算出第一个元素之后的地址。然后，整个表达式被强制转换为 <code>size_t</code> 类型，以表示大小。</p><p>需要注意的是，这只是一个简化的例子，实际的实现可能更为复杂，以处理各种类型和体系结构。实际的 <code>sizeof</code> 实现通常是由编译器内部提供的，因为它需要考虑各种编译器和目标平台的特定细节。</p><h3 id="代码分析" tabindex="-1"><a class="header-anchor" href="#代码分析"><span>代码分析</span></a></h3><p><code>(size_t)(&amp;((type*)0)[1])</code> 的运算顺序可以分解为以下步骤：</p><ol><li><code>(type*)0</code>: 将整数 0 转换为指向类型 <code>type</code> 的指针，得到一个指向类型 <code>type</code> 的空指针。</li><li><code>((type*)0)[1]</code>: 使用上一步得到的空指针进行数组操作，取得数组的第二个元素。这等效于 <code>( ((type*)0) + 1)</code>。请注意，这里并没有实际的数组，只是利用了指针运算的语法。</li><li><code>&amp;((type*)0)[1]</code>: 取得数组第二个元素的地址。</li><li><code>(size_t)(&amp;((type*)0)[1])</code>: 将这个地址转换为 <code>size_t</code> 类型。</li></ol><p>整个表达式的目的是计算一个指向类型 <code>type</code> 的指针，指向一个虚构的数组的第二个元素，然后获取这个元素的地址，并将其转换为 <code>size_t</code> 类型。这种技巧通常用于计算结构体或数组的大小，而无需创建实际的实例。</p><p>通过将test.c文件编译成汇编文件可发现：</p><p><code>SIZEOF(int)</code> 对应汇编文件中的 <code>movq $4, -8(%rbp)</code>，将值 4 存储在相对于 <strong><code>%rbp</code></strong> 偏移为 -8 的位置。</p><p><code>SIZEOF(double)</code> 对应汇编文件中的<code>movq $8, -8(%rbp)</code>，将值 8 存储在相对于 <strong><code>%rbp</code></strong> 偏移为 -8 的位置。</p><p>可见将整数 0 转换为指向类型 <code>type</code> 的指针，得到一个指向类型 <code>type</code> 的空指针时<code>type[0]</code>的地址为0，<code>((type*)0)[1]</code>的偏移量即为type的字节大小，从而可获取type的字节大小</p>`,17))])}const h=e(o,[["render",d]]),k=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/sizeof_in_c.html","title":"C语言sizeof宏分析","lang":"zh-CN","frontmatter":{"title":"C语言sizeof宏分析","icon":"file","order":1,"date":"2023-12-09T00:00:00.000Z","category":["编程语言"],"tag":["C语言","siezof"],"star":true,"isOriginal":true,"article":true,"timeline":true,"description":"本文主要介绍C语言中sizeof的原理分析","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C语言sizeof宏分析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-09T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-03T12:28:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"孤星旅记\\",\\"url\\":\\"https://binkyle.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://binkyle.github.io/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/sizeof_in_c.html"}],["meta",{"property":"og:site_name","content":"孤星旅记"}],["meta",{"property":"og:title","content":"C语言sizeof宏分析"}],["meta",{"property":"og:description","content":"本文主要介绍C语言中sizeof的原理分析"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-03T12:28:44.000Z"}],["meta",{"property":"article:tag","content":"siezof"}],["meta",{"property":"article:tag","content":"C语言"}],["meta",{"property":"article:published_time","content":"2023-12-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-03T12:28:44.000Z"}]]},"git":{"createdTime":1703050150000,"updatedTime":1748953724000,"contributors":[{"name":"cxqd","username":"cxqd","email":"xb142857@outlook.com","commits":4,"url":"https://github.com/cxqd"}]},"readingTime":{"minutes":2.94,"words":881},"filePathRelative":"技术笔记/编程语言/C/sizeof_in_c.md","excerpt":"<p>本文主要介绍C语言中sizeof的原理分析</p>\\n","autoDesc":true}');export{h as comp,k as data};
